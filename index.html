<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>√âditeur de Points 3D</title>
    <!-- IMPORTANT: La biblioth√®que Three.js et OrbitControls seront charg√©es ici par votre JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- Ajout de Font Awesome pour les ic√¥nes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }

      #container {
        width: 100vw;
        height: 100vh;
        /* Le container principal du viewer 3D */
        position: relative;
        /* N√©cessaire pour positionner les boutons de cam√©ra √† l'int√©rieur */
      }

      #panel {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(255, 255, 255, 0.95);
        /* AUGMENTER LE PADDING HAUT POUR FAIRE DE LA PLACE AU BOUTON */
        padding: 65px 20px 20px 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        max-height: 90vh;
        overflow-y: auto;
        width: 320px;
        transition: transform 0.3s ease;
        z-index: 999;
      }

      #panel.hidden {
        /* D√©place le panneau de 100% de sa largeur + sa marge de 20px */
        transform: translateX(calc(-100% - 20px));
      }

      #toggleBtn {
        position: absolute;
        top: 15px;
        left: 15px;
        background: transparent;
        z-index: 1001;
      }

      .burger-line {
        width: 20px;
        height: 2px;
        background-color: #333;
        transition: all 0.3s ease;
      }
      #openBtn {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(255, 255, 255, 0.95);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        z-index: 998;
        display: none; /* La logique d'affichage reste la m√™me */
      }

      #openBtn.show {
        display: flex;
      }

      h3 {
        /* On retire la marge qui sera maintenant g√©r√©e par flexbox */
        margin: 0;
        font-size: 18px;
        color: #333;
      }
      .section-header {
        display: flex;
        align-items: center;
        gap: 12px; /* Espace entre l'ic√¥ne et le titre */
      }
      .header-icon {
        font-size: 20px;
        width: 24px; /* Largeur fixe pour un alignement parfait */
        text-align: center;
        flex-shrink: 0; /* Emp√™che l'ic√¥ne de r√©tr√©cir */
      }

      .section-header h3 {
        font-size: 16px;
        font-weight: bold;
        flex-grow: 1; /* Le titre prend toute la place restante */
      }
      .section {
        margin-bottom: 10px;
        padding-bottom: 0px;
        border-bottom: 1px solid #ddd;
      }
      .section:last-of-type {
        border-bottom: none;
        margin-bottom: 0;
      }

      .input-group {
        margin-bottom: 10px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        font-size: 13px;
        font-weight: bold;
        color: #555;
      }

      input,
      select,
      textarea {
        width: 100%;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 13px;
        box-sizing: border-box;
      }

      .coord-inputs {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 8px;
      }

      .coord-inputs input {
        width: 100%;
      }

      button {
        width: 100%;
        margin: 8px 0;
        padding: 10px;
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
      }

      button:hover {
        background: #45a049;
      }

      .btn-secondary {
        background: #2196f3;
      }

      .btn-secondary:hover {
        background: #0b7dda;
      }

      .btn-danger {
        background: #f44336;
      }

      .btn-danger:hover {
        background: #da190b;
      }

      .btn-warning {
        background: #ff9800;
      }

      .btn-warning:hover {
        background: #e68900;
      }

      .btn-violet {
        background: #8a2be2;
        /* Un violet bien visible */
      }

      .btn-violet:hover {
        background: #7a25c4;
        /* Un peu plus fonc√© au survol */
      }

      .btn-violet-light {
        background: #9370db;
        /* Un violet plus clair (MediumPurple) */
      }

      .btn-violet-light:hover {
        background: #825fbc;
        /* Un peu plus fonc√© au survol */
      }

      .point-list,
      .geometry-list {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 5px;
        background: #f9f9f9;
      }

      /* --- STYLES R√âVIS√âS POUR TOUTES LES LISTES --- */
      .point-item,
      .geometry-item {
        padding: 8px;
        margin: 5px 0;
        background: white;
        border-radius: 4px;
        display: flex;
        flex-direction: column; /* Force les enfants (lignes) √† s'empiler */
        align-items: stretch; /* Les enfants prennent toute la largeur */
        font-size: 13px;
        border: 1px solid #eee; /* Bordure subtile pour mieux d√©limiter les items */
      }

      /* Ligne principale (contient nom/infos et boutons) */
      /* Ligne principale (contient nom/infos et boutons) */
      .geometry-item-main {
        display: flex;
        justify-content: space-between;

        /* LA CORRECTION CL√â EST ICI : */
        align-items: flex-start; /* Aligne les √©l√©ments sur le haut */

        width: 100%;
        gap: 10px; /* Espace entre la zone de texte et les boutons */
      }

      /* Conteneur pour le nom et les infos (coordonn√©es, etc.) */
      .geometry-info {
        flex-grow: 1; /* Prend l'espace disponible */
        display: flex;
        flex-direction: row; /* Aligne les enfants horizontalement */
        align-items: center; /* Centre verticalement le nom et les coordonn√©es sur la m√™me ligne */
        gap: 8px; /* Espace horizontal de 8px entre le nom et les coordonn√©es */
        flex-wrap: wrap; /* Permet le retour √† la ligne si le nom est tr√®s long */
      }

      .point-name,
      .geometry-name {
        font-weight: bold;
        color: #333;
        font-size: 13px;
        white-space: normal; /* Permet au texte de passer √† la ligne */
        word-break: break-word; /* Coupe les mots tr√®s longs si n√©cessaire */
      }

      .geometry-coords,
      .geometry-details {
        font-size: 12px; /* Police l√©g√®rement plus petite pour les d√©tails */
        color: #666; /* Couleur plus discr√®te pour les informations secondaires */
        white-space: normal;
        word-break: break-word;
      }

      /* Ligne secondaire (utilis√©e pour la norme du vecteur) */
      .geometry-details-secondary {
        font-size: 11px;
        color: #666;
        margin-top: 4px;
        padding-left: 2px;
      }

      /* Conteneur des boutons */
      .geometry-actions {
        display: flex;
        gap: 5px;
        flex-shrink: 0; /* Emp√™che les boutons de se compresser */
      }

      .geometry-actions button {
        width: auto;
        padding: 5px 8px; /* Un peu moins de padding pour √™tre plus compact */
        font-size: 11px;
        margin: 0;
      }

      /* --- STYLES POUR LES CONTR√îLES DE CAM√âRA (√Ä RESTAURER) --- */
      #cameraControls {
        position: absolute;
        top: 20px;
        right: 20px;
        /* RESTE TOUJOURS √Ä DROITE */
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 990;
      }

      .camera-btn {
        width: 40px;
        height: 40px;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #f0f0f0;
        border: 1px solid #ccc;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s, border-color 0.2s, color 0.2s;
        color: #333;
        font-size: 18px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .camera-btn:hover {
        background-color: #e0e0e0;
      }

      /* Style pour le bouton actif (celui qui est s√©lectionn√©) */
      .camera-btn.active {
        background-color: #007bff;
        color: white;
        border-color: #007bff;
      }

      /* Icones pour les vues */
      .fa-cube {
        transform: rotateX(20deg) rotateY(-20deg);
      }

      .equation-display {
        background: #e9e9e9;
        padding: 10px;
        border-radius: 4px;
        font-family: "Courier New", monospace;
        font-size: 13px;
        color: #333;
        min-height: 20px;
        display: block;
        text-align: left;
        word-break: break-all;
      }

      .sub-section-title {
        font-size: 13px;
        margin-top: 10px;
        margin-bottom: 10px;
        color: #444;
      }

      /* --- STYLES POUR LE MENU CONTEXTUEL --- */
      .context-menu {
        position: fixed; /* CHANGEMENT : fixed au lieu de absolute */
        top: 0;
        left: 0;
        z-index: 2147483647; /* Le maximum possible en CSS */
        background-color: #ffffff;
        border: 1px solid #999;
        box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.5);
        border-radius: 4px;
        padding: 5px 0;
        min-width: 160px;
        font-family: Arial, sans-serif;
        display: none; /* Cach√© par d√©faut */
      }

      .context-menu-items {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      .context-menu-items li {
        padding: 8px 15px;
        font-size: 14px;
        color: #333;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        /* Espace entre l'ic√¥ne et le texte */
      }

      .context-menu-items li:hover {
        background-color: #f0f0f0;
      }

      .context-menu-items li i {
        color: #555;
        /* Couleur des ic√¥nes */
      }

      /* --- FIN DES STYLES POUR LE MENU CONTEXTUEL --- */

      .edit-actions-container {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        /* Trois colonnes de largeur √©gale */
        gap: 8px;
        /* Espace entre les boutons */
        margin-top: 10px;
      }

      .edit-actions-container button {
        font-size: 12px;
        margin: 0;
        /* Annule la marge par d√©faut des boutons */
        width: 100%;
        /* Fait en sorte que chaque bouton remplisse sa colonne */
        padding: 10px 5px;
        /* Ajuste le padding pour les textes plus courts */
      }

      .section.collapsible .section-header {
        cursor: pointer;
        position: relative;
      }

      .section.collapsible.collapsed .section-content {
        display: none;
      }

      .section.collapsible .section-header::after {
        content: "‚ñ≤";
        font-size: 12px;
        color: #666;
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        transition: transform 0.3s ease;
      }

      .section.collapsible.collapsed .section-header::after {
        transform: translateY(-50%) rotate(180deg);
      }

      /* --- FIN DE L'AJOUT --- */

      @media (max-width: 768px) {
        /* Le panneau prend toute la largeur et hauteur de l'√©cran */
        #panel {
          position: absolute;
          top: 20px;
          left: 20px;
          background: rgba(255, 255, 255, 0.95);
          padding: 65px 20px 20px 20px;
          border-radius: 8px;
          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
          max-height: 90vh;
          overflow-y: auto;

          /* --- MODIFICATIONS PRINCIPALES --- */
          width: fit-content; /* Le panneau s'adapte √† son contenu */
          min-width: 280px; /* On garde une largeur minimale pour une bonne lisibilit√© */
          /* --- FIN DES MODIFICATIONS --- */

          transition: transform 0.3s ease;
          z-index: 999;
        }

        /* Ajuste la position du panneau une fois cach√© */
        #panel.hidden {
          transform: translateX(calc(-100% - 20px));
        }

        /* On s'assure que le bouton "Ouvrir" est bien visible */
        #openBtn {
          top: 15px;
          left: 15px;
        }

        .camera-btn svg {
          width: 20px;
          height: 20px;
          pointer-events: none;
        }
      }
      /* --- STYLES POUR LE SPLASH SCREEN (NOTIFICATION) --- */
      #splashScreen {
        position: fixed; /* Reste en place m√™me si on fait d√©filer la page */
        top: 50px; /* Un peu en dessous du haut de la page */
        left: 50%; /* Centr√© horizontalement */
        transform: translateX(-50%); /* Ajustement final pour un centrage parfait */

        background-color: rgba(40, 40, 40, 0.9); /* Fond sombre semi-transparent */
        color: white;
        padding: 12px 25px;
        border-radius: 25px; /* Bords bien arrondis */
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);

        z-index: 10001; /* Doit √™tre au-dessus de tout le reste (m√™me le menu contextuel) */
        font-size: 14px;
        font-weight: bold;

        /* Animation de transition douce */
        transition: opacity 0.5s ease-in-out, top 0.5s ease-in-out;
      }

      /* Classe pour cacher le splash screen */
      #splashScreen.splash-hidden {
        opacity: 0;
        top: -100px; /* Le fait "monter" hors de l'√©cran */
        pointer-events: none; /* Emp√™che de cliquer dessus quand il est invisible */
      }
      #panel.no-transition {
        transition: none;
      }
      /* --- NOUVEAU : Style unifi√© pour les boutons burger --- */
      .burger-btn {
        width: 40px;
        height: 40px;
        padding: 8px; /* Assure un espacement interne coh√©rent */
        border-radius: 6px;
        cursor: pointer;
        border: none;

        /* Utilisation de flexbox pour centrer parfaitement les lignes */
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 4px;
      }

      .burger-btn:hover {
        background-color: rgba(0, 0, 0, 0.05) !important; /* Effet de survol unifi√© */
      }
    </style>
  </head>

  <body>
    <div id="splashScreen" class="splash-hidden">
      <span id="splashMessage"></span>
    </div>
    <button id="openBtn" class="burger-btn show" onclick="togglePanel()">
      <span class="burger-line"></span>
      <span class="burger-line"></span>
      <span class="burger-line"></span>
    </button>
    <div id="container">
      <div id="cameraControls">
        <!-- Vue de dessus (XY) : La face sup√©rieure du cube est noire -->
        <div class="camera-btn" id="btnTop" onclick="setCameraView('top', this)" title="Vue de dessus (XY)">
          <svg width="40" height="40" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
            <!-- Face du dessus (noire) -->
            <polygon points="5,15 25,5 45,15 25,25" fill="#222222" />
            <!-- Face de droite (claire) -->
            <polygon points="45,15 45,35 25,45 25,25" fill="#e6e6e6" />
            <!-- Face de gauche (moyenne) -->
            <polygon points="5,15 5,35 25,45 25,25" fill="#cacaca" />
          </svg>
        </div>

        <!-- Vue de face (XZ) : La face de "gauche" (qui repr√©sente l'avant) est noire -->
        <div class="camera-btn" id="btnFront" onclick="setCameraView('front', this)" title="Vue de face (XZ)">
          <svg width="40" height="40" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
            <!-- Face du dessus (moyenne) -->
            <polygon points="5,15 25,5 45,15 25,25" fill="#cacaca" />
            <!-- Face de droite (claire) -->
            <polygon points="45,15 45,35 25,45 25,25" fill="#e6e6e6" />
            <!-- Face de gauche/avant (noire) -->
            <polygon points="5,15 5,35 25,45 25,25" fill="#222222" />
          </svg>
        </div>

        <!-- Vue de c√¥t√© (YZ) : La face de "droite" (qui repr√©sente le c√¥t√©) est noire -->
        <div class="camera-btn" id="btnSide" onclick="setCameraView('side', this)" title="Vue de c√¥t√© (YZ)">
          <svg width="40" height="40" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
            <!-- Face du dessus (moyenne) -->
            <polygon points="5,15 25,5 45,15 25,25" fill="#cacaca" />
            <!-- Face de droite/c√¥t√© (noire) -->
            <polygon points="45,15 45,35 25,45 25,25" fill="#222222" />
            <!-- Face de gauche (claire) -->
            <polygon points="5,15 5,35 25,45 25,25" fill="#e6e6e6" />
          </svg>
        </div>

        <div class="camera-btn" id="btnReset" onclick="resetCamera(this)" title="R√©initialiser la vue (Isom√©trique)">
          <i class="fas fa-sync-alt"></i>
        </div>
      </div>

      <!-- FIN NOUVEAU -->
    </div>
    <div id="panel" class="hidden">
      <button id="toggleBtn" class="burger-btn" onclick="togglePanel()">
        <span class="burger-line"></span>
        <span class="burger-line"></span>
        <span class="burger-line"></span>
      </button>
      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üíæ Gestion des Sc√®nes</h3>
        </div>
        <div class="section-content">
          <label>Nom de la sc√®ne :</label>
          <input type="text" id="sceneNameInput" placeholder="Ex: Ma Sc√®ne 1" />
          <button class="btn-secondary" onclick="saveScene()">üíæ Enregistrer la sc√®ne</button>

          <h4 class="sub-section-title" style="margin-top: 20px">Charger une sc√®ne :</h4>
          <label>Sc√®nes sauvegard√©es :</label>
          <select id="savedScenesSelect" style="margin-bottom: 8px"></select>

          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px">
            <button class="btn-violet" onclick="loadScene()">üîÑ Charger</button>
            <button class="btn-danger" onclick="deleteScene()">üóëÔ∏è Supprimer</button>
          </div>
        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üìç Tracer des points</h3>
        </div>
        <div class="section-content">
          <label>Nom du point :</label>
          <input type="text" id="pointName" placeholder="Ex: A, Point1..." />

          <label style="margin-top: 10px">Coordonn√©es (X, Y, Z) :</label>
          <div class="coord-inputs">
            <input type="number" id="pointX" placeholder="X" step="1" />
            <input type="number" id="pointY" placeholder="Y (Profondeur)" step="1" />
            <input type="number" id="pointZ" placeholder="Z (Hauteur)" step="1" />
          </div>

          <!-- Bouton d'ajout de point, visible par d√©faut -->
          <button id="addPointBtn" onclick="addPoint()">‚ûï Ajouter le point</button>

          <!-- NOUVEAU : Conteneur pour les boutons d'action d'√©dition des points -->
          <input type="hidden" id="editPointIndex" />
          <div id="pointEditActions" class="edit-actions-container" style="display: none">
            <button id="updatePointBtn" class="btn-secondary" onclick="updatePoint()">üíæ Mettre √† jour</button>
            <button id="deleteEditingPointBtn" class="btn-danger" onclick="deleteEditingPoint()">üóëÔ∏è Supprimer</button>
            <button id="cancelEditBtn" class="btn-warning" onclick="cancelEdit()">‚ùå Annuler</button>
          </div>
        </div>
        <div class="section-content">
          <div id="pointList" class="point-list"></div>
          <button class="btn-danger" onclick="clearAllPoints()">üóëÔ∏è Effacer tous les points</button>
        </div>
        <div class="section-content">
          <div class="checkbox-group">
            <input type="checkbox" id="autoLoadTestPointsCheckbox" onchange="toggleAutoLoadTestPoints()" />
            <label for="autoLoadTestPointsCheckbox">Charger A, B, C au d√©marrage</label>
          </div>
          <button class="btn-secondary" onclick="loadTestPointsOnce()">‚ûï Charger points A, B, C maintenant</button>
          <p style="font-size: 11px; color: #666; margin-top: 5px"></p>
        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">‚ÜóÔ∏è Tracer des vecteurs</h3>
        </div>
        <div class="section-content">
          <h4 class="sub-section-title">Vecteur entre deux points :</h4>
          <label>Point de d√©part :</label>
          <select id="vectorStartPoint"></select>

          <label style="margin-top: 10px">Point d'arriv√©e :</label>
          <select id="vectorEndPoint"></select>

          <button id="addVectorFromPointsBtn" class="btn-secondary" onclick="addVectorFromPoints()">
            ‚ûï Tracer le vecteur
          </button>

          <h4 class="sub-section-title">Vecteur par coordonn√©es :</h4>
          <label>Nom du vecteur :</label>
          <input type="text" id="vectorNameCoords" placeholder="Ex: V1, Direction..." />

          <label style="margin-top: 10px">Coordonn√©es (Vx, Vy, Vz) :</label>
          <div class="coord-inputs">
            <input type="number" id="vectorCoordX" placeholder="Vx" step="1" />
            <input type="number" id="vectorCoordY" placeholder="Vy" step="1" />
            <input type="number" id="vectorCoordZ" placeholder="Vz" step="1" />
          </div>

          <label style="margin-top: 10px">Origine du vecteur :</label>
          <select id="vectorOriginPoint"></select>
          <button id="addVectorFromCoordsBtn" class="btn-secondary" onclick="addVectorFromCoords()">
            ‚ûï Tracer le vecteur
          </button>

          <input type="hidden" id="editVectorId" />

          <!-- NOUVEAU : Conteneur pour les boutons d'action d'√©dition -->
          <div id="vectorEditActions" class="edit-actions-container" style="display: none">
            <button id="updateVectorBtn" class="btn-secondary" onclick="updateVector()">üíæ Mettre √† jour</button>
            <button id="deleteEditingVectorBtn" class="btn-danger" onclick="deleteEditingVector()">üóëÔ∏è Supprimer</button>
            <button id="cancelVectorEditBtn" class="btn-warning" onclick="cancelVectorEdit()">‚ùå Annuler</button>
          </div>

          <h4 class="sub-section-title">Vecteurs existants :</h4>
          <div id="vectorList" class="geometry-list"></div>
          <button class="btn-danger" onclick="clearAllVectors()">üóëÔ∏è Effacer tous les vecteurs</button>
        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üìè Tracer des droites</h3>
        </div>
        <div class="section-content">
          <h4 class="sub-section-title">Droite par deux points :</h4>
          <label>Premier point :</label>
          <select id="lineStart"></select>
          <label style="margin-top: 10px">Deuxi√®me point :</label>
          <select id="lineEnd"></select>
          <button class="btn-secondary" onclick="addStraightLine()">‚ûï Tracer la droite</button>

          <h4 class="sub-section-title">Droite par √©quation param√©trique :</h4>
          <label>Nom de la droite :</label>
          <input type="text" id="lineNameFromEquation" placeholder="Ex: D1, MaDroite..." />
          <label>√âquations (une par ligne) :</label>
          <textarea
            id="lineEquationInput"
            rows="3"
            placeholder="x = 1 + 2t&#10;y = -3 + t&#10;z = 4 - 5t"
            style="font-family: monospace"
          ></textarea>
          <button class="btn-secondary" onclick="addLineFromEquation()">‚ûï Cr√©er la droite</button>

          <h4 class="sub-section-title">Droites existantes :</h4>
          <div id="lineList" class="geometry-list"></div>
          <button class="btn-danger" onclick="clearStraightLines()">üóëÔ∏è Effacer les droites</button>
        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üî∑ Tracer des plans</h3>
        </div>
        <div class="section-content">
          <h4 class="sub-section-title">Plan par 3 points :</h4>
          <label>Nom du plan :</label>
          <input type="text" id="planeName" placeholder="Ex: P1, MonPlan..." />

          <label style="margin-top: 10px">Premier point :</label>
          <select id="planeSelectP1"></select>

          <label style="margin-top: 10px">Deuxi√®me point :</label>
          <select id="planeSelectP2"></select>

          <label style="margin-top: 10px">Troisi√®me point :</label>
          <select id="planeSelectP3"></select>

          <button class="btn-warning" onclick="addPlane()">‚ûï Ajouter ce plan</button>

          <h4 class="sub-section-title">Plan par √©quation :</h4>
          <label>√âquation cart√©sienne (ax+by+cz+d=0) :</label>
          <input type="text" id="planeEquationInput" placeholder="Ex: 2x - y + 3z - 6 = 0" />
          <button class="btn-warning" onclick="addPlaneFromEquation()">‚ûï Cr√©er le plan depuis l'√©quation</button>

          <h4 class="sub-section-title">Plans existants :</h4>
          <div id="planeList" class="geometry-list"></div>
          <button class="btn-danger" onclick="clearAllPlanes()">üóëÔ∏è Effacer tous les plans</button>
        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üìà √âquations g√©om√©triques</h3>
        </div>
        <div class="section-content">
          <h4 class="sub-section-title">√âquation de plan :</h4>
          <label>S√©lectionner un plan pour voir son √©quation :</label>
          <select id="equationPlaneSelect" onchange="displayPlaneEquation()"></select>
          <div id="planeEquationDisplay" class="equation-display"></div>

          <h4 class="sub-section-title" style="margin-top: 20px">√âquation param√©trique de droite :</h4>
          <label>S√©lectionner une droite pour voir son √©quation :</label>
          <select id="equationLineSelect" onchange="displayLineEquation()"></select>

          <div id="lineEquationDisplay" class="equation-display"></div>
        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üßÆ Calculs</h3>
        </div>
        <div class="section-content">
          <!-- Outils de Mesure -->
          <h4 class="sub-section-title" style="margin-top: 20px">Op√©rations sur les Vecteurs</h4>

          <!-- Somme de vecteurs -->
          <label>Somme de deux vecteurs \(\vec{u} + \vec{v}\) :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="sumVectorSelect1"></select>
            <select id="sumVectorSelect2"></select>
          </div>

          <label>Point de d√©part (pour la construction ou le vecteur libre) :</label>
          <select id="sumVectorOrigin" style="margin-bottom: 8px"></select>

          <!-- MODIFICATION: Boutons pour des actions distinctes -->
          <button class="btn-violet" onclick="calculateVectorSumFree()">üñ© Cr√©er le vecteur somme (libre)</button>
          <button class="btn-warning" onclick="constructChaslesSum()">üìê Construire la somme (Chasles)</button>

          <!-- NOUVEAU: Bouton pour nettoyer la construction, cach√© par d√©faut -->
          <button
            class="btn-danger"
            onclick="clearChaslesConstruction()"
            style="display: none; margin-top: 5px"
            id="clearChaslesBtn"
          >
            üóëÔ∏è Effacer la construction
          </button>

          <div id="vectorSumResult" class="equation-display"></div>

          <!-- Produit Scalaire -->
          <label style="margin-top: 15px">Produit scalaire de deux vecteurs \( \vec{u} \cdot \vec{v} \) :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="dotVectorSelect1"></select>
            <select id="dotVectorSelect2"></select>
          </div>
          <button class="btn-warning" onclick="calculateScalarProduct()">üñ© Calculer</button>
          <div id="scalarProductResult" class="equation-display"></div>

          <!-- Produit Vectoriel -->
          <label style="margin-top: 15px">Produit vectoriel de deux vecteurs \( \vec{u} \wedge \vec{v} \) :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="crossVectorSelect1"></select>
            <select id="crossVectorSelect2"></select>
          </div>
          <label>Origine du vecteur produit :</label>
          <select id="crossVectorOrigin" style="margin-bottom: 8px"></select>
          <button class="btn-warning" onclick="calculateVectorProduct()">üñ© Cr√©er le vecteur produit</button>
          <div id="vectorProductResult" class="equation-display"></div>
        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üìê Mesures et Intersections</h3>
        </div>
        <div class="section-content">
          <!-- Outils de Mesure -->
          <h4 class="sub-section-title">Mesure de Distances</h4>

          <!-- Distance Point-Point -->
          <label>Distance entre deux points :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="distPointSelect1"></select>
            <select id="distPointSelect2"></select>
          </div>
          <button class="btn-warning" onclick="calculatePointPointDistance()">üñ© Mesurer</button>
          <div id="distResult1" class="equation-display"></div>

          <!-- Distance Point-Droite -->
          <label style="margin-top: 15px">Distance d'un point √† une droite :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="distPointSelect3"></select>
            <select id="distLineSelect1"></select>
          </div>
          <button class="btn-warning" onclick="calculatePointLineDistance()">üñ© Mesurer</button>
          <div id="distResult2" class="equation-display"></div>

          <!-- Distance Point-Plan -->
          <label style="margin-top: 15px">Distance d'un point √† un plan :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="calcPointSelect"></select>
            <select id="calcPlaneSelect1"></select>
          </div>
          <button class="btn-warning" onclick="calculatePointPlaneDistance()">üñ© Mesurer et projeter</button>
          <div id="calcResultDisplay1" class="equation-display" style="min-height: 50px"></div>

          <!-- Outils d'Angle -->
          <h4 class="sub-section-title" style="margin-top: 20px">Mesure d'Angles</h4>

          <!-- Angle Droite-Droite -->
          <label>Angle entre deux droites :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="angleLineSelect1"></select>
            <select id="angleLineSelect2"></select>
          </div>
          <button class="btn-warning" onclick="calculateLineLineAngle()">üñ© Mesurer</button>
          <div id="angleResult1" class="equation-display"></div>

          <!-- Angle Plan-Plan -->
          <label style="margin-top: 15px">Angle entre deux plans :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="anglePlaneSelect1"></select>
            <select id="anglePlaneSelect2"></select>
          </div>
          <button class="btn-warning" onclick="calculatePlanePlaneAngle()">üñ© Mesurer</button>
          <div id="angleResult2" class="equation-display"></div>

          <!-- Angle Droite-Plan -->
          <label style="margin-top: 15px">Angle entre une droite et un plan :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="angleLineSelect3"></select>
            <select id="anglePlaneSelect3"></select>
          </div>
          <button class="btn-warning" onclick="calculateLinePlaneAngle()">üñ© Mesurer</button>
          <div id="angleResult3" class="equation-display"></div>

          <!-- Intersections -->
          <h4 class="sub-section-title" style="margin-top: 20px">Calcul d'Intersections</h4>

          <!-- Intersection Droite-Plan -->
          <label>Intersection d'une droite et d'un plan :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="calcLineSelect"></select>
            <select id="calcPlaneSelect2"></select>
          </div>
          <button class="btn-warning" onclick="calculateLinePlaneIntersection()">üñ© Calculer l'intersection</button>
          <div id="calcResultDisplay2" class="equation-display"></div>

          <!-- Intersection Plan-Plan -->
          <label style="margin-top: 15px">Intersection de deux plans :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="calcPlaneSelect3"></select>
            <select id="calcPlaneSelect4"></select>
          </div>
          <button class="btn-warning" onclick="calculatePlanePlaneIntersection()">üñ© Calculer l'intersection</button>
          <div id="calcResultDisplay3" class="equation-display" style="min-height: 60px"></div>

          <!-- Intersection Droite-Droite -->
          <h4 class="sub-section-title" style="margin-top: 20px">Intersection de deux droites :</h4>
          <label>S√©lectionner les deux droites :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="calcLineSelect1"></select>
            <select id="calcLineSelect2"></select>
          </div>
          <button class="btn-warning" onclick="calculateLineLineIntersection()">üñ© Analyser l'intersection</button>
          <div id="calcResultDisplay4" class="equation-display" style="margin-top: 10px; min-height: 50px"></div>
        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üîÑ Transformations</h3>
        </div>
        <div class="section-content">
          <p id="transformations-hint" style="font-size: 12px; color: #888; text-align: center">
            Veuillez s√©lectionner un objet dans la sc√®ne 3D pour appliquer une transformation.
          </p>

          <!-- Sous-section Translation -->
          <div id="transformations-container" style="display: none">
            <h4 class="sub-section-title">Translation</h4>
            <label>Vecteur de translation (dX, dY, dZ) :</label>
            <div class="coord-inputs">
              <input type="number" id="transX" placeholder="dX" value="0" step="1" />
              <input type="number" id="transY" placeholder="dY" value="0" step="1" />
              <input type="number" id="transZ" placeholder="dZ" value="0" step="1" />
            </div>
            <button class="btn-secondary" onclick="applyTranslation()">‚û°Ô∏è Appliquer la Translation</button>

            <!-- Sous-section Rotation -->
            <h4 class="sub-section-title" style="margin-top: 20px">Rotation</h4>
            <label>Centre de rotation :</label>
            <select id="rotationCenterSelect">
              <option value="origin">Origine du rep√®re (0,0,0)</option>
              <!-- Les points seront ajout√©s dynamiquement ici -->
            </select>
            <label style="margin-top: 10px">Axe de rotation :</label>
            <select id="rotationAxisSelect">
              <option value="x">Axe X</option>
              <option value="y">Axe Y</option>
              <option value="z">Axe Z</option>
            </select>
            <label style="margin-top: 10px">Angle de rotation (en degr√©s) :</label>
            <input type="number" id="rotationAngle" value="90" step="1" />
            <button class="btn-secondary" onclick="applyRotation()">üîÑ Appliquer la Rotation</button>

            <!-- Sous-section Sym√©trie -->
            <h4 class="sub-section-title" style="margin-top: 20px">Sym√©trie</h4>
            <label>Sym√©trie par rapport √† :</label>
            <select id="symmetryTypeSelect" onchange="updateSymmetryUI()">
              <option value="">-- Choisir un type --</option>
              <option value="point">Un Point</option>
              <option value="line">Une Droite</option>
              <option value="plane">Un Plan</option>
            </select>
            <div id="symmetryOptionsContainer" style="margin-top: 10px">
              <!-- Les options (s√©lecteurs de point, droite, plan) appara√Ætront ici -->
            </div>
            <button class="btn-secondary" id="applySymmetryBtn" style="display: none" onclick="applySymmetry()">
              üîπ Appliquer la Sym√©trie
            </button>
          </div>
        </div>
      </div>
      <div style="text-align: center; font-size: 10px; color: #888; margin-top: 20px; padding-top: 5px">
        Copyright Michel ESPARSA 15/11/2025
      </div>

      <!-- START: HTML pour le menu contextuel -->
      <div id="contextMenu" class="context-menu" style="display: none">
        <ul id="contextMenuItems" class="context-menu-items">
          <!-- Les options du menu seront inject√©es ici par JavaScript -->
        </ul>
      </div>
      <!-- END: HTML pour le menu contextuel -->
    </div>
    <script>
      // =====================================================================================
      // SECTION 1 : CLASSES DES OBJETS G√âOM√âTRIQUES
      // =====================================================================================

      /**
       * Classe repr√©sentant un point 3D.
       */
      class Point {
        constructor(name, x, y, z, color = 0xff6b35, derivedFrom = null) {
          this.name = name;
          this.position = new THREE.Vector3(x, y, z);
          this.color = new THREE.Color(color);
          this.derivedFrom = derivedFrom;
          const sphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
          const sphereMaterial = new THREE.MeshPhongMaterial({
            color: this.color,
          });
          this.mesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
          this.mesh.position.copy(this.position);
          this.mesh.userData = { type: "point", instance: this };
          this.label = this.createTextLabel(name);
          this.updateLabelPosition();
        }
        // Dans la classe Point
        createTextLabel(text) {
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          canvas.width = 512;
          canvas.height = 256;

          // Vider le canvas pour un fond transparent
          context.clearRect(0, 0, canvas.width, canvas.height);

          context.font = "Bold 96px Arial";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.strokeStyle = "white";
          context.lineWidth = 12;
          context.strokeText(text, canvas.width / 2, canvas.height / 2);
          context.fillStyle = "black";
          context.fillText(text, canvas.width / 2, canvas.height / 2);

          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;

          // La correction est ici
          const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false, // Garantit que le label est toujours visible
          });

          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.scale.set(2, 1, 1);
          sprite.center.set(0.5, 0);
          return sprite;
        }

        updateLabelPosition() {
          this.label.position.set(this.position.x, this.position.y + 0.35, this.position.z);
        }
        update(name, x, y, z) {
          this.name = name;
          this.position.set(x, y, z);
          this.mesh.position.copy(this.position);
          scene.remove(this.label);
          this.label = this.createTextLabel(name);
          this.updateLabelPosition();
          scene.add(this.label);
        }
        addToScene(scene) {
          // On s'assure que les points ont un renderOrder plus √©lev√© que les axes
          this.mesh.renderOrder = 10;
          this.label.renderOrder = 11; // Les labels doivent √™tre au-dessus des points

          scene.add(this.mesh);
          scene.add(this.label);
        }
        removeFromScene(scene) {
          scene.remove(this.mesh);
          scene.remove(this.label);
          if (this.mesh.geometry) this.mesh.geometry.dispose();
          if (this.mesh.material) this.mesh.material.dispose();
          if (this.label.material) {
            if (this.label.material.map) this.label.material.map.dispose(); // Texture du texte
            this.label.material.dispose();
          }
        }
      }

      /**
       * Classe repr√©sentant une droite 3D.
       */
      class Line3D {
        constructor(name, startPoint, directorVector, color = 0x00ced1, derivedFrom = null) {
          this.id = nextStraightLineId++;
          this.name = name;
          this.startPoint = startPoint.clone();
          this.directorVector = directorVector.clone();
          this.color = new THREE.Color(color);
          this.derivedFrom = derivedFrom;
          this.isVisible = true; // La propri√©t√© existe d√©j√†, c'est parfait
          const lineLength = 100;
          const dir = this.directorVector.clone().normalize();
          const visualStart = new THREE.Vector3().addVectors(this.startPoint, dir.clone().multiplyScalar(-lineLength));
          const visualEnd = new THREE.Vector3().addVectors(this.startPoint, dir.clone().multiplyScalar(lineLength));
          const geometry = new THREE.BufferGeometry().setFromPoints([visualStart, visualEnd]);
          const material = new THREE.LineBasicMaterial({ color: this.color });
          this.mesh = new THREE.Line(geometry, material);
          this.mesh.userData = { type: "line", instance: this };
        }

        // --- NOUVELLE M√âTHODE √Ä AJOUTER ---
        setVisibility(visible) {
          this.isVisible = visible;
          this.mesh.visible = visible;
        }
        // --- FIN DE L'AJOUT ---

        addToScene(scene) {
          scene.add(this.mesh);
        }
        removeFromScene(scene) {
          scene.remove(this.mesh);
          if (this.mesh.geometry) this.mesh.geometry.dispose();
          if (this.mesh.material) this.mesh.material.dispose();
        }
      }
      /**
       * Classe repr√©sentant un plan 3D.
       */
      class Plane {
        constructor(
          name,
          pointOnPlane,
          normal, // C'est le vecteur AVANT normalisation
          color = 0xffeb3b,
          derivedFrom = null
        ) {
          this.id = nextPlaneId++;
          this.name = name;
          this.pointOnPlane = pointOnPlane.clone();

          // --- MODIFICATION ---
          // On stocke le vecteur original pour l'affichage des √©quations
          this.displayNormal = normal.clone();
          // On utilise le vecteur normalis√© pour le rendu 3D
          this.normal = normal.clone().normalize();
          // --- FIN DE LA MODIFICATION ---

          this.color = new THREE.Color(color);
          this.derivedFrom = derivedFrom;
          this.isVisible = true;
          const planeGeometry = new THREE.PlaneGeometry(15, 15);
          const planeMaterial = new THREE.MeshPhongMaterial({
            color: this.color,
            transparent: true,
            opacity: 0.4, // Opacit√© r√©duite pour une meilleure visibilit√© des axes
            side: THREE.DoubleSide,
            depthWrite: false, // Important pour la visibilit√© des axes
            polygonOffset: true, // √âvite les probl√®mes de z-fighting
            polygonOffsetFactor: 1, // Ajuste la profondeur du plan
            polygonOffsetUnits: 1,
          });
          this.mesh = new THREE.Mesh(planeGeometry, planeMaterial);
          this.mesh.position.copy(this.pointOnPlane);
          // La normalisation est importante pour la ligne suivante
          this.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), this.normal);
          this.mesh.userData = { type: "plane", instance: this };
        }
        // ... le reste de la classe (setVisibility, addToScene, etc.) ne change pas
        setVisibility(visible) {
          this.isVisible = visible;
          this.mesh.visible = visible;
        }
        addToScene(scene) {
          scene.add(this.mesh);
        }
        removeFromScene(scene) {
          scene.remove(this.mesh);
          if (this.mesh.geometry) this.mesh.geometry.dispose();
          if (this.mesh.material) this.mesh.material.dispose();
        }
      }
      /**
       * Classe repr√©sentant un vecteur 3D.
       */

      class Vector {
        constructor(name, origin, components, color = 0xffa500, derivedFrom = null) {
          this.id = nextVectorId++;
          this.name = name;
          this.origin = origin.clone();
          this.components = components.clone();
          this.color = new THREE.Color(color);
          this.derivedFrom = derivedFrom;
          this.isVisible = true;
          this.arrowHelper = null;

          // --- AJOUTS POUR L'√âTIQUETTE ---
          this.isLabelVisible = true; // Par d√©faut, l'√©tiquette est visible
          this.label = this.createTextLabel(name);
          this.updateLabelPosition();
          // --- FIN DES AJOUTS ---

          this.createArrowHelper();
        }

        // --- NOUVELLE M√âTHODE (copi√©e de la classe Point) ---
        createTextLabel(text) {
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          canvas.width = 512;
          canvas.height = 256;

          context.clearRect(0, 0, canvas.width, canvas.height);

          context.font = "Bold 96px Arial";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.strokeStyle = "white";
          context.lineWidth = 12;
          context.strokeText(text, canvas.width / 2, canvas.height / 2);
          context.fillStyle = "black";
          context.fillText(text, canvas.width / 2, canvas.height / 2);

          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;

          const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false,
          });

          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.scale.set(2, 1, 1);
          sprite.center.set(0.5, 0);
          return sprite;
        }

        // --- NOUVELLE M√âTHODE ---
        updateLabelPosition() {
          if (!this.label) return;
          // Positionne l'√©tiquette au milieu du vecteur
          const midPoint = new THREE.Vector3().addVectors(this.origin, this.components.clone().multiplyScalar(0.5));
          this.label.position.copy(midPoint);
          // On peut ajouter un petit d√©calage pour √©viter que ce soit directement sur la fl√®che
          this.label.position.y += 0.2;
        }

        // --- NOUVELLE M√âTHODE ---
        setLabelVisibility(visible) {
          this.isLabelVisible = visible;
          if (this.label) {
            this.label.visible = visible;
          }
        }

        createArrowHelper() {
          if (this.arrowHelper) this.removeFromScene(scene);
          const length = this.components.length();
          if (length > 1e-6) {
            this.arrowHelper = new THREE.ArrowHelper(
              this.components.clone().normalize(),
              this.origin,
              length,
              this.color,
              0.4,
              0.2
            );
            this.arrowHelper.line.userData = { type: "vector", instance: this };
            this.arrowHelper.cone.userData = { type: "vector", instance: this };
          } else {
            this.arrowHelper = null;
          }
        }

        update(name, origin, components) {
          this.name = name;
          this.origin.copy(origin);
          this.components.copy(components);

          // --- MISE √Ä JOUR DE L'√âTIQUETTE ---
          if (this.label) scene.remove(this.label);
          this.label = this.createTextLabel(name);
          this.updateLabelPosition();
          if (this.isVisible) scene.add(this.label);
          this.setLabelVisibility(this.isLabelVisible); // Applique la visibilit√© actuelle
          // --- FIN DE LA MISE √Ä JOUR ---

          this.createArrowHelper();
          this.addToScene(scene);
          this.setVisibility(this.isVisible);
        }

        setVisibility(visible) {
          this.isVisible = visible;
          if (this.arrowHelper) this.arrowHelper.visible = visible;
          // --- AJOUT ---
          // La visibilit√© globale du vecteur affecte aussi son √©tiquette
          if (this.label) this.label.visible = visible && this.isLabelVisible;
        }

        addToScene(scene) {
          if (this.arrowHelper) scene.add(this.arrowHelper);
          // --- AJOUT ---
          if (this.label) {
            this.label.renderOrder = 11; // Pour √™tre au-dessus des autres objets
            scene.add(this.label);
          }
        }

        removeFromScene(scene) {
          if (this.arrowHelper) scene.remove(this.arrowHelper);
          // --- AJOUT ---
          if (this.label) scene.remove(this.label);
        }
      }
      // =====================================================================================
      // SECTION 2 : GESTIONNAIRE CENTRAL DE LA G√âOM√âTRIE
      // =====================================================================================

      class GeometryManager {
        constructor(scene) {
          this.scene = scene;
          this.points = [];
          this.lines = [];
          this.planes = [];
          this.vectors = [];
        }
        /**
         * G√©n√®re un nom unique pour un type d'objet donn√© en ajoutant un suffixe si n√©cessaire.
         * @param {string} baseName Le nom de base souhait√©.
         * @param {string} objectType Le type d'objet : 'point', 'line', 'plane', ou 'vector'.
         * @returns {string} Un nom garanti unique.
         */
        generateUniqueName(baseName, objectType) {
          let nameList;
          // 1. S√©lectionner la bonne liste d'objets en fonction du type
          switch (objectType) {
            case "point":
              nameList = this.points.map((p) => p.name);
              break;
            case "line":
              nameList = this.lines.map((l) => l.name);
              break;
            case "plane":
              nameList = this.planes.map((p) => p.name);
              break;
            case "vector":
              nameList = this.vectors.map((v) => v.name);
              break;
            default:
              // Si le type est inconnu, on ne peut pas v√©rifier, on retourne le nom de base
              return baseName;
          }

          // 2. V√©rifier si le nom de base est d√©j√† pris
          if (!nameList.includes(baseName)) {
            return baseName; // Le nom est d√©j√† unique, on le retourne
          }

          // 3. Si le nom est pris, on cherche un suffixe
          let uniqueName = baseName;
          let counter = 1;
          do {
            uniqueName = `${baseName}_${counter}`;
            counter++;
          } while (nameList.includes(uniqueName));

          return uniqueName;
        }

        addPoint(point) {
          this.points.push(point);
          point.addToScene(this.scene);
        }
        addLine(line) {
          this.lines.push(line);
          line.addToScene(this.scene);
        }
        addPlane(plane) {
          this.planes.push(plane);
          plane.addToScene(this.scene);
        }
        addVector(vector) {
          this.vectors.push(vector);
          vector.addToScene(this.scene);
        }
        _removeInstance(array, instance) {
          const index = array.indexOf(instance);
          if (index > -1) {
            instance.removeFromScene(this.scene);
            array.splice(index, 1);
            return true;
          }
          return false;
        }
        removePoint(instance) {
          return this._removeInstance(this.points, instance);
        }
        removeLine(instance) {
          return this._removeInstance(this.lines, instance);
        }
        removePlane(instance) {
          return this._removeInstance(this.planes, instance);
        }
        removeVector(instance) {
          return this._removeInstance(this.vectors, instance);
        }
        findLineById(id) {
          return this.lines.find((l) => l.id === id);
        }
        findPlaneById(id) {
          return this.planes.find((p) => p.id === id);
        }
        findVectorById(id) {
          return this.vectors.find((v) => v.id === id);
        }

        findPointAt(position) {
          const tolerance = 0.01;
          for (const point of this.points) {
            if (point.position.distanceTo(position) < tolerance) {
              return point;
            }
          }
          return null;
        }
        findObjectByName(name) {
          const allObjects = [...this.points, ...this.lines, ...this.planes];
          return allObjects.find((obj) => obj.name === name);
        }

        clearAll() {
          [...this.points, ...this.lines, ...this.planes, ...this.vectors].forEach((obj) =>
            obj.removeFromScene(this.scene)
          );
          this.points = [];
          this.lines = [];
          this.planes = [];
          this.vectors = [];
          nextStraightLineId = 0;
          nextPlaneId = 0;
          nextVectorId = 0;
        }
      }

      // =====================================================================================
      // SECTION 3 : VARIABLES GLOBALES ET INITIALISATION
      // =====================================================================================

      let scene, camera, renderer, geometryManager;
      let isDragging = false,
        isPanning = false,
        wasDragged = false;
      let previousMousePosition = { x: 0, y: 0 };
      let cameraRotation = { x: 0.5, y: 0.5 };
      let cameraDistance = 15;
      let cameraTarget = new THREE.Vector3(0, 0, 0);
      let initialPinchDistance = 0;
      let panelOpen = false;
      let nextStraightLineId = 0;
      let nextPlaneId = 0;
      let nextVectorId = 0;
      let raycaster,
        mouse,
        selectedObjectInstance = null;
      // let wasPanningOrZooming = false; // Pour distinguer un geste cam√©ra d'un tap
      let currentConstructionObjects = [];
      let splashTimer = null;
      let blockNextClick = false; // Variable pour bloquer le "clic fant√¥me" sur mobile
      const HIGHLIGHT_COLOR = 0xffff00; // Jaune vif pour la surbrillance
      let longPressTimer = null;
      const LONG_PRESS_DURATION = 500;
      let touchStartPosition = { x: 0, y: 0 };
      const TOUCH_MOVE_TOLERANCE = 10; // Tol√©rance en pixels pour diff√©rencier un tap d'un drag
      // let rightClickedObjectInstance = null;

      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        return b === 0 ? a : gcd(b, a % b);
      }

      const swipeState = {
        isSwiping: false, // VRAI si un geste de balayage du panneau est en cours
        lock: null, // deviendra 'horizontal' ou 'vertical'
        startX: 0,
        startY: 0,
        panelStartTranslateX: 0,
      };
      const SWIPE_EDGE_ZONE = 40; // Zone de d√©tection sur le bord gauche

      function gcdOfThree(a, b, c) {
        return gcd(gcd(a, b), c);
      }

      function init() {
        scene = new THREE.Scene();
        geometryManager = new GeometryManager(scene);
        scene.background = new THREE.Color(0xf0f0f0);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("container").appendChild(renderer.domElement);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 15, 10);
        scene.add(directionalLight);
        createAxes();
        const gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xe0e0e0);
        // On place le quadrillage en arri√®re-plan avec un renderOrder n√©gatif
        gridHelper.renderOrder = -1;
        // On s'assure que le mat√©riau du quadrillage ne cache pas les objets derri√®re
        gridHelper.material.depthTest = false;
        scene.add(gridHelper);
        setupEventListeners();
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        const autoLoadCheckbox = document.getElementById("autoLoadTestPointsCheckbox");
        if (localStorage.getItem("autoLoadTestPoints") === "true") {
          autoLoadCheckbox.checked = true;
          addFixedTestPoints();
        }
        document.getElementById("lineEquationInput").value = "x = 1 + 2t\ny = -3 + 3t\nz = 4 - 5t";
        document.getElementById("planeEquationInput").value = "2x - y + 3z - 4 = 0";
        updateCameraPosition();
        animate();
        updateAllUI();
      }

      function formatNumber(value, decimalPlaces = 2) {
        if (typeof value !== "number" || isNaN(value)) {
          return value; // Retourne la valeur telle quelle si ce n'est pas un nombre
        }
        // V√©rifie si la valeur est "proche" d'un entier
        if (Math.abs(value - Math.round(value)) < 1e-6) {
          return Math.round(value).toString();
        }
        return value.toFixed(decimalPlaces);
      }

      // =====================================================================================
      // START: GESTION DES √âV√âNEMENTS FINALE ET V√âRIFI√âE
      // =====================================================================================

      // --- Variables globales pour la logique des interactions ---

      function setupEventListeners() {
        const canvas = renderer.domElement;
        const panel = document.getElementById("panel");

        canvas.addEventListener("contextmenu", onRightClick);
        canvas.addEventListener("click", onObjectClick);
        canvas.addEventListener("mousedown", onMouseDown);
        canvas.addEventListener("mousemove", onMouseMove);
        canvas.addEventListener("mouseup", onMouseUp);
        canvas.addEventListener("wheel", onWheel);

        document.addEventListener("touchstart", handleTouchStart, { passive: false });
        document.addEventListener("touchmove", handleTouchMove, { passive: false });
        document.addEventListener("touchend", handleTouchEnd);

        window.addEventListener("resize", onWindowResize);
        window.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            hideContextMenu();
            if (panelOpen) togglePanel();
            if (selectedObjectInstance) {
              deselectCurrentObject();
              cancelEdit();
              cancelVectorEdit();
            }
          }
        });

        document.addEventListener("mousedown", (e) => {
          const menu = document.getElementById("contextMenu");
          if (menu.style.display === "block" && !menu.contains(e.target)) {
            hideContextMenu();
          }
        });

        document.getElementById("contextMenu").addEventListener("mousedown", (e) => e.stopPropagation());

        const stopPropagation = (e) => e.stopPropagation();
        panel.addEventListener("mousedown", stopPropagation);
        panel.addEventListener("wheel", stopPropagation);
        panel.addEventListener("contextmenu", stopPropagation);
      }

      function onRightClick(event) {
        event.preventDefault();
        console.log("üëâ 1. Clic droit d√©tect√© √† :", event.clientX, event.clientY);
        findObjectAndShowMenu(event.clientX, event.clientY);
      }

      function onObjectClick(event) {
        if (blockNextClick) {
          blockNextClick = false;
          return;
        }
        if (wasDragged) return;
        performRaycastSelection(event.clientX, event.clientY);
      }

      function handleTouchStart(e) {
        wasDragged = false;
        // wasPanningOrZooming = false;
        clearTimeout(longPressTimer);
        longPressTimer = null;
        const touch = e.touches[0];

        const canStartOpening = !panelOpen && touch.clientX < SWIPE_EDGE_ZONE;
        const canStartClosing = panelOpen && e.target.closest("#panel");
        if (canStartOpening || canStartClosing) {
          swipeState.isSwiping = true;
          swipeState.lock = null;
          swipeState.startX = touch.clientX;
          swipeState.startY = touch.clientY;
          const panel = document.getElementById("panel");
          const panelRect = panel.getBoundingClientRect();
          swipeState.panelStartTranslateX = panel.classList.contains("hidden") ? -panelRect.width : 0;
          return;
        }

        swipeState.isSwiping = false;

        if (e.touches.length === 1) {
          isDragging = true;
          previousMousePosition = { x: touch.clientX, y: touch.clientY };
          touchStartPosition = { x: touch.clientX, y: touch.clientY };
          longPressTimer = setTimeout(() => {
            findObjectAndShowMenu(touchStartPosition.x, touchStartPosition.y);
            longPressTimer = null;
            isDragging = false;
          }, LONG_PRESS_DURATION);
        } else if (e.touches.length >= 2) {
          isPanning = true;
          // wasPanningOrZooming = true;
          clearTimeout(longPressTimer);
          longPressTimer = null;
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
          previousMousePosition = {
            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
            y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
          };
        }
      }

      function handleTouchMove(e) {
        if (swipeState.isSwiping) {
          const touch = e.touches[0];
          const deltaX = touch.clientX - swipeState.startX;
          const deltaY = touch.clientY - swipeState.startY;
          if (!swipeState.lock) {
            swipeState.lock = Math.abs(deltaX) > Math.abs(deltaY) ? "horizontal" : "vertical";
          }
          if (swipeState.lock === "horizontal") {
            e.preventDefault();
            const panel = document.getElementById("panel");
            panel.classList.add("no-transition");
            let newX = swipeState.panelStartTranslateX + deltaX;
            newX = Math.max(-panel.offsetWidth, Math.min(0, newX));
            panel.style.transform = `translateX(${newX}px)`;
          }
          return;
        }

        const touch = e.touches[0];
        if (longPressTimer) {
          const moveX = Math.abs(touch.clientX - touchStartPosition.x);
          const moveY = Math.abs(touch.clientY - touchStartPosition.y);
          if (moveX > TOUCH_MOVE_TOLERANCE || moveY > TOUCH_MOVE_TOLERANCE) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
          }
        }

        if (isDragging) {
          e.preventDefault();
          wasDragged = true;
          const dX = touch.clientX - previousMousePosition.x;
          const dY = touch.clientY - previousMousePosition.y;
          cameraRotation.y += dX * 0.005;
          cameraRotation.x += dY * 0.005;
          cameraRotation.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraRotation.x));
          updateCameraPosition();
          previousMousePosition = { x: touch.clientX, y: touch.clientY };
        } else if (isPanning && e.touches.length >= 2) {
          e.preventDefault();
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const pinch = Math.sqrt(dx * dx + dy * dy);
          zoomCamera((initialPinchDistance - pinch) * 0.1);
          initialPinchDistance = pinch;
          const mid = {
            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
            y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
          };
          panCamera(mid.x - previousMousePosition.x, mid.y - previousMousePosition.y);
          previousMousePosition = mid;
        }
      }

      function handleTouchEnd(e) {
        if (swipeState.isSwiping) {
          if (swipeState.lock === "horizontal") {
            const panel = document.getElementById("panel");
            panel.classList.remove("no-transition");
            panel.style.transform = "";
            const panelRect = panel.getBoundingClientRect();
            if (panelRect.left > -panel.offsetWidth / 2) {
              panelOpen = true;
              panel.classList.remove("hidden");
              document.getElementById("openBtn").classList.remove("show");
            } else {
              panelOpen = false;
              panel.classList.add("hidden");
              document.getElementById("openBtn").classList.add("show");
            }
          }
        } else {
          if (longPressTimer) {
            clearTimeout(longPressTimer);
            e.preventDefault();
            performRaycastSelection(touchStartPosition.x, touchStartPosition.y);
          }
        }
        swipeState.isSwiping = false;
        swipeState.lock = null;
        isDragging = false;
        isPanning = false;
        longPressTimer = null;
      }

      function getIntersectionResult(x, y) {
        // 1. Transformation des coordonn√©es (inchang√©)
        mouse.x = (x / window.innerWidth) * 2 - 1;
        mouse.y = -(y / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        // 2. Rassemblement des objets, MAIS avec un filtre sur la visibilit√©
        const meshes = [];

        // A. Points (s'ils ont une propri√©t√© isVisible ou via le mesh directly)
        // Par d√©faut vos points sont toujours visibles, mais on v√©rifie le mesh au cas o√π
        meshes.push(...geometryManager.points.filter((p) => p.mesh.visible).map((p) => p.mesh));

        // B. Droites (Seulement si isVisible est true)
        meshes.push(...geometryManager.lines.filter((l) => l.isVisible).map((l) => l.mesh));

        // C. Plans (C'est ici que votre probl√®me se r√©glait)
        meshes.push(...geometryManager.planes.filter((p) => p.isVisible).map((p) => p.mesh));

        // D. Vecteurs (Seulement si isVisible est true)
        // Pour les vecteurs, c'est un peu plus complexe car ils ont une ligne et un c√¥ne
        geometryManager.vectors.forEach((v) => {
          if (v.isVisible && v.arrowHelper) {
            meshes.push(v.arrowHelper.line, v.arrowHelper.cone);
          }
        });

        // 3. Lancement du rayon uniquement sur les objets visibles
        const intersects = raycaster.intersectObjects(meshes);

        return intersects.length > 0 ? intersects[0] : null;
      }

      function performRaycastSelection(x, y) {
        const intersection = getIntersectionResult(x, y);
        if (intersection && intersection.object.userData.instance) {
          // La fonction handleSelection attend le MAILLAGE cliqu√©
          handleSelection(intersection.object);
        } else {
          deselectCurrentObject();
          cancelEdit();
          cancelVectorEdit();
        }
      }

      function getObjectAtCoordinates(x, y) {
        mouse.x = (x / window.innerWidth) * 2 - 1;
        mouse.y = -(y / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const meshes = [
          ...geometryManager.points.map((p) => p.mesh),
          ...geometryManager.lines.map((l) => l.mesh),
          ...geometryManager.planes.map((p) => p.mesh),
          ...geometryManager.vectors
            .map((v) => v.arrowHelper)
            .filter(Boolean)
            .flatMap((a) => [a.line, a.cone]),
        ];
        const intersects = raycaster.intersectObjects(meshes);

        if (intersects.length > 0) {
          return intersects[0].object.userData.instance || null;
        }
        return null;
      }

      function performRaycastSelection(x, y) {
        const instance = getObjectAtCoordinates(x, y);
        if (instance) {
          handleSelection(instance.mesh); // handleSelection attend le mesh
        } else {
          deselectCurrentObject();
          cancelEdit();
          cancelVectorEdit();
        }
      }

      function findObjectAndShowMenu(x, y) {
        // On v√©rifie que la fonction existe bien avant de l'appeler
        if (typeof hideContextMenu === "function") {
          hideContextMenu();
        } else {
          console.error("‚ùå Erreur : hideContextMenu n'est pas d√©finie !");
          return;
        }

        const intersection = getIntersectionResult(x, y);

        if (intersection) {
          console.log("‚úÖ 2. Objet touch√© !", intersection.object);

          if (intersection.object.userData && intersection.object.userData.instance) {
            console.log("‚úÖ 3. Instance trouv√©e, lancement du menu...");
            populateAndShowContextMenu(x, y, intersection.object.userData.instance);
          } else {
            console.warn("‚ö†Ô∏è Objet touch√© mais pas de donn√©es 'instance' (userData vide ?)");
          }
        } else {
          console.log("‚ùå 2. Aucun objet trouv√© sous la souris.");
        }
      }

      function populateAndShowContextMenu(x, y, instance) {
        console.log("üõ†Ô∏è Construction du menu pour :", instance.constructor.name);

        const menu = document.getElementById("contextMenu");
        const menuItemsContainer = document.getElementById("contextMenuItems");

        // 1. Vider le menu pr√©c√©dent
        menuItemsContainer.innerHTML = "";

        // Helper pour cr√©er les lignes (li)
        const createAction = (action, text) =>
          `<li onclick="${action}; hideContextMenu();" style="padding:8px 15px; cursor:pointer; border-bottom:1px solid #eee; color:#333;">${text}</li>`;

        let htmlContent = "";

        // 2. G√©n√©rer le contenu selon le type
        if (instance instanceof Point) {
          const index = geometryManager.points.indexOf(instance);
          htmlContent += createAction(`editPoint(${index})`, "‚úèÔ∏è Modifier le point");
          htmlContent += createAction(`removePoint(${index})`, "üóëÔ∏è Supprimer le point");
        } else if (instance instanceof Vector) {
          htmlContent += createAction(`editVector(${instance.id})`, "‚úèÔ∏è Modifier le vecteur");
          htmlContent += createAction(
            `toggleVectorVisibility(${instance.id})`,
            instance.isVisible ? "üôà Cacher" : "üëÅÔ∏è Afficher"
          );
          htmlContent += createAction(`removeVectorById(${instance.id})`, "üóëÔ∏è Supprimer");
        } else if (instance instanceof Line3D) {
          htmlContent += createAction(`editLine(${instance.id})`, "‚úèÔ∏è Modifier la droite");
          htmlContent += createAction(
            `toggleStraightLineVisibility(${instance.id})`,
            instance.isVisible ? "üôà Cacher" : "üëÅÔ∏è Afficher"
          );
          htmlContent += createAction(`removeStraightLineById(${instance.id})`, "üóëÔ∏è Supprimer");
        } else if (instance instanceof Plane) {
          htmlContent += createAction(`editPlane(${instance.id})`, "‚úèÔ∏è Modifier le plan");
          htmlContent += createAction(
            `togglePlaneVisibility(${instance.id})`,
            instance.isVisible ? "üôà Cacher" : "üëÅÔ∏è Afficher"
          );
          htmlContent += createAction(`toggleNormalVector(${instance.id})`, "üìè Vecteur Normal (Vn)");
          htmlContent += createAction(`removePlaneById(${instance.id})`, "üóëÔ∏è Supprimer");
        }

        // 3. V√©rifier si du contenu a √©t√© g√©n√©r√©
        if (htmlContent === "") {
          console.warn("‚ö†Ô∏è Menu vide : type d'objet non reconnu", instance);
          return;
        }

        menuItemsContainer.innerHTML = htmlContent;

        // 4. Affichage et Positionnement (Logique Fixed)
        menu.style.display = "block"; // On l'affiche pour pouvoir calculer sa taille

        const menuWidth = menu.offsetWidth || 160;
        const menuHeight = menu.offsetHeight || 100;

        // Calcul pour ne pas sortir de l'√©cran
        let finalX = x;
        let finalY = y;

        if (x + menuWidth > window.innerWidth) {
          finalX = window.innerWidth - menuWidth - 10;
        }
        if (y + menuHeight > window.innerHeight) {
          finalY = window.innerHeight - menuHeight - 10;
        }

        // Application des positions
        menu.style.left = finalX + "px";
        menu.style.top = finalY + "px";

        console.log(`‚úÖ Menu affich√© en (${finalX}, ${finalY})`);
      }
      // =====================================================================================
      // END: GESTION DES √âV√âNEMENTS
      // =====================================================================================
      function createAxes() {
        const axisLength = 10;
        const axisRadius = 0.04;
        const headLength = 0.4;
        const headRadius = 0.12;

        // --- Helper pour cr√©er le texte (Label) ---
        const createAxisLabel = (text, colorHex) => {
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          canvas.width = 256;
          canvas.height = 256;

          // Fond transparent
          context.clearRect(0, 0, canvas.width, canvas.height);

          // Style du texte
          context.font = "50px Arial";
          context.textAlign = "center";
          context.textBaseline = "middle";

          // On utilise la couleur de l'axe pour le texte
          context.fillStyle = "#" + new THREE.Color(colorHex).getHexString();
          context.fillText(text, canvas.width / 2, canvas.height / 2);

          // Cr√©ation de la texture et du sprite
          const texture = new THREE.CanvasTexture(canvas);
          const material = new THREE.SpriteMaterial({
            map: texture,
            depthTest: false, // Toujours visible au-dessus des objets
            transparent: true,
          });

          const sprite = new THREE.Sprite(material);
          sprite.scale.set(2.5, 2.5, 1); // Taille de l'√©tiquette
          return sprite;
        };

        const createAxisArrow = (color, direction, labelText) => {
          const material = new THREE.MeshBasicMaterial({
            color: color,
            depthTest: false, // Garde l'axe visible √† travers les autres objets
          });

          const group = new THREE.Group();

          // 1. Le corps de l'axe (cylindre)
          const shaftGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 12);
          const shaft = new THREE.Mesh(shaftGeometry, material);
          shaft.position.copy(direction).multiplyScalar(axisLength / 2);
          shaft.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
          group.add(shaft);

          // 2. La t√™te de l'axe (c√¥ne)
          const headGeometry = new THREE.ConeGeometry(headRadius, headLength, 12);
          const head = new THREE.Mesh(headGeometry, material);
          head.position.copy(direction).multiplyScalar(axisLength);
          head.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
          group.add(head);

          // 3. L'√©tiquette (Sprite)
          const label = createAxisLabel(labelText, color);
          // On place l'√©tiquette un peu plus loin que la pointe de la fl√®che
          const labelPos = direction.clone().multiplyScalar(axisLength + 1.5);
          label.position.copy(labelPos);
          group.add(label);

          // Configuration des propri√©t√©s de rendu
          group.traverse((child) => {
            if (child.material) {
              child.material.depthTest = true;
              child.material.transparent = true;
              child.material.opacity = 1.0;
              child.material.depthWrite = true;
              child.renderOrder = 1;
            }
          });

          return group;
        };

        // Cr√©ation et ajout des 3 axes √† la sc√®ne
        // NOTE : Adaptation √† votre logique UI (Z = Hauteur, Y = Profondeur)

        // Axe X (Rouge) -> Label "X"
        const xAxis = createAxisArrow(0xff0000, new THREE.Vector3(1, 0, 0), "X");

        // Axe Y ThreeJS (Vert - Vertical) -> Label "Z" (Car votre UI consid√®re la hauteur comme Z)
        const yAxis = createAxisArrow(0x00ff00, new THREE.Vector3(0, 1, 0), "Z");

        // Axe Z ThreeJS (Bleu - Profondeur) -> Label "Y" (Car votre UI consid√®re la profondeur comme Y)
        const zAxis = createAxisArrow(0x0000ff, new THREE.Vector3(0, 0, 1), "Y");

        [xAxis, yAxis, zAxis].forEach((axis) => {
          scene.add(axis);
        });
      }
      function animate() {
        requestAnimationFrame(animate);
        const scaleFactor = 0.12;

        // Boucle existante pour les points
        geometryManager.points.forEach((p) => {
          const dist = camera.position.distanceTo(p.label.position);
          const desiredScale = dist * scaleFactor;
          p.label.scale.set(desiredScale, desiredScale * 0.5, 1);
        });

        // --- AJOUT : Boucle pour les √©tiquettes de vecteurs ---
        geometryManager.vectors.forEach((v) => {
          if (v.label) {
            // On v√©rifie que l'√©tiquette existe
            const dist = camera.position.distanceTo(v.label.position);
            const desiredScale = dist * scaleFactor;
            v.label.scale.set(desiredScale, desiredScale * 0.5, 1);
          }
        });
        // --- FIN DE L'AJOUT ---

        renderer.render(scene, camera);
      }
      // =====================================================================================
      // SECTION 4 : MISE √Ä JOUR DE L'INTERFACE UTILISATEUR (UI)
      // =====================================================================================

      function updateAllUI() {
        updatePointList();
        updateStraightLineList();
        updatePlaneList();
        updateVectorList();
        updateSelects();
      }

      function updatePointList() {
        const list = document.getElementById("pointList");
        list.innerHTML = "";
        geometryManager.points.forEach((p, i) => {
          const item = document.createElement("div");
          item.className = "point-item";
          const coordsText = `(${formatNumber(p.position.x, 1)}, ${formatNumber(p.position.z, 1)}, ${formatNumber(
            p.position.y,
            1
          )})`;

          item.innerHTML = `
      <div class="geometry-item-main">
          <div class="geometry-info">
              <span class="point-name">${p.name}</span>
              <span class="geometry-coords">${coordsText}</span>
          </div>
          <div class="geometry-actions">
              <button class="btn-secondary" onclick="editPoint(${i})" title="Modifier">‚úèÔ∏è</button>
              <button class="btn-danger" onclick="removePoint(${i})" title="Supprimer">üóëÔ∏è</button>
          </div>
      </div>`;
          list.appendChild(item);
        });
      }

      function updateStraightLineList() {
        const list = document.getElementById("lineList");
        list.innerHTML =
          geometryManager.lines.length === 0 ? '<div class="point-item">Aucune droite trac√©e.</div>' : "";
        geometryManager.lines.forEach((line) => {
          const item = document.createElement("div");
          item.className = "geometry-item";
          item.id = `line-item-${line.id}`;
          const v = line.directorVector;
          const vText = `u(${formatNumber(v.x, 1)}, ${formatNumber(v.y, 1)}, ${formatNumber(v.z, 1)})`;

          item.innerHTML = `
        <div class="geometry-item-main">
            <div class="geometry-info">
                <span class="geometry-name">${line.name}</span>
                <span class="geometry-details">Vect. dir: ${vText}</span>
            </div>
            <div class="geometry-actions">
                <button class="btn-secondary" onclick="toggleStraightLineVisibility(${line.id})" title="${
            line.isVisible ? "Masquer" : "Afficher"
          }">${line.isVisible ? "üëÅÔ∏è" : "üôà"}</button>
                <button class="btn-danger" onclick="removeStraightLineById(${line.id})" title="Supprimer">üóëÔ∏è</button>
            </div>
        </div>`;
          list.appendChild(item);
        });
      }

      function updatePlaneList() {
        const list = document.getElementById("planeList");
        list.innerHTML = geometryManager.planes.length === 0 ? '<div class="point-item">Aucun plan cr√©√©.</div>' : "";

        geometryManager.planes.forEach((plane) => {
          const item = document.createElement("div");
          item.className = "geometry-item";
          item.id = `plane-item-${plane.id}`;

          // 1. Pr√©parer le texte des d√©tails (vecteur normal)
          const n = plane.displayNormal;
          const normalText = `Vn : n(${formatNumber(n.x, 1)}, ${formatNumber(n.y, 1)}, ${formatNumber(n.z, 1)})`;

          // 2. Pr√©parer le HTML du bouton "Vn" (logique inchang√©e)
          const existingNormalVector = geometryManager.vectors.find(
            (v) => v.parentPlaneId === plane.id && v.isNormalVector
          );
          let normalBtnHtml;
          if (existingNormalVector) {
            normalBtnHtml = `<button class="btn-violet-light" onclick="toggleNormalVector(${plane.id})" title="Masquer le vecteur normal">Vn ‚ûñ</button>`;
          } else {
            normalBtnHtml = `<button class="btn-violet" onclick="toggleNormalVector(${plane.id})" title="Afficher le vecteur normal">Vn ‚ûï</button>`;
          }

          // 3. G√©n√©rer la nouvelle structure HTML
          item.innerHTML = `
        <div class="geometry-item-main">
            <!-- Colonne de gauche pour le texte -->
            <div class="geometry-info">
                <span class="geometry-name">${plane.name}</span>
                <span class="geometry-details">${normalText}</span>
            </div>

            <!-- Colonne de droite pour les boutons -->
            <div class="geometry-actions">
                ${normalBtnHtml}
                <button class="btn-secondary" onclick="togglePlaneVisibility(${plane.id})" title="${
            plane.isVisible ? "Masquer" : "Afficher"
          }">${plane.isVisible ? "üëÅÔ∏è" : "üôà"}</button>
                <button class="btn-danger" onclick="removePlaneById(${plane.id})" title="Supprimer">üóëÔ∏è</button>
            </div>
        </div>`;

          list.appendChild(item);
        });
      }

      function updateVectorList() {
        const list = document.getElementById("vectorList");
        list.innerHTML =
          geometryManager.vectors.length === 0 ? '<div class="point-item">Aucun vecteur trac√©.</div>' : "";
        geometryManager.vectors.forEach((vector) => {
          const item = document.createElement("div");
          item.className = "geometry-item";
          const v = vector.components;

          const coordsText = `(${formatNumber(v.x, 1)}, ${formatNumber(v.z, 1)}, ${formatNumber(v.y, 1)})`;
          const normText = formatNumber(vector.components.length(), 2);

          // --- MODIFICATION DU INNERHTML ---
          item.innerHTML = `
    <div class="geometry-item-main">
        <div class="geometry-info">
            <span class="geometry-name">${vector.name}</span>
            <span class="geometry-coords">${coordsText}</span>
        </div>
        <div class="geometry-actions">
            <button class="btn-secondary" onclick="editVector(${vector.id})" title="Modifier">‚úèÔ∏è</button>

            <!-- NOUVEAU BOUTON POUR L'√âTIQUETTE -->
            <button class="btn-violet-light" onclick="toggleVectorLabelVisibility(${vector.id})" title="${
            vector.isLabelVisible ? "Masquer le nom" : "Afficher le nom"
          }">${vector.isLabelVisible ? "üëÅÔ∏è" : "üôà"}</button>

            <button class="btn-secondary" onclick="toggleVectorVisibility(${vector.id})" title="${
            vector.isVisible ? "Masquer" : "Afficher"
          }">${vector.isVisible ? "üëÅÔ∏è" : "üôà"}</button>
            <button class="btn-danger" onclick="removeVectorById(${vector.id})" title="Supprimer">üóëÔ∏è</button>
        </div>
    </div>
    <div class="geometry-details-secondary">
        Norme: <strong>${normText}</strong>
    </div>`;
          list.appendChild(item);
        });
      }

      function toggleVectorLabelVisibility(id) {
        const vector = geometryManager.findVectorById(id);
        if (vector) {
          // Appelle la nouvelle m√©thode de la classe Vector
          vector.setLabelVisibility(!vector.isLabelVisible);
          // Met √† jour la liste pour que le texte du bouton change
          updateVectorList();
        }
      }

      function toggleNormalVector(planeId) {
        const plane = geometryManager.findPlaneById(planeId);
        if (!plane) return;

        // Chercher si un vecteur normal existe d√©j√† pour ce plan
        const existingVector = geometryManager.vectors.find((v) => v.parentPlaneId === planeId && v.isNormalVector);

        if (existingVector) {
          // Le vecteur existe, on le supprime
          geometryManager.removeVector(existingVector);
        } else {
          // Le vecteur n'existe pas, on le cr√©e
          const normalVectorName = `Vn(${plane.name})`;
          const normalVectorLength = 2.5;
          const normalVectorComponents = plane.normal.clone().normalize().multiplyScalar(normalVectorLength);

          const normalVector = new Vector(
            normalVectorName,
            plane.mesh.position, // Origine du vecteur
            normalVectorComponents,
            0x800080 // Couleur violette
          );

          // On stocke des informations pour le retrouver
          normalVector.isNormalVector = true;
          normalVector.parentPlaneId = plane.id;

          geometryManager.addVector(normalVector);
        }

        // Mettre √† jour l'UI pour refl√©ter le changement de bouton et la liste des vecteurs
        updateAllUI();
      }

      function updateSelects() {
        const allSelects = document.querySelectorAll("select");

        allSelects.forEach((select) => {
          // --- MODIFICATION ICI ---
          // On ajoute 'savedScenesSelect' √† la liste des menus √† ignorer
          if (["rotationAxisSelect", "symmetryTypeSelect", "savedScenesSelect"].includes(select.id)) {
            return; // On ignore ce menu et on passe au suivant
          }
          // --- FIN DE LA MODIFICATION ---

          const currentValue = select.value;
          select.innerHTML = "";
          const id = select.id;

          if (id.includes("Vector")) {
            select.add(new Option("-- Vecteur --", ""));
            geometryManager.vectors.forEach((v) => select.add(new Option(v.name, v.id)));
          } else if (id.includes("Line")) {
            select.add(new Option("-- Droite --", ""));
            geometryManager.lines.forEach((l) => select.add(new Option(l.name, l.id)));
          } else if (id.includes("Plane")) {
            select.add(new Option("-- Plan --", ""));
            geometryManager.planes.forEach((p) => select.add(new Option(p.name, p.id)));
          } else {
            select.add(new Option("-- Point --", ""));
            geometryManager.points.forEach((p, i) => select.add(new Option(p.name, i)));
          }

          if (["vectorOriginPoint", "sumVectorOrigin", "crossVectorOrigin", "rotationCenterSelect"].includes(id)) {
            select.add(new Option("Origine (0,0,0)", "origin"), select.options[1]);
          }

          select.value = currentValue;
        });

        displayPlaneEquation();
        displayLineEquation();

        if (document.getElementById("symmetryTypeSelect")) {
          updateSymmetryUI();
        }
      }
      // =====================================================================================
      // SECTION 5 : CR√âATION / MODIFICATION / SUPPRESSION D'OBJETS
      // =====================================================================================
      function editLine(id) {
        ensurePanelVisible();
        expandSectionAndScrollToItem(`line-item-${id}`, "lineList");
      }

      function editPlane(id) {
        ensurePanelVisible();
        expandSectionAndScrollToItem(`plane-item-${id}`, "planeList");
      }
      // --- Points ---
      // VERSION ORIGINALE (avec les anciens IDs)
      function addPoint() {
        const n = document.getElementById("pointName").value.trim();
        const x = parseFloat(document.getElementById("pointX").value);
        const y_from_ui = parseFloat(document.getElementById("pointY").value); // Profondeur
        const z_from_ui = parseFloat(document.getElementById("pointZ").value); // Hauteur
        if (!n || isNaN(x) || isNaN(y_from_ui) || isNaN(z_from_ui)) {
          showSplashScreen("Donn√©es invalides.");
          return;
        }
        // Le constructeur Point attend un nom et un Vector3, pas des coordonn√©es s√©par√©es
        geometryManager.addPoint(new Point(n, x, z_from_ui, y_from_ui));
        cancelEdit();
        updateAllUI();
      }

      function editPoint(index) {
        ensurePanelVisible(); // Ouvre le panneau si n√©cessaire
        const p = geometryManager.points[index];
        if (!p) return;

        // --- D√âBUT DE LA MODIFICATION ---
        // On applique la fonction formatNumber aux coordonn√©es AVANT de les afficher

        // Remplir les champs du formulaire avec les valeurs format√©es
        document.getElementById("pointName").value = p.name;
        document.getElementById("pointX").value = formatNumber(p.position.x);
        document.getElementById("pointY").value = formatNumber(p.position.z); // Le Z de Three.js (profondeur) est le Y de l'UI
        document.getElementById("pointZ").value = formatNumber(p.position.y); // Le Y de Three.js (hauteur) est le Z de l'UI

        // --- FIN DE LA MODIFICATION ---

        document.getElementById("editPointIndex").value = index;

        // Cacher le bouton "Ajouter"
        document.getElementById("addPointBtn").style.display = "none";
        // Afficher le CONTENEUR des boutons d'√©dition
        document.getElementById("pointEditActions").style.display = "grid";

        // D√©plier la section et faire d√©filer jusqu'au formulaire
        const s = document.getElementById("pointList").closest(".section.collapsible");
        if (s && s.classList.contains("collapsed")) {
          s.classList.remove("collapsed");
        }
        document.getElementById("pointName").scrollIntoView({ behavior: "smooth", block: "center" });
      }

      function updatePoint() {
        const i = document.getElementById("editPointIndex").value;
        const p = geometryManager.points[i];
        if (!p) return;

        const n = document.getElementById("pointName").value.trim();

        // --- D√âBUT DE LA CORRECTION ---
        // On utilise les bons IDs pour lire les coordonn√©es depuis le formulaire
        const x = parseFloat(document.getElementById("pointX").value);
        const y_from_ui = parseFloat(document.getElementById("pointY").value); // Profondeur
        const z_from_ui = parseFloat(document.getElementById("pointZ").value); // Hauteur
        // --- FIN DE LA CORRECTION ---

        if (!n || isNaN(x) || isNaN(y_from_ui) || isNaN(z_from_ui)) {
          showSplashScreen("Donn√©es invalides.");
          return;
        }

        // --- AJOUT DE LA V√âRIFICATION ---
        // On v√©rifie si le nouveau nom est d√©j√† pris par un AUTRE objet
        const existingObject = geometryManager.findObjectByName(n);
        if (existingObject && existingObject.id !== p.id) {
          showSplashScreen(`Le nom "${n}" est d√©j√† utilis√©. Veuillez en choisir un autre.`);
          return;
        }
        // --- FIN DE L'AJOUT ---

        // On garde votre logique de mise √† jour, elle est parfaite
        p.update(n, x, z_from_ui, y_from_ui);

        updateAllUI();
        cancelEdit();
      }

      function cancelEdit() {
        // Vider les champs
        document.getElementById("pointName").value = "";
        document.getElementById("pointX").value = "";
        document.getElementById("pointY").value = "";
        document.getElementById("pointZ").value = "";
        document.getElementById("editPointIndex").value = "";

        // --- PARTIE CORRIG√âE ---
        // Afficher le bouton "Ajouter"
        document.getElementById("addPointBtn").style.display = "block";
        // Cacher le CONTENEUR des boutons d'√©dition
        document.getElementById("pointEditActions").style.display = "none";
      }
      /**
       * Supprime le point actuellement en cours d'√©dition dans le formulaire.
       */
      function deleteEditingPoint() {
        // R√©cup√®re l'index du point depuis le champ cach√©
        const index = parseInt(document.getElementById("editPointIndex").value);
        if (isNaN(index)) return; // S√©curit√©

        // Appelle la fonction de suppression existante qui g√®re d√©j√† la confirmation
        removePoint(index);

        // R√©initialise le formulaire pour quitter le mode √©dition
        cancelEdit();
      }

      function removePoint(index) {
        const p = geometryManager.points[index];
        if (p && confirm(`Supprimer "${p.name}" ?`)) {
          geometryManager.removePoint(p);
          updateAllUI();
        }
      }

      function clearAllPoints() {
        // 1. Modifier le message de confirmation pour qu'il soit pr√©cis.
        if (
          confirm(
            "√ätes-vous s√ªr de vouloir effacer tous les points ? (Les droites, plans et vecteurs existants seront conserv√©s)"
          )
        ) {
          // 2. Parcourir chaque point pour le retirer de la sc√®ne 3D.
          geometryManager.points.forEach((point) => {
            point.removeFromScene(scene);
          });

          // 3. Vider le tableau des points dans le gestionnaire.
          geometryManager.points = [];

          // 4. Mettre √† jour l'interface utilisateur pour refl√©ter la suppression.
          updateAllUI();
        }
      }

      // --- Droites ---

      // Dans la SECTION 5
      function addStraightLine() {
        const [i1, i2] = [document.getElementById("lineStart").value, document.getElementById("lineEnd").value];
        if (i1 === "" || i2 === "" || i1 === i2) {
          showSplashScreen("S√©lectionnez deux points diff√©rents.");
          return;
        }
        const p1 = geometryManager.points[i1],
          p2 = geometryManager.points[i2];
        const d = new THREE.Vector3().subVectors(p2.position, p1.position);

        const baseName = `Droite(${p1.name},${p2.name})`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "line"); // On passe 'line'
        geometryManager.addLine(new Line3D(uniqueName, p1.position, d));
        updateAllUI();
      }
      function removeStraightLineById(id) {
        const l = geometryManager.findLineById(id);
        if (l && confirm(`Supprimer "${l.name}" ?`)) {
          geometryManager.removeLine(l);
          updateAllUI();
        }
      }

      function addLineFromEquation() {
        const name = document.getElementById("lineNameFromEquation").value.trim() || "Droite (Eq)";
        const equationsText = document.getElementById("lineEquationInput").value;
        const lines = equationsText.split("\n").filter((line) => line.trim() !== "");

        if (lines.length < 3) {
          showSplashScreen("Veuillez entrer les 3 √©quations param√©triques (x, y, et z).");
          return;
        }

        let point = { x: 0, y: 0, z: 0 };
        let vector = { x: 0, y: 0, z: 0 };
        const axesFound = { x: false, y: false, z: false };

        for (const line of lines) {
          const axisChar = line.trim().charAt(0).toLowerCase();
          if (axisChar !== "x" && axisChar !== "y" && axisChar !== "z") continue;
          if (axesFound[axisChar]) {
            showSplashScreen(`L'√©quation pour l'axe '${axisChar}' est d√©finie plusieurs fois.`);
            return;
          }

          const cleanLine = line.substring(line.indexOf("=") + 1);

          // 1. Extraire le coefficient de 't' (composante du vecteur)
          let tMatch = cleanLine.match(/[+\-]?\s*[\d\.]*t/);
          let vectorComp = 0;
          let lineWithoutT = cleanLine;

          if (tMatch) {
            let tPart = tMatch[0].replace(/\s/g, "").replace("t", "");
            if (tPart === "+" || tPart === "") {
              vectorComp = 1;
            } else if (tPart === "-") {
              vectorComp = -1;
            } else {
              vectorComp = parseFloat(tPart);
            }
            lineWithoutT = cleanLine.replace(tMatch[0], "");
          }

          // 2. Extraire la constante (coordonn√©e du point)
          let pointCoord = parseFloat(lineWithoutT.trim() || "0");

          if (isNaN(pointCoord) || isNaN(vectorComp)) {
            showSplashScreen(`Erreur de syntaxe dans l'√©quation pour l'axe '${axisChar}'.`);
            return;
          }

          if (geometryManager.lines.some((l) => l.name === name)) {
            showSplashScreen(`Le nom de droite "${name}" est d√©j√† utilis√©. Veuillez en choisir un autre.`);
            return;
          }

          point[axisChar] = pointCoord;
          vector[axisChar] = vectorComp;
          axesFound[axisChar] = true;
        }

        if (!axesFound.x || !axesFound.y || !axesFound.z) {
          showSplashScreen("Les √©quations pour x, y, et z doivent toutes √™tre pr√©sentes.");
          return;
        }

        const startPoint = new THREE.Vector3(point.x, point.y, point.z);
        const directorVector = new THREE.Vector3(vector.x, vector.y, vector.z);

        if (directorVector.lengthSq() < 1e-8) {
          showSplashScreen("Le vecteur directeur ne peut pas √™tre nul.");
          return;
        }

        geometryManager.addLine(new Line3D(name, startPoint, directorVector));
        updateAllUI();
      }

      function toggleStraightLineVisibility(lineId) {
        const line = geometryManager.findLineById(lineId);
        if (line) {
          line.setVisibility(!line.isVisible);
          // Met √† jour la liste pour changer le texte du bouton
          updateStraightLineList();
        }
      }

      function removeStraightLineById(id) {
        const l = geometryManager.findLineById(id);
        if (l && confirm(`Supprimer "${l.name}" ?`)) {
          geometryManager.removeLine(l);
          updateAllUI();
        }
      }

      function clearStraightLines() {
        if (confirm("Effacer toutes les droites ?")) {
          geometryManager.lines.forEach((line) => line.removeFromScene(scene));
          geometryManager.lines = [];
          updateAllUI();
        }
      }

      // --- Plans ---
      function addPlane() {
        const n = document.getElementById("planeName").value.trim() || "Plan";

        // --- V√©rification du nom unique ---
        if (geometryManager.planes.some((p) => p.name === n)) {
          showSplashScreen(`Le nom de plan "${n}" est d√©j√† utilis√©. Veuillez en choisir un autre.`);
          return;
        }
        // --- Fin de la v√©rification ---

        const [i1, i2, i3] = ["planeSelectP1", "planeSelectP2", "planeSelectP3"].map(
          (id) => document.getElementById(id).value
        );
        if (i1 === "" || i2 === "" || i3 === "" || i1 === i2 || i1 === i3 || i2 === i3) {
          showSplashScreen("S√©lectionnez trois points distincts.");
          return;
        }
        const [p1, p2, p3] = [i1, i2, i3].map((i) => geometryManager.points[i].position);
        const norm = new THREE.Vector3().crossVectors(
          new THREE.Vector3().subVectors(p2, p1),
          new THREE.Vector3().subVectors(p3, p1)
        );
        if (norm.lengthSq() < 1e-6) {
          showSplashScreen("Points colin√©aires.");
          return;
        }

        const areIntegers = Number.isInteger(norm.x) && Number.isInteger(norm.y) && Number.isInteger(norm.z);

        if (areIntegers) {
          const commonDivisor = gcdOfThree(norm.x, norm.y, norm.z);
          if (commonDivisor > 1) {
            norm.divideScalar(commonDivisor);
          }
        }

        const newPlane = new Plane(n, p1, norm);
        geometryManager.addPlane(newPlane);

        updateAllUI();

        // --- D√âBUT DE LA CORRECTION ---
        // On vide le champ de saisie du nom pour la prochaine cr√©ation.
        document.getElementById("planeName").value = "";
        // --- FIN DE LA CORRECTION ---
      }

      function addPlaneFromEquation() {
        let equationStr = document.getElementById("planeEquationInput").value.trim();
        if (!equationStr) {
          showSplashScreen("Veuillez entrer une √©quation de plan.");
          return;
        }

        if (equationStr.includes("=")) {
          const parts = equationStr.split("=");
          equationStr = `${parts[0]} - (${parts[1]})`;
        }

        const getCoefficient = (variable) => {
          const regex = new RegExp(`([+\-]?[\\d\\.]*)\\s*\\*?\\s*${variable}`, "gi");
          let totalCoeff = 0;
          let match;
          while ((match = regex.exec(equationStr)) !== null) {
            let coeffStr = match[1].replace(/\s/g, "");
            if (coeffStr === "" || coeffStr === "+") totalCoeff += 1;
            else if (coeffStr === "-") totalCoeff += -1;
            else totalCoeff += parseFloat(coeffStr);
          }
          return totalCoeff;
        };

        const a = getCoefficient("x");
        const b = getCoefficient("y"); // Coefficient 'b' de l'√©quation (profondeur)
        const c = getCoefficient("z"); // Coefficient 'c' de l'√©quation (hauteur)

        let constantStr = equationStr
          .replace(/[+\-]?[\d\\.]*\s*\*?\s*[xyz]/gi, "")
          .replace(/--/g, "+")
          .trim();

        let d = 0;
        try {
          if (constantStr) {
            d = new Function("return " + constantStr)();
          }
        } catch (e) {
          showSplashScreen("Erreur de syntaxe dans la constante de l'√©quation.");
          return;
        }

        if (isNaN(a) || isNaN(b) || isNaN(c) || isNaN(d)) {
          showSplashScreen("Syntaxe de l'√©quation invalide.");
          return;
        }

        // --- D√âBUT DE LA CORRECTION CRUCIALE ---
        // On cr√©e le vecteur normal pour Three.js : new THREE.Vector3(x, HAUTEUR, PROFONDEUR)
        // On doit donc passer les coefficients (a, c, b)
        const normal = new THREE.Vector3(a, c, b);
        // --- FIN DE LA CORRECTION CRUCIALE ---

        if (normal.lengthSq() < 1e-8) {
          showSplashScreen("L'√©quation est invalide (le vecteur normal ne peut pas √™tre nul).");
          return;
        }

        let pointOnPlane;
        if (Math.abs(a) > 1e-6) pointOnPlane = new THREE.Vector3(-d / a, 0, 0);
        else if (Math.abs(b) > 1e-6) pointOnPlane = new THREE.Vector3(0, 0, -d / b); // Profondeur (z Three.js)
        else if (Math.abs(c) > 1e-6) pointOnPlane = new THREE.Vector3(0, -d / c, 0); // Hauteur (y Three.js)
        else {
          showSplashScreen("Erreur logique inattendue.");
          return;
        }

        const baseName = `Plan (${formatNumber(a, 1)}x + ${formatNumber(b, 1)}y + ${formatNumber(c, 1)}z...)`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "plane");

        const newPlane = new Plane(uniqueName, pointOnPlane, normal, 0xffeb3b);

        geometryManager.addPlane(newPlane);
        updateAllUI();
      }

      function removePlaneById(id) {
        const p = geometryManager.findPlaneById(id);
        if (p && confirm(`Supprimer le plan "${p.name}" ?`)) {
          // Chercher et supprimer le vecteur normal associ√© s'il existe
          const normalVector = geometryManager.vectors.find((v) => v.parentPlaneId === p.id && v.isNormalVector);
          if (normalVector) {
            geometryManager.removeVector(normalVector);
          }

          // Supprimer le plan lui-m√™me
          geometryManager.removePlane(p);
          updateAllUI();
        }
      }

      function clearAllPlanes() {
        if (confirm("Effacer tous les plans et leurs normales associ√©es ?")) {
          // D'abord, trouver et supprimer tous les vecteurs normaux
          const normalVectors = geometryManager.vectors.filter((v) => v.isNormalVector);
          normalVectors.forEach((v) => geometryManager.removeVector(v));

          // Ensuite, supprimer tous les plans
          geometryManager.planes.forEach((plane) => plane.removeFromScene(scene));
          geometryManager.planes = [];
          updateAllUI();
        }
      }

      function togglePlaneVisibility(id) {
        const p = geometryManager.findPlaneById(id);
        if (p) {
          p.setVisibility(!p.isVisible);
          updatePlaneList();
        }
      }

      // --- Vecteurs ---
      function addVectorFromPoints() {
        const [sIdx, eIdx] = ["vectorStartPoint", "vectorEndPoint"].map((id) => document.getElementById(id).value);
        if (sIdx === "" || eIdx === "" || sIdx === eIdx) {
          showSplashScreen("S√©lectionnez deux points diff√©rents.");
          return;
        }
        const pS = geometryManager.points[sIdx],
          pE = geometryManager.points[eIdx];
        const c = new THREE.Vector3().subVectors(pE.position, pS.position);
        const n = `Vecteur(${pS.name}${pE.name})`;

        const baseName = `Vecteur(${pS.name}${pE.name})`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "vector");
        geometryManager.addVector(new Vector(uniqueName, pS.position, c));
        updateAllUI();
      }

      function addVectorFromCoords() {
        const n = document.getElementById("vectorNameCoords").value.trim() || "Vecteur";

        // --- D√âBUT DE LA CORRECTION ---
        // On v√©rifie si un vecteur portant ce nom existe d√©j√†.
        if (geometryManager.vectors.some((vector) => vector.name === n)) {
          // Si c'est le cas, on affiche une alerte et on arr√™te la fonction.
          showSplashScreen(`Le nom de vecteur "${n}" est d√©j√† utilis√©. Veuillez en choisir un autre.`);
          return;
        }
        // --- FIN DE LA CORRECTION ---

        const vx = parseFloat(document.getElementById("vectorCoordX").value);
        const vy_from_ui = parseFloat(document.getElementById("vectorCoordY").value); // Profondeur
        const vz_from_ui = parseFloat(document.getElementById("vectorCoordZ").value); // Hauteur
        if (isNaN(vx) || isNaN(vy_from_ui) || isNaN(vz_from_ui)) {
          showSplashScreen("Composantes invalides");
          return;
        }

        const comps = new THREE.Vector3(vx, vz_from_ui, vy_from_ui);
        let o = new THREE.Vector3(0, 0, 0);
        const oSel = document.getElementById("vectorOriginPoint").value;
        if (oSel !== "origin" && oSel !== "") o = geometryManager.points[oSel].position;

        geometryManager.addVector(new Vector(n, o, comps));
        cancelVectorEdit();
        updateAllUI();
      }

      function editVector(id) {
        ensurePanelVisible(); // <-- AJOUTEZ CETTE LIGNE
        const v = geometryManager.findVectorById(id);
        if (!v) return;
        document.getElementById("vectorNameCoords").value = v.name;
        document.getElementById("vectorCoordX").value = v.components.x;
        // TRADUCTION INVERSE
        document.getElementById("vectorCoordY").value = v.components.z;
        document.getElementById("vectorCoordZ").value = v.components.y;
        document.getElementById("editVectorId").value = id;
        document.getElementById("addVectorFromCoordsBtn").style.display = "none";
        document.getElementById("vectorEditActions").style.display = "grid"; // Affiche le conteneur
        const s = document.getElementById("vectorList").closest(".section.collapsible");
        if (s.classList.contains("collapsed")) s.classList.remove("collapsed");
        document.getElementById("vectorNameCoords").scrollIntoView({ behavior: "smooth", block: "center" });
      }

      function updateVector() {
        const id = parseInt(document.getElementById("editVectorId").value);
        const v = geometryManager.findVectorById(id);
        if (!v) return;

        const n = document.getElementById("vectorNameCoords").value.trim();

        // --- D√âBUT DE LA CORRECTION ---
        // On v√©rifie si un autre vecteur (avec un ID diff√©rent) utilise d√©j√† ce nom.
        if (geometryManager.vectors.some((vec) => vec.name === n && vec.id !== id)) {
          showSplashScreen(
            `Le nom de vecteur "${n}" est d√©j√† utilis√© par un autre vecteur. Veuillez en choisir un autre.`
          );
          return;
        }
        // --- FIN DE LA CORRECTION ---

        const vx = parseFloat(document.getElementById("vectorCoordX").value);
        const vy_from_ui = parseFloat(document.getElementById("vectorCoordY").value);
        const vz_from_ui = parseFloat(document.getElementById("vectorCoordZ").value);
        if (isNaN(vx) || isNaN(vy_from_ui) || isNaN(vz_from_ui)) {
          showSplashScreen("Composantes invalides.");
          return;
        }

        const comps = new THREE.Vector3(vx, vz_from_ui, vy_from_ui);
        let o = new THREE.Vector3(0, 0, 0);
        const oSel = document.getElementById("vectorOriginPoint").value;
        if (oSel !== "origin" && oSel !== "") o = geometryManager.points[oSel].position;

        v.update(n, o, comps);
        updateAllUI();
        cancelVectorEdit();
      }

      function deleteEditingVector() {
        const id = parseInt(document.getElementById("editVectorId").value);
        if (isNaN(id)) return; // S√©curit√© pour √©viter les erreurs

        const vector = geometryManager.findVectorById(id);
        if (vector) {
          // On utilise la fonction de suppression existante, qui g√®re la confirmation
          removeVectorById(id);
          // On r√©initialise le formulaire
          cancelVectorEdit();
        }
      }

      function cancelVectorEdit() {
        document.getElementById("vectorNameCoords").value = "";
        document.getElementById("vectorCoordX").value = "";
        document.getElementById("vectorCoordY").value = "";
        document.getElementById("vectorCoordZ").value = "";
        document.getElementById("editVectorId").value = "";

        document.getElementById("addVectorFromCoordsBtn").style.display = "block";
        document.getElementById("vectorEditActions").style.display = "none"; // Cache le conteneur

        // deselectCurrentObject();
      }

      function removeVectorById(id) {
        const v = geometryManager.findVectorById(id);
        if (v && confirm(`Supprimer "${v.name}" ?`)) {
          geometryManager.removeVector(v);
          updateAllUI();
        }
      }

      function clearAllVectors() {
        if (confirm("Effacer tous les vecteurs ?")) {
          geometryManager.vectors.forEach((vector) => vector.removeFromScene(scene));
          geometryManager.vectors = [];
          updateAllUI();
        }
      }

      function toggleVectorVisibility(id) {
        const v = geometryManager.findVectorById(id);
        if (v) {
          v.setVisibility(!v.isVisible);
          updateVectorList();
        }
      }

      function performRaycastSelection(screenX, screenY) {
        mouse.x = (screenX / window.innerWidth) * 2 - 1;
        mouse.y = -(screenY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const meshes = [
          ...geometryManager.points.map((p) => p.mesh),
          ...geometryManager.lines.map((l) => l.mesh),
          ...geometryManager.planes.map((p) => p.mesh),
          ...geometryManager.vectors
            .map((v) => v.arrowHelper)
            .filter(Boolean)
            .flatMap((a) => [a.line, a.cone]),
        ];

        const intersects = raycaster.intersectObjects(meshes);

        if (intersects.length > 0) {
          // Un objet est touch√©, on le s√©lectionne
          handleSelection(intersects[0].object);
        } else {
          // Aucun objet n'est touch√©, on d√©s√©lectionne tout
          deselectCurrentObject();
          cancelEdit();
          cancelVectorEdit();
        }
      }

      function onObjectClick(e) {
        if (wasDragged) return; // Garde la s√©curit√© pour la souris
        e.preventDefault();
        performRaycastSelection(e.clientX, e.clientY);
      }

      function handleSelection(mesh) {
        const inst = mesh.userData.instance;
        if (!inst) return;

        // Logique de "toggle" : cliquer sur l'objet d√©j√† s√©lectionn√© le d√©s√©lectionne
        if (inst === selectedObjectInstance) {
          deselectCurrentObject();
          cancelEdit();
          cancelVectorEdit();
          return;
        }

        // --- LOGIQUE DE S√âLECTION D'UN NOUVEL OBJET ---

        // 1. D√©s√©lectionner l'objet pr√©c√©dent (ce qui cache aussi le panneau de transformations)
        deselectCurrentObject();

        // 2. Enregistrer le nouvel objet comme √©tant s√©lectionn√©
        selectedObjectInstance = inst;

        // 3. --- CORRECTION DU BUG ---
        // AFFICHER EXPLICITEMENT LE PANNEAU DE TRANSFORMATIONS.
        // Cette √©tape est maintenant effectu√©e pour TOUS les types d'objets,
        // ce qui garantit que le panneau appara√Æt bien pour les droites et les plans.
        document.getElementById("transformations-hint").style.display = "none";
        document.getElementById("transformations-container").style.display = "block";
        // --- FIN DE LA CORRECTION ---

        // 4. Appliquer la surbrillance visuelle
        if (inst instanceof Vector) {
          inst.arrowHelper.setColor(HIGHLIGHT_COLOR);
        } else {
          mesh.material.color.set(HIGHLIGHT_COLOR);
          if (inst instanceof Plane) mesh.material.opacity = 0.75;
        }

        // 5. Mettre √† jour les parties sp√©cifiques de l'interface (formulaires, listes)
        updatePanelForSelection(inst);
      }

      function deselectCurrentObject() {
        if (!selectedObjectInstance) return;

        const inst = selectedObjectInstance;

        // 1. Restaurer la couleur
        if (inst instanceof Vector) {
          inst.arrowHelper.setColor(inst.color);
        } else if (inst.mesh) {
          inst.mesh.material.color.copy(inst.color);
          if (inst instanceof Plane) inst.mesh.material.opacity = 0.5;
        }

        // 2. Mettre √† jour l'√©tat
        selectedObjectInstance = null;

        // 3. Mettre √† jour l'UI (c'est la partie cruciale)
        document.getElementById("transformations-hint").style.display = "block";
        document.getElementById("transformations-container").style.display = "none";
      }

      function updatePanelForSelection(inst) {
        if (inst instanceof Point) {
          // Pour les points, on appelle la fonction d'√©dition directe
          editPoint(geometryManager.points.indexOf(inst));
        } else if (inst instanceof Vector) {
          // Pour les vecteurs, on appelle la fonction d'√©dition directe
          editVector(inst.id);
        } else if (inst instanceof Line3D) {
          // Pour les droites, on appelle la nouvelle fonction qui g√®re tout
          editLine(inst.id);
        } else if (inst instanceof Plane) {
          // Pour les plans, on appelle la nouvelle fonction qui g√®re tout
          editPlane(inst.id);
        }
      }

      function constructChaslesSum() {
        // 1. Nettoyer toute construction pr√©c√©dente pour repartir de z√©ro
        clearChaslesConstruction();

        // 2. R√©cup√©rer les objets s√©lectionn√©s dans l'interface
        const u = geometryManager.findVectorById(parseInt(document.getElementById("sumVectorSelect1").value));
        const v = geometryManager.findVectorById(parseInt(document.getElementById("sumVectorSelect2").value));
        const originId = document.getElementById("sumVectorOrigin").value;
        const resultDiv = document.getElementById("vectorSumResult");

        if (!u || !v || originId === "") {
          showSplashScreen("Veuillez s√©lectionner deux vecteurs et un point de d√©part pour la construction.");
          resultDiv.textContent = "S√©lection invalide.";
          return;
        }

        const pointA =
          originId === "origin"
            ? new THREE.Vector3(0, 0, 0)
            : geometryManager.points[parseInt(originId)].position.clone();

        // 3. Calculer les points cl√©s de la construction
        const pointB = new THREE.Vector3().addVectors(pointA, u.components);

        // 4. Cr√©er les objets visuels et les ajouter au suivi
        // Repr√©sentant de u (bleu)
        const u_rep = new Vector(
          geometryManager.generateUniqueName(`Rep(${u.name})`, "vector"),
          pointA,
          u.components,
          0x2196f3
        );
        geometryManager.addVector(u_rep);
        currentConstructionObjects.push(u_rep);

        // Repr√©sentant de v (rouge)
        const v_rep = new Vector(
          geometryManager.generateUniqueName(`Rep(${v.name})`, "vector"),
          pointB,
          v.components,
          0xf44336
        );
        geometryManager.addVector(v_rep);
        currentConstructionObjects.push(v_rep);

        // Vecteur somme (violet)
        const sumComponents = new THREE.Vector3().addVectors(u.components, v.components);
        const sum_vec = new Vector(
          geometryManager.generateUniqueName(`Somme(${u.name},${v.name})`, "vector"),
          pointA,
          sumComponents,
          0x8a2be2
        );
        geometryManager.addVector(sum_vec);
        currentConstructionObjects.push(sum_vec);

        // 5. Afficher le r√©sultat dans l'UI
        resultDiv.innerHTML = `Construction de Chasles effectu√©e.<br>
                               <strong>${u_rep.name} + ${v_rep.name} = ${sum_vec.name}</strong><br>
                               Composantes somme: <strong>(${formatNumber(sumComponents.x)}, ${formatNumber(
          sumComponents.y
        )}, ${formatNumber(sumComponents.z)})</strong>`;

        // 6. Mettre √† jour la sc√®ne et afficher le bouton de nettoyage
        updateAllUI();
        document.getElementById("clearChaslesBtn").style.display = "block";
      }

      function clearChaslesConstruction() {
        if (currentConstructionObjects.length === 0) {
          return; // Rien √† faire
        }

        // Parcourir la liste des objets suivis et les supprimer
        currentConstructionObjects.forEach((obj) => {
          if (obj instanceof Vector) {
            geometryManager.removeVector(obj);
          }
        });

        // Vider la liste de suivi
        currentConstructionObjects = [];

        // R√©initialiser l'interface
        document.getElementById("clearChaslesBtn").style.display = "none";
        document.getElementById("vectorSumResult").innerHTML = "";

        updateAllUI();
      }

      function displayPlaneEquation() {
        const s = document.getElementById("equationPlaneSelect"),
          r = document.getElementById("planeEquationDisplay");
        if (!s || !r) return;

        const pId = parseInt(s.value),
          p = geometryManager.findPlaneById(pId);
        if (!p) {
          r.innerHTML = "Aucun plan s√©lectionn√©.";
          return;
        }

        const n = p.displayNormal;
        const p0 = p.pointOnPlane;
        // La constante 'd' de l'√©quation ax+by+cz+d=0
        const d = -n.dot(p0);

        const terms = [];

        // Terme en X
        if (Math.abs(n.x) > 1e-6) {
          if (Math.abs(n.x - 1) < 1e-6) terms.push("x");
          else if (Math.abs(n.x + 1) < 1e-6) terms.push("-x");
          else terms.push(`${formatNumber(n.x, 2)}x`);
        }

        // Terme en Y (profondeur) -> utilise n.z
        if (Math.abs(n.z) > 1e-6) {
          const sign = n.z > 0 ? " + " : " - ";
          const absValue = Math.abs(n.z);
          if (absValue === 1) terms.push(`${sign}y`);
          else terms.push(`${sign}${formatNumber(absValue, 2)}y`);
        }

        // Terme en Z (hauteur) -> utilise n.y
        if (Math.abs(n.y) > 1e-6) {
          const sign = n.y > 0 ? " + " : " - ";
          const absValue = Math.abs(n.y);
          if (absValue === 1) terms.push(`${sign}z`);
          else terms.push(`${sign}${formatNumber(absValue, 2)}z`);
        }

        // Terme constant D
        if (Math.abs(d) > 1e-6) {
          const sign = d > 0 ? " + " : " - ";
          terms.push(`${sign}${formatNumber(Math.abs(d), 2)}`);
        }

        // Si tous les coefficients sont nuls
        if (terms.length === 0) {
          r.innerHTML = "<strong>0 = 0</strong>";
          return;
        }

        // On assemble l'√©quation en joignant les termes
        let equation = terms.join(" ").trim();

        // On nettoie le d√©but de la cha√Æne pour un affichage parfait
        if (equation.startsWith("+ ")) {
          // Enl√®ve le " + " initial si le premier terme est positif
          equation = equation.substring(2);
        } else if (equation.startsWith("- ")) {
          // Enl√®ve l'espace apr√®s le "-" initial si le premier terme est n√©gatif
          equation = "-" + equation.substring(2);
        }

        r.innerHTML = `<strong>${equation} = 0</strong>`;
      }

      function displayLineEquation() {
        const s = document.getElementById("equationLineSelect"),
          r = document.getElementById("lineEquationDisplay");
        if (!s || !r) return;

        const lId = parseInt(s.value),
          l = geometryManager.findLineById(lId);
        if (!l) {
          r.innerHTML = "Aucune droite s√©lectionn√©e.";
          return;
        }

        const p0 = l.startPoint;
        const v = l.directorVector;

        const formatTTerm = (coefficient) => {
          if (Math.abs(coefficient) < 1e-6) return "";
          const sign = coefficient > 0 ? " + " : " - ";
          const absValue = Math.abs(coefficient);
          if (Math.abs(absValue - 1) < 1e-6) return `${sign}t`;
          else return `${sign}${formatNumber(absValue, 2)}t`;
        };

        const eX = `x = ${formatNumber(p0.x, 2)}${formatTTerm(v.x)}`;

        // --- D√âBUT DE LA CORRECTION ---
        // La ligne 'y' (profondeur) doit afficher les composantes Z de Three.js
        const eY = `y = ${formatNumber(p0.z, 2)}${formatTTerm(v.z)}`;
        // La ligne 'z' (hauteur) doit afficher les composantes Y de Three.js
        const eZ = `z = ${formatNumber(p0.y, 2)}${formatTTerm(v.y)}`;
        // --- FIN DE LA CORRECTION ---

        r.innerHTML = `<strong>${eX}<br>${eY}<br>${eZ}</strong>`;
      }

      function calculateVectorSumFree() {
        // Nettoyer toute construction visuelle de Chasles qui pourrait √™tre active
        clearChaslesConstruction();

        const v1 = geometryManager.findVectorById(parseInt(document.getElementById("sumVectorSelect1").value));
        const v2 = geometryManager.findVectorById(parseInt(document.getElementById("sumVectorSelect2").value));
        const r = document.getElementById("vectorSumResult");

        if (!v1 || !v2) {
          showSplashScreen("Veuillez s√©lectionner deux vecteurs.");
          r.textContent = "Veuillez s√©lectionner deux vecteurs.";
          return;
        }

        const sumComponents = new THREE.Vector3().addVectors(v1.components, v2.components);

        let sumOrigin;
        const originSelection = document.getElementById("sumVectorOrigin").value;
        let originPointName = "l'origine du rep√®re";

        if (originSelection !== "origin" && originSelection !== "") {
          const originPoint = geometryManager.points[parseInt(originSelection)];
          sumOrigin = originPoint.position.clone();
          originPointName = `point ${originPoint.name}`;
        } else {
          sumOrigin = new THREE.Vector3(0, 0, 0); // Origine par d√©faut
        }

        const baseName = `Somme(${v1.name},${v2.name})`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "vector");

        const newVector = new Vector(uniqueName, sumOrigin, sumComponents, 0x9932cc);
        geometryManager.addVector(newVector);

        const componentsText = `(${formatNumber(sumComponents.x)}, ${formatNumber(sumComponents.y)}, ${formatNumber(
          sumComponents.z
        )})`;
        const normText = formatNumber(sumComponents.length(), 3);

        r.innerHTML = `Vecteur somme "${uniqueName}" cr√©√© depuis ${originPointName}.<br>
                     Composantes: <strong>${componentsText}</strong><br>
                     Norme ‚âà <strong>${normText}</strong>`;

        updateAllUI();
      }

      function calculateScalarProduct() {
        const [v1, v2] = [
          geometryManager.findVectorById(parseInt(document.getElementById("dotVectorSelect1").value)),
          geometryManager.findVectorById(parseInt(document.getElementById("dotVectorSelect2").value)),
        ];
        const r = document.getElementById("scalarProductResult"); // CORRECTED ID
        if (!v1 || !v2) {
          r.textContent = "S√©lectionnez deux vecteurs.";
          return;
        }
        const dP = v1.components.dot(v2.components);
        r.innerHTML = `<strong>${v1.name} ‚ãÖ ${v2.name} = ${dP.toFixed(3)}</strong>`;
      }

      function calculateVectorProduct() {
        const [v1, v2] = [
          geometryManager.findVectorById(parseInt(document.getElementById("crossVectorSelect1").value)),
          geometryManager.findVectorById(parseInt(document.getElementById("crossVectorSelect2").value)),
        ];
        const r = document.getElementById("vectorProductResult");

        if (!v1 || !v2) {
          showSplashScreen("S√©lectionnez deux vecteurs.");
          r.textContent = "Veuillez s√©lectionner deux vecteurs.";
          return;
        }

        let o = new THREE.Vector3(0, 0, 0);
        const oS = document.getElementById("crossVectorOrigin").value;
        if (oS !== "origin" && oS !== "") {
          o = geometryManager.points[parseInt(oS)].position;
        }
        const rC = new THREE.Vector3().crossVectors(v1.components, v2.components);

        const baseName = `ProduitVect(${v1.name},${v2.name})`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "vector");

        const newVector = new Vector(uniqueName, o, rC, 0x4682b4);
        geometryManager.addVector(newVector);

        // --- NOUVELLE MISE EN FORME HTML (SIMPLE ET ALIGN√âE √Ä GAUCHE) ---
        const componentsText = `(${formatNumber(rC.x)}, ${formatNumber(rC.y)}, ${formatNumber(rC.z)})`;
        const normText = formatNumber(rC.length(), 3);

        r.innerHTML = `Vecteur "${uniqueName}" cr√©√©<br>
                     Composantes: <strong>${componentsText}</strong><br>
                     Norme ‚âà <strong>${normText}</strong>`;
        // --- FIN DE LA MODIFICATION ---

        updateAllUI();
      }

      function calculatePointPointDistance() {
        const [i1, i2] = [
          document.getElementById("distPointSelect1").value,
          document.getElementById("distPointSelect2").value,
        ];
        if (i1 === "" || i2 === "") return;
        const p1 = geometryManager.points[i1],
          p2 = geometryManager.points[i2];
        const d = p1.position.distanceTo(p2.position);
        document.getElementById("distResult1").innerHTML = `Dist(${p1.name},${p2.name}) = <strong>${d.toFixed(
          3
        )}</strong>`;
      }

      function calculatePointLineDistance() {
        const pI = document.getElementById("distPointSelect3").value,
          lI = document.getElementById("distLineSelect1").value;
        if (pI === "" || lI === "") return;
        const p = geometryManager.points[pI],
          l = geometryManager.findLineById(parseInt(lI));

        // --- CORRECTION APPLIQU√âE ---
        const lineMath = new THREE.Line3(
          l.startPoint.clone().add(l.directorVector.clone().normalize().multiplyScalar(-1000)),
          l.startPoint.clone().add(l.directorVector.clone().normalize().multiplyScalar(1000))
        );
        const closestPoint = new THREE.Vector3();
        lineMath.closestPointToPoint(p.position, true, closestPoint);
        const d = p.position.distanceTo(closestPoint);
        // --- FIN DE LA CORRECTION ---

        document.getElementById("distResult2").innerHTML = `Dist(${p.name}, ${l.name}) = <strong>${d.toFixed(
          3
        )}</strong>`;
      }

      function calculatePointPlaneDistance() {
        const pI = document.getElementById("calcPointSelect").value,
          plId = parseInt(document.getElementById("calcPlaneSelect1").value);
        const r = document.getElementById("calcResultDisplay1"); // CORRECTED ID
        if (pI === "" || isNaN(plId)) {
          r.textContent = "S√©lectionnez un point et un plan.";
          return;
        }
        const pt = geometryManager.points[pI],
          pl = geometryManager.findPlaneById(plId);
        const vP0P = new THREE.Vector3().subVectors(pt.position, pl.pointOnPlane);
        const d = Math.abs(vP0P.dot(pl.normal));
        r.innerHTML = `Distance = <strong>${d.toFixed(3)}</strong>`;
      }

      function calculateLineLineAngle() {
        const [l1, l2] = [
          geometryManager.findLineById(parseInt(document.getElementById("angleLineSelect1").value)),
          geometryManager.findLineById(parseInt(document.getElementById("angleLineSelect2").value)),
        ];
        const r = document.getElementById("angleResult1");
        if (!l1 || !l2) {
          r.textContent = "S√©lectionnez deux droites.";
          return;
        }
        let a = (l1.directorVector.angleTo(l2.directorVector) * 180) / Math.PI;
        if (a > 90) a = 180 - a;
        r.innerHTML = `Angle ‚âà <strong>${a.toFixed(2)}¬∞</strong>`;
      }

      function calculatePlanePlaneAngle() {
        const [p1, p2] = [
          geometryManager.findPlaneById(parseInt(document.getElementById("anglePlaneSelect1").value)),
          geometryManager.findPlaneById(parseInt(document.getElementById("anglePlaneSelect2").value)),
        ];
        const r = document.getElementById("angleResult2");
        if (!p1 || !p2) {
          r.textContent = "S√©lectionnez deux plans.";
          return;
        }
        let a = (p1.normal.angleTo(p2.normal) * 180) / Math.PI;
        if (a > 90) a = 180 - a;
        r.innerHTML = `Angle ‚âà <strong>${a.toFixed(2)}¬∞</strong>`;
      }

      function calculateLinePlaneAngle() {
        const l = geometryManager.findLineById(parseInt(document.getElementById("angleLineSelect3").value)),
          p = geometryManager.findPlaneById(parseInt(document.getElementById("anglePlaneSelect3").value));

        const r = document.getElementById("angleResult3");
        if (!l || !p) {
          r.textContent = "S√©lectionnez une droite et un plan.";
          return;
        }
        const dot = Math.abs(l.directorVector.clone().normalize().dot(p.normal));
        const a = (Math.asin(dot) * 180) / Math.PI;
        r.innerHTML = `Angle ‚âà <strong>${a.toFixed(2)}¬∞</strong>`;
      }

      function calculateLinePlaneIntersection() {
        console.log("calculateLinePlaneIntersection1");
        // 1. R√©cup√©ration des √©l√©ments UI (inchang√©)
        const lineSelect = document.getElementById("calcLineSelect");
        const planeSelect = document.getElementById("calcPlaneSelect2");
        const resultDisplay = document.getElementById("calcResultDisplay2");

        if (!lineSelect || !planeSelect || !resultDisplay) {
          console.error("IDs de s√©lection pour le calcul d'intersection non trouv√©s.");
          return;
        }

        // 2. R√©cup√©ration des objets g√©om√©triques (inchang√©)
        const line = geometryManager.findLineById(parseInt(lineSelect.value));
        const plane = geometryManager.findPlaneById(parseInt(planeSelect.value));

        if (!line || !plane) {
          resultDisplay.innerHTML = "Veuillez s√©lectionner une droite et un plan valides.";
          return;
        }

        // 3. Calcul de l'intersection (inchang√©)
        const p0 = line.startPoint;
        const v = line.directorVector;
        const planePoint = plane.pointOnPlane;
        const n = plane.displayNormal;
        const dotNV = n.dot(v);

        if (Math.abs(dotNV) < 1e-6) {
          const pointIsOnPlane = Math.abs(n.dot(new THREE.Vector3().subVectors(p0, planePoint))) < 1e-6;
          if (pointIsOnPlane) {
            resultDisplay.innerHTML = "La droite est contenue dans le plan (infinit√© d'intersections).";
          } else {
            resultDisplay.innerHTML = "La droite est parall√®le au plan (aucune intersection).";
          }
          return;
        }

        const t = n.dot(new THREE.Vector3().subVectors(planePoint, p0)) / dotNV;
        const intersectionPoint = new THREE.Vector3().copy(p0).addScaledVector(v, t);

        // --- D√âBUT DE LA MODIFICATION ---
        // On applique VOTRE fonction formatNumber aux r√©sultats du calcul

        // 4. Formatage des coordonn√©es pour l'affichage et la saisie
        const formattedX = formatNumber(intersectionPoint.x);
        const formattedY_UI = formatNumber(intersectionPoint.z); // Le Z de Three.js est le Y de l'UI (profondeur)
        const formattedZ_UI = formatNumber(intersectionPoint.y); // Le Y de Three.js est le Z de l'UI (hauteur)

        // 5. Remplissage des champs de saisie avec les valeurs format√©es
        const pointNameInput = document.getElementById("pointName");
        const pointXInput = document.getElementById("pointX");
        const pointYInput = document.getElementById("pointY");
        const pointZInput = document.getElementById("pointZ");

        const baseName = `Intersect(${line.name},${plane.name})`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "point");

        pointNameInput.value = uniqueName;
        pointXInput.value = formattedX;
        pointYInput.value = formattedY_UI;
        pointZInput.value = formattedZ_UI;

        // 6. Affichage du r√©sultat format√© dans la bo√Æte de dialogue
        const displayCoords = `(${formattedX}, ${formattedY_UI}, ${formattedZ_UI})`;

        resultDisplay.innerHTML = `Coordonn√©es ins√©r√©es dans la section 'Ajouter un point'.<br>
                               Nom sugg√©r√© : <strong>${uniqueName}</strong><br>
                               Coordonn√©es calcul√©es : <strong>${displayCoords}</strong>`;

        // --- FIN DE LA MODIFICATION ---
      }

      function calculatePlanePlaneIntersection() {
        console.log("calculatePlanePlaneIntersection");
        const plane1Id = parseInt(document.getElementById("calcPlaneSelect3").value); // CORRECTED ID
        const plane2Id = parseInt(document.getElementById("calcPlaneSelect4").value); // CORRECTED ID
        const r = document.getElementById("calcResultDisplay3");

        const p1 = geometryManager.findPlaneById(plane1Id);
        const p2 = geometryManager.findPlaneById(plane2Id);

        if (!p1 || !p2) {
          r.textContent = "Veuillez s√©lectionner deux plans distincts.";
          return;
        }

        const n1 = p1.normal;
        const n2 = p2.normal;
        const lineDirection = new THREE.Vector3().crossVectors(n1, n2);

        if (lineDirection.lengthSq() < 1e-8) {
          const vec_p1_p2 = new THREE.Vector3().subVectors(p1.pointOnPlane, p2.pointOnPlane);
          if (Math.abs(vec_p1_p2.dot(n2)) < 1e-6) {
            r.textContent = "Les plans sont confondus.";
          } else {
            r.textContent = "Les plans sont parall√®les et distincts.";
          }
          return;
        }

        let linePoint;
        const d1 = n1.dot(p1.pointOnPlane);
        const d2 = n2.dot(p2.pointOnPlane);
        const absDir = new THREE.Vector3(
          Math.abs(lineDirection.x),
          Math.abs(lineDirection.y),
          Math.abs(lineDirection.z)
        );

        try {
          if (absDir.z > absDir.x && absDir.z > absDir.y) {
            const det = n1.x * n2.y - n2.x * n1.y;
            const x = (n2.y * d1 - n1.y * d2) / det;
            const y = (n1.x * d2 - n2.x * d1) / det;
            linePoint = new THREE.Vector3(x, y, 0);
          } else if (absDir.y > absDir.x) {
            const det = n1.x * n2.z - n2.x * n1.z;
            const x = (n2.z * d1 - n1.z * d2) / det;
            const z = (n1.x * d2 - n2.x * d1) / det;
            linePoint = new THREE.Vector3(x, 0, z);
          } else {
            const det = n1.y * n2.z - n1.z * n2.y; // CORRECTION
            const y = (n2.z * d1 - n1.z * d2) / det;
            const z = (n1.y * d2 - n2.y * d1) / det;
            linePoint = new THREE.Vector3(0, y, z);
          }
        } catch (error) {
          r.textContent = "Erreur num√©rique. Plans quasi parall√®les ?";
          return;
        }

        if (isNaN(linePoint.x)) {
          r.textContent = "Calcul impossible (division par z√©ro).";
          return;
        }

        const baseName = `Intersect(${p1.name}, ${p2.name})`;
        const lineName = geometryManager.generateUniqueName(baseName, "line");
        const newLine = new Line3D(lineName, linePoint, lineDirection, 0xff1493);
        geometryManager.addLine(newLine);
        r.textContent = `Droite d'intersection "${lineName}" cr√©√©e.`;
        updateAllUI();
      }

      function calculateLineLineIntersection() {
        const line1Id = parseInt(document.getElementById("calcLineSelect1").value); // CORRECTED ID
        const line2Id = parseInt(document.getElementById("calcLineSelect2").value); // CORRECTED ID
        const r = document.getElementById("calcResultDisplay4");

        const d1 = geometryManager.findLineById(line1Id);
        const d2 = geometryManager.findLineById(line2Id);

        if (!d1 || !d2) {
          r.textContent = "Veuillez s√©lectionner deux droites distinctes.";
          return;
        }

        const p1 = d1.startPoint,
          v1 = d1.directorVector.clone().normalize();
        const p2 = d2.startPoint,
          v2 = d2.directorVector.clone().normalize();

        const v1_cross_v2 = new THREE.Vector3().crossVectors(v1, v2);
        const p1_minus_p2 = new THREE.Vector3().subVectors(p1, p2);

        if (v1_cross_v2.lengthSq() < 1e-8) {
          if (p1_minus_p2.clone().cross(v1).lengthSq() < 1e-8) {
            r.textContent = "Droites colin√©aires (confondues).";
          } else {
            r.textContent = "Droites parall√®les et distinctes.";
          }
          return;
        }

        const mixedProduct = p1_minus_p2.dot(v1_cross_v2);

        if (Math.abs(mixedProduct) < 1e-6) {
          const p2_minus_p1 = p1_minus_p2.clone().negate();
          const v2_cross_p2p1 = new THREE.Vector3().crossVectors(v2, p2_minus_p1);
          const t = v2_cross_p2p1.dot(v1_cross_v2) / v1_cross_v2.lengthSq();
          const intersectionPoint = p1.clone().add(v1.clone().multiplyScalar(t));
          const baseName = `Intersect(${d1.name}, ${d2.name})`;
          const pointName = geometryManager.generateUniqueName(baseName, "point");
          const newPoint = new Point(
            pointName,
            intersectionPoint.x,
            intersectionPoint.y,
            intersectionPoint.z,
            0x00ff00
          );
          geometryManager.addPoint(newPoint);
          r.innerHTML = `Droites s√©cantes.<br>Point "${pointName}" cr√©√©.`;
          updateAllUI();
        } else {
          const distance = Math.abs(mixedProduct) / v1_cross_v2.length();
          r.innerHTML = `Droites non-coplanaires.<br>Distance min ‚âà <strong>${distance.toFixed(3)}</strong>.`;
        }
      }

      // =====================================================================================
      // SECTION 8 : CONTR√îLE CAM√âRA ET FONCTIONS UTILITAIRES
      // =====================================================================================

      function expandSectionAndScrollToItem(itemId, listId) {
        const listElement = document.getElementById(listId);
        if (!listElement) return;

        // 1. Trouver la section parente et la d√©plier si elle est ferm√©e
        const section = listElement.closest(".section.collapsible");
        if (section && section.classList.contains("collapsed")) {
          section.classList.remove("collapsed");
        }

        // 2. Trouver l'√©l√©ment sp√©cifique dans la liste et le faire d√©filer
        const itemElement = document.getElementById(itemId);
        if (itemElement) {
          // Un petit d√©lai pour s'assurer que l'animation d'ouverture est termin√©e
          setTimeout(() => {
            itemElement.scrollIntoView({ behavior: "smooth", block: "center" });
          }, 300); // 300ms est une bonne valeur
        }
      }

      function togglePanel() {
        const p = document.getElementById("panel"),
          o = document.getElementById("openBtn");
        panelOpen = !panelOpen;
        p.classList.toggle("hidden", !panelOpen);
        o.classList.toggle("show", !panelOpen);
      }

      function ensurePanelVisible() {
        // La variable globale 'panelOpen' nous indique l'√©tat actuel du panneau.
        if (!panelOpen) {
          // Si le panneau n'est pas ouvert, on appelle la fonction existante pour l'ouvrir.
          togglePanel();
        }
      }

      function addFixedTestPoints() {
        const pts = [
          { n: "A", x: 2, y: 0, z: 0 },
          { n: "B", x: 0, y: 3, z: 0 },
          { n: "C", x: 0, y: 0, z: 4 },
        ];
        pts.forEach((p) => {
          if (!geometryManager.points.some((gp) => gp.name === p.n))
            geometryManager.addPoint(new Point(p.n, p.x, p.y, p.z));
        });
        updateAllUI();
      }

      function toggleAutoLoadTestPoints() {
        const c = document.getElementById("autoLoadTestPointsCheckbox");
        localStorage.setItem("autoLoadTestPoints", c.checked);
      }

      function loadTestPointsOnce() {
        addFixedTestPoints();
      }

      function updateCameraPosition() {
        camera.position.x = cameraTarget.x + cameraDistance * Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x);
        camera.position.y = cameraTarget.y + cameraDistance * Math.sin(cameraRotation.x);
        camera.position.z = cameraTarget.z + cameraDistance * Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x);
        camera.lookAt(cameraTarget);
      }

      function onMouseDown(e) {
        wasDragged = false;
        if (e.button === 0) isDragging = true;
        else if (e.button === 2) isPanning = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
      }

      function onMouseMove(e) {
        const dX = e.clientX - previousMousePosition.x,
          dY = e.clientY - previousMousePosition.y;
        if (isDragging || isPanning) if (Math.abs(dX) > 3 || Math.abs(dY) > 3) wasDragged = true;
        if (isDragging) {
          cameraRotation.y += dX * 0.005;
          cameraRotation.x += dY * 0.005;
          cameraRotation.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraRotation.x));
          updateCameraPosition();
        } else if (isPanning) panCamera(dX, dY);
        previousMousePosition = { x: e.clientX, y: e.clientY };
      }

      function onMouseUp() {
        isDragging = false;
        isPanning = false;
      }

      function onWheel(e) {
        e.preventDefault();
        zoomCamera(e.deltaY * 0.01);
      }

      function panCamera(dX, dY) {
        const speed = 0.02;
        const r = new THREE.Vector3();
        camera.getWorldDirection(r);
        const u = camera.up.clone();
        r.cross(u).normalize();
        cameraTarget.addScaledVector(r, -dX * speed);
        cameraTarget.addScaledVector(u, dY * speed);
        updateCameraPosition();
      }

      function zoomCamera(d) {
        cameraDistance = Math.max(3, Math.min(50, cameraDistance + d));
        updateCameraPosition();
      }

      function resetCamera(btn) {
        setCameraView("isometric", btn);
      }

      function setCameraView(v, btn) {
        cameraTarget.set(0, 0, 0);
        cameraDistance = 15;
        switch (v) {
          case "top": // Vue de dessus (regarde le plan XY de l'utilisateur, donc XZ interne)
            cameraRotation.x = Math.PI / 2 - 0.001;
            cameraRotation.y = 0;
            break;
          case "front": // Vue de face (regarde le plan XZ de l'utilisateur, donc XY interne)
            cameraRotation.x = 0;
            cameraRotation.y = Math.PI / 2; // On tourne la cam√©ra pour voir le plan XY interne
            break;
          case "side": // Vue de c√¥t√© (regarde le plan YZ de l'utilisateur, donc YZ interne)
            cameraRotation.x = 0;
            cameraRotation.y = 0;
            break;
          default: // Vue isom√©trique
            cameraRotation.x = 0.5;
            cameraRotation.y = 0.5;
        }
        updateCameraPosition();
        toggleButtonState(btn);
      }

      function toggleButtonState(btn) {
        document.querySelectorAll("#cameraControls .camera-btn").forEach((b) => b.classList.remove("active"));
        if (btn) btn.classList.add("active");
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      document.addEventListener("DOMContentLoaded", () => {
        document.querySelectorAll(".section-header").forEach((header) => {
          header.addEventListener("click", () => header.closest(".section").classList.toggle("collapsed"));
        });
        init();
        const resetBtn = document.getElementById("btnReset");
        resetCamera(resetBtn);
      });

      function applyTranslation() {
        if (!selectedObjectInstance) {
          showSplashScreen("Aucun objet n'est s√©lectionn√©.");
          return;
        }

        // 1. R√©cup√©ration des valeurs de l'interface
        const dx = parseFloat(document.getElementById("transX").value) || 0;
        const dy_ui = parseFloat(document.getElementById("transY").value) || 0; // L'utilisateur pense "Y" (Profondeur)
        const dz_ui = parseFloat(document.getElementById("transZ").value) || 0; // L'utilisateur pense "Z" (Hauteur)

        // 2. CORRECTION DE L'AXE : Conversion vers le rep√®re Three.js
        // Three.js X = UI X
        // Three.js Y (Vertical) = UI Z (Hauteur)
        // Three.js Z (Profondeur) = UI Y (Profondeur)
        const translationVector = new THREE.Vector3(dx, dz_ui, dy_ui);

        const inst = selectedObjectInstance;

        // 3. Application de la translation selon le type d'objet
        if (inst instanceof Point) {
          const newPos = inst.position.clone().add(translationVector);
          // Note : update() attend (nom, x, z, y) car elle refait la conversion en interne,
          // mais ici on manipule directement des positions Three.js, donc on passe x, y, z du vecteur position
          // C'est une petite subtilit√© : on met √† jour la position brute.
          inst.position.copy(newPos);
          inst.mesh.position.copy(inst.position);
          inst.updateLabelPosition();
        } else if (inst instanceof Vector) {
          const newOrigin = inst.origin.clone().add(translationVector);
          // Pour le vecteur, on met √† jour l'origine, les composantes ne changent pas
          inst.update(inst.name, newOrigin, inst.components);
        } else if (inst instanceof Plane) {
          inst.pointOnPlane.add(translationVector);
          inst.mesh.position.copy(inst.pointOnPlane);
        } else if (inst instanceof Line3D) {
          // D√©placer le point de d√©part
          inst.startPoint.add(translationVector);

          // Recalculer la g√©om√©trie visuelle
          const lineLength = 100;
          const dir = inst.directorVector.clone().normalize();
          const start = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(-lineLength));
          const end = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(lineLength));

          // Mise √† jour propre de la g√©om√©trie
          inst.mesh.geometry.dispose(); // Nettoyage m√©moire
          inst.mesh.geometry = new THREE.BufferGeometry().setFromPoints([start, end]);

          // R√©initialiser la couleur si n√©cessaire (garde la s√©lection active visuellement)
          if (inst === selectedObjectInstance) {
            inst.mesh.material.color.set(HIGHLIGHT_COLOR);
          }
        }

        // 4. Mise √† jour de l'interface (notamment les coordonn√©es dans la liste)
        updateAllUI();
      }

function applyRotation() {
  if (!selectedObjectInstance) {
    showSplashScreen("Aucun objet n'est s√©lectionn√©.");
    return;
  }

  // 1. R√©cup√©ration de l'angle
  const angleDeg = parseFloat(document.getElementById("rotationAngle").value) || 0;
  const angleRad = (angleDeg * Math.PI) / 180;

  // 2. R√©cup√©ration et correction de l'Axe
  const axisSelect = document.getElementById("rotationAxisSelect");
  const axisValue = axisSelect.value.toLowerCase().trim(); // S√©curit√© contre les majuscules/espaces

  let rotationAxis;

  // --- C'EST ICI QUE SE JOUE LA CORRECTION ---
  if (axisValue === "x") {
      // Axe X (Rouge) : Ne change pas
      rotationAxis = new THREE.Vector3(1, 0, 0);

  } else if (axisValue === "y") {
      // L'utilisateur choisit "Axe Y" (Profondeur dans votre interface)
      // Cela correspond √† l'axe Z de Three.js (L'axe BLEU)
      rotationAxis = new THREE.Vector3(0, 0, 1);

  } else {
      // L'utilisateur choisit "Axe Z" (Hauteur/Verticale)
      // Cela correspond √† l'axe Y de Three.js (L'axe VERT)
      rotationAxis = new THREE.Vector3(0, 1, 0);
  }

  // 3. R√©cup√©ration du centre de rotation
  const centerValue = document.getElementById("rotationCenterSelect").value;
  const centerOfRotation =
    centerValue === "origin"
      ? new THREE.Vector3(0, 0, 0)
      : geometryManager.points[parseInt(centerValue)].position.clone();

  const inst = selectedObjectInstance;

  // Helper : Appliquer la rotation math√©matique √† un point
  const rotatePoint = (p, c) => {
    p.sub(c); // Ramener au centre relatif
    p.applyAxisAngle(rotationAxis, angleRad); // Tourner
    p.add(c); // Remettre √† la position absolue
  };

  // 4. Application de la rotation selon le type d'objet
  if (inst instanceof Point) {
    const newPos = inst.position.clone();
    rotatePoint(newPos, centerOfRotation);

    // Mise √† jour directe des positions Three.js
    inst.position.copy(newPos);
    inst.mesh.position.copy(inst.position);
    inst.updateLabelPosition();

  } else if (inst instanceof Vector) {
    const newOrigin = inst.origin.clone();
    rotatePoint(newOrigin, centerOfRotation);

    // Le vecteur lui-m√™me (ses composantes) tourne aussi
    const newComponents = inst.components.clone().applyAxisAngle(rotationAxis, angleRad);

    inst.update(inst.name, newOrigin, newComponents);

  } else if (inst instanceof Plane) {
    rotatePoint(inst.pointOnPlane, centerOfRotation);

    // La normale du plan tourne aussi
    inst.normal.applyAxisAngle(rotationAxis, angleRad);
    inst.displayNormal.applyAxisAngle(rotationAxis, angleRad);

    inst.mesh.position.copy(inst.pointOnPlane);
    inst.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), inst.normal.clone().normalize());

  } else if (inst instanceof Line3D) {
    rotatePoint(inst.startPoint, centerOfRotation);
    inst.directorVector.applyAxisAngle(rotationAxis, angleRad);

    // Recalcul g√©om√©trie (identique au fix de translation)
    const lineLength = 100;
    const dir = inst.directorVector.clone().normalize();
    const start = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(-lineLength));
    const end = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(lineLength));

    inst.mesh.geometry.dispose();
    inst.mesh.geometry = new THREE.BufferGeometry().setFromPoints([start, end]);

    // Conserver la couleur de s√©lection
    if(inst === selectedObjectInstance) {
        inst.mesh.material.color.set(HIGHLIGHT_COLOR);
    }
  }

  updateAllUI();
}

       function updateSymmetryUI() {
        const type = document.getElementById("symmetryTypeSelect").value;
        const container = document.getElementById("symmetryOptionsContainer");
        const applyBtn = document.getElementById("applySymmetryBtn");
        container.innerHTML = ""; // Vider les anciennes options

        if (!type) {
          applyBtn.style.display = "none";
          return;
        }

        let selectHTML = `<label>R√©f√©rence :</label><select id="symmetryRefSelect" style="width: 100%;">`;
        let hasOptions = false;

        if (type === "point") {
          if (geometryManager.points.length > 0) {
            geometryManager.points.forEach((p, i) => {
              selectHTML += `<option value="${i}">${p.name}</option>`;
            });
            hasOptions = true;
          } else {
            selectHTML += `<option value="">Aucun point disponible</option>`;
          }
        } else if (type === "line") {
          if (geometryManager.lines.length > 0) {
            geometryManager.lines.forEach((l) => {
              selectHTML += `<option value="${l.id}">${l.name}</option>`;
            });
            hasOptions = true;
          } else {
            selectHTML += `<option value="">Aucune droite disponible</option>`;
          }
        } else if (type === "plane") {
          if (geometryManager.planes.length > 0) {
            geometryManager.planes.forEach((p) => {
              selectHTML += `<option value="${p.id}">${p.name}</option>`;
            });
            hasOptions = true;
          } else {
            selectHTML += `<option value="">Aucun plan disponible</option>`;
          }
        }

        selectHTML += `</select>`;
        container.innerHTML = selectHTML;

        // N'afficher le bouton que si des objets de r√©f√©rence existent
        applyBtn.style.display = hasOptions ? "block" : "none";
      }

      function applySymmetry() {
        if (!selectedObjectInstance) {
          showSplashScreen("Aucun objet n'est s√©lectionn√©.");
          return;
        }

        const type = document.getElementById("symmetryTypeSelect").value;
        const refId = document.getElementById("symmetryRefSelect").value;

        if (!type || !refId) {
          showSplashScreen("Veuillez s√©lectionner un type et une r√©f√©rence pour la sym√©trie.");
          return;
        }

        const inst = selectedObjectInstance;

        // --- Fonctions d'aide √† la sym√©trie (NON-DESTRUCTIVES) ---
        // Elles retournent toujours un NOUVEAU vecteur.
        const reflectPointInPoint = (p, center) => p.clone().sub(center).negate().add(center);

        const reflectPointInLine = (p, line) => {
          const line3 = new THREE.Line3(
            line.startPoint,
            new THREE.Vector3().addVectors(line.startPoint, line.directorVector)
          );
          const projectedPoint = new THREE.Vector3();
          line3.closestPointToPoint(p.clone(), true, projectedPoint);
          return p.clone().sub(projectedPoint).negate().add(projectedPoint);
        };

        const reflectPointInPlane = (p, plane) => {
          const v = new THREE.Vector3().subVectors(p, plane.pointOnPlane);
          const dist = v.dot(plane.normal);
          return p.clone().addScaledVector(plane.normal, -2 * dist);
        };

        // --- Logique principale ---
        let refObject;
        if (type === "point") refObject = geometryManager.points[parseInt(refId)];
        else if (type === "line") refObject = geometryManager.findLineById(parseInt(refId));
        else if (type === "plane") refObject = geometryManager.findPlaneById(parseInt(refId));

        if (!refObject) {
          showSplashScreen("R√©f√©rence de sym√©trie non trouv√©e.");
          return;
        }

        if (inst instanceof Point) {
          let newPos = inst.position; // On prend la position actuelle
          if (type === "point") newPos = reflectPointInPoint(inst.position, refObject.position);
          else if (type === "line") newPos = reflectPointInLine(inst.position, refObject);
          else if (type === "plane") newPos = reflectPointInPlane(inst.position, refObject);
          inst.update(inst.name, newPos.x, newPos.y, newPos.z);
        } else if (inst instanceof Vector) {
          let newOrigin = inst.origin;
          let endPoint = new THREE.Vector3().addVectors(inst.origin, inst.components);

          if (type === "point") {
            newOrigin = reflectPointInPoint(inst.origin, refObject.position);
            endPoint = reflectPointInPoint(endPoint, refObject.position);
          } else if (type === "line") {
            newOrigin = reflectPointInLine(inst.origin, refObject);
            endPoint = reflectPointInLine(endPoint, refObject);
          } else if (type === "plane") {
            newOrigin = reflectPointInPlane(inst.origin, refObject);
            endPoint = reflectPointInPlane(endPoint, refObject);
          }
          const newComponents = new THREE.Vector3().subVectors(endPoint, newOrigin);
          inst.update(inst.name, newOrigin, newComponents);
        } else if (inst instanceof Line3D) {
          // Pour une droite, on r√©fl√©chit son point de d√©part et son vecteur directeur.
          let newStartPoint = inst.startPoint;
          let newDirectorVector = inst.directorVector;
          let endPoint = new THREE.Vector3().addVectors(inst.startPoint, inst.directorVector);

          if (type === "point") {
            newStartPoint = reflectPointInPoint(inst.startPoint, refObject.position);
            newDirectorVector = reflectPointInPoint(endPoint, refObject.position).sub(newStartPoint);
          } else if (type === "line") {
            newStartPoint = reflectPointInLine(inst.startPoint, refObject);
            newDirectorVector = reflectPointInLine(endPoint, refObject).sub(newStartPoint);
          } else if (type === "plane") {
            newStartPoint = reflectPointInPlane(inst.startPoint, refObject);
            newDirectorVector = reflectPointInPlane(endPoint, refObject).sub(newStartPoint);
          }

          inst.startPoint.copy(newStartPoint);
          inst.directorVector.copy(newDirectorVector);
          const lineLength = 100;
          const dir = inst.directorVector.clone().normalize();
          const start = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(-lineLength));
          const end = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(lineLength));
          inst.mesh.geometry.setFromPoints([start, end]);
          inst.mesh.geometry.computeBoundingSphere();
        } else if (inst instanceof Plane) {
          // Pour un plan, on r√©fl√©chit son point de r√©f√©rence et son vecteur normal.
          let newPointOnPlane = inst.pointOnPlane;
          let endPointNormal = new THREE.Vector3().addVectors(inst.pointOnPlane, inst.normal);

          if (type === "point") {
            newPointOnPlane = reflectPointInPoint(inst.pointOnPlane, refObject.position);
            inst.normal.copy(reflectPointInPoint(endPointNormal, refObject.position).sub(newPointOnPlane));
          } else if (type === "line") {
            newPointOnPlane = reflectPointInLine(inst.pointOnPlane, refObject);
            inst.normal.copy(reflectPointInLine(endPointNormal, refObject).sub(newPointOnPlane));
          } else if (type === "plane") {
            newPointOnPlane = reflectPointInPlane(inst.pointOnPlane, refObject);
            // La r√©flexion d'un vecteur normal par rapport √† un plan est une op√©ration de r√©flexion vectorielle.
            inst.normal.reflect(refObject.normal);
          }
          inst.pointOnPlane.copy(newPointOnPlane);
          inst.displayNormal.copy(inst.normal); // Synchroniser le vecteur d'affichage

          inst.mesh.position.copy(inst.pointOnPlane);
          inst.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), inst.normal.clone().normalize());
        }

        updateAllUI();
        console.log(`Sym√©trie par rapport √† "${refObject.name}" appliqu√©e √† "${inst.name}".`);
      }

      function saveScene() {
        const sceneName = document.getElementById("sceneNameInput").value.trim();
        if (!sceneName) {
          showSplashScreen("Veuillez donner un nom √† votre sc√®ne.");
          return;
        }
        // 1. S√©rialiser la g√©om√©trie actuelle
        const sceneData = {
          name: sceneName,
          timestamp: new Date().toISOString(),
          geometry: {
            points: geometryManager.points.map((p) => ({
              name: p.name,
              position: { x: p.position.x, y: p.position.y, z: p.position.z },
            })),
            vectors: geometryManager.vectors.map((v) => ({
              id: v.id,
              name: v.name,
              origin: { x: v.origin.x, y: v.origin.y, z: v.origin.z },
              components: { x: v.components.x, y: v.components.y, z: v.components.z },
              isLabelVisible: v.isLabelVisible,
            })),
            lines: geometryManager.lines.map((l) => ({
              id: l.id,
              name: l.name,
              startPoint: { x: l.startPoint.x, y: l.startPoint.y, z: l.startPoint.z },
              directorVector: { x: l.directorVector.x, y: l.directorVector.y, z: l.directorVector.z },
            })),
            planes: geometryManager.planes.map((p) => ({
              id: p.id,
              name: p.name,
              pointOnPlane: { x: p.pointOnPlane.x, y: p.pointOnPlane.y, z: p.pointOnPlane.z },
              displayNormal: { x: p.displayNormal.x, y: p.displayNormal.y, z: p.displayNormal.z },
            })),
          },
        };

        // 2. G√©rer le stockage
        let savedScenes = JSON.parse(localStorage.getItem("savedScenes")) || [];

        // V√©rifier si une sc√®ne avec le m√™me nom existe d√©j√†
        const existingSceneIndex = savedScenes.findIndex((s) => s.name === sceneName);
        if (existingSceneIndex > -1) {
          if (confirm(`Une sc√®ne nomm√©e "${sceneName}" existe d√©j√†. Voulez-vous la remplacer ?`)) {
            savedScenes[existingSceneIndex] = sceneData;
          } else {
            return; // L'utilisateur a annul√©
          }
        } else {
          savedScenes.push(sceneData);
        }

        // 3. Sauvegarder dans localStorage
        localStorage.setItem("savedScenes", JSON.stringify(savedScenes));
        showSplashScreen(`‚úÖ Sc√®ne "${sceneName}" enregistr√©e !`);

        // 4. Mettre √† jour la liste des sc√®nes chargeables
        populateSavedScenesSelect();
      }

      function loadScene() {
        const sceneName = document.getElementById("savedScenesSelect").value;
        if (!sceneName) {
          showSplashScreen("Veuillez s√©lectionner une sc√®ne √† charger.");
          return;
        }

        const savedScenes = JSON.parse(localStorage.getItem("savedScenes")) || [];
        const sceneData = savedScenes.find((s) => s.name === sceneName);

        if (!sceneData) {
          showSplashScreen("Erreur : Impossible de trouver les donn√©es de la sc√®ne.");
          return;
        }

        // 1. Nettoyer la sc√®ne actuelle
        geometryManager.clearAll();

        // 2. D√©s√©rialiser et reconstruire la g√©om√©trie
        sceneData.geometry.points.forEach((p) => {
          geometryManager.addPoint(new Point(p.name, p.position.x, p.position.y, p.position.z));
        });

        sceneData.geometry.vectors.forEach((v) => {
          const origin = new THREE.Vector3(v.origin.x, v.origin.y, v.origin.z);
          const components = new THREE.Vector3(v.components.x, v.components.y, v.components.z);
          // On doit recr√©er le vecteur avec son ID pour garder la coh√©rence
          const newVector = new Vector(v.name, origin, components);
          newVector.id = v.id;
          nextVectorId = Math.max(nextVectorId, v.id + 1); // Important pour ne pas avoir de conflits d'ID
          if (v.isLabelVisible === false) {
            newVector.setLabelVisibility(false);
          }

          geometryManager.addVector(newVector);
        });

        sceneData.geometry.lines.forEach((l) => {
          const startPoint = new THREE.Vector3(l.startPoint.x, l.startPoint.y, l.startPoint.z);
          const directorVector = new THREE.Vector3(l.directorVector.x, l.directorVector.y, l.directorVector.z);
          const newLine = new Line3D(l.name, startPoint, directorVector);
          newLine.id = l.id;
          nextStraightLineId = Math.max(nextStraightLineId, l.id + 1);
          geometryManager.addLine(newLine);
        });

        sceneData.geometry.planes.forEach((p) => {
          const pointOnPlane = new THREE.Vector3(p.pointOnPlane.x, p.pointOnPlane.y, p.pointOnPlane.z);
          const normal = new THREE.Vector3(p.displayNormal.x, p.displayNormal.y, p.displayNormal.z);
          const newPlane = new Plane(p.name, pointOnPlane, normal);
          newPlane.id = p.id;
          nextPlaneId = Math.max(nextPlaneId, p.id + 1);
          geometryManager.addPlane(newPlane);
        });
        showSplashScreen(`‚úÖ Sc√®ne "${sceneName}" charg√©e !`);
        // 3. Mettre √† jour l'ensemble de l'interface
        updateAllUI();
      }

      function deleteScene() {
        const sceneName = document.getElementById("savedScenesSelect").value;
        if (!sceneName) {
          showSplashScreen("Veuillez s√©lectionner une sc√®ne √† supprimer.");
          return;
        }

        if (confirm(`√ätes-vous s√ªr de vouloir supprimer la sc√®ne "${sceneName}" ? Cette action est irr√©versible.`)) {
          let savedScenes = JSON.parse(localStorage.getItem("savedScenes")) || [];
          const updatedScenes = savedScenes.filter((s) => s.name !== sceneName);
          localStorage.setItem("savedScenes", JSON.stringify(updatedScenes));
          populateSavedScenesSelect();
          showSplashScreen(`‚úÖ Sc√®ne "${sceneName}"supprim√©e !`);
        }
      }

      function populateSavedScenesSelect() {
        const select = document.getElementById("savedScenesSelect");
        select.innerHTML = ""; // Vider les anciennes options

        const savedScenes = JSON.parse(localStorage.getItem("savedScenes")) || [];

        if (savedScenes.length === 0) {
          select.add(new Option("Aucune sc√®ne enregistr√©e", ""));
        } else {
          savedScenes.forEach((scene) => {
            select.add(new Option(scene.name, scene.name));
          });
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        populateSavedScenesSelect(); // Ajoutez cette ligne !
      });

      function showSplashScreen(message, duration = 2000) {
        const splashElement = document.getElementById("splashScreen");
        const messageElement = document.getElementById("splashMessage");

        // Annule un timer pr√©c√©dent si une notification √©tait d√©j√† en cours de disparition
        if (splashTimer) {
          clearTimeout(splashTimer);
        }

        // 1. Mettre √† jour le message et afficher l'√©l√©ment
        messageElement.textContent = message;
        splashElement.classList.remove("splash-hidden");

        // 2. Programmer la disparition de l'√©l√©ment apr√®s la dur√©e sp√©cifi√©e
        splashTimer = setTimeout(() => {
          splashElement.classList.add("splash-hidden");
          splashTimer = null; // R√©initialiser le timer
        }, duration);
      }
      function hideContextMenu() {
        console.log("hideContextMenu");
        const menu = document.getElementById("contextMenu");
        if (menu) {
          menu.style.display = "none";
        }
      }
    </script>
  </body>
</html>
