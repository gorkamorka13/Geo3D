<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>√âditeur de Points 3D</title>
  <!-- IMPORTANT: La biblioth√®que Three.js et OrbitControls seront charg√©es ici par votre JavaScript -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/controls/TransformControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <!-- Ajout de Font Awesome pour les ic√¥nes -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
  <style>
    /* =========================================
       1. VARIABLES & TH√àME (Clair / Sombre)
       ========================================= */
    :root {
      /* --- TH√àME CLAIR (D√©faut) --- */
      --bg-color: #f0f0f0;
      --panel-bg: #ffffff;
      --text-color: #333333;
      --text-secondary: #666666;
      --input-bg: #ffffff;
      --input-border: #cccccc;
      --input-focus: #4caf50;
      --item-bg: #ffffff;
      --item-border: #eeeeee;
      --hover-bg: #f9f9f9;
      --button-text: #ffffff;
      --shadow-color: rgba(0, 0, 0, 0.15);
      --burger-color: #333333;
      --camera-btn-bg: #f0f0f0;
      --camera-btn-hover: #e0e0e0;
      --section-border: #ddd;
    }

    [data-theme="dark"] {
      /* --- TH√àME SOMBRE --- */
      --bg-color: #121212;
      --panel-bg: #2c2c2c;
      --text-color: #e0e0e0;
      --text-secondary: #aaaaaa;
      --input-bg: #383838;
      --input-border: #555555;
      --input-focus: #81c784;
      --item-bg: #333333;
      --item-border: #444444;
      --hover-bg: #404040;
      --button-text: #ffffff;
      --shadow-color: rgba(0, 0, 0, 0.5);
      --burger-color: #ffffff;
      --camera-btn-bg: #333333;
      --camera-btn-hover: #444444;
      --section-border: #444;
    }

    /* =========================================
       2. CONFIGURATION G√âN√âRALE
       ========================================= */
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
      touch-action: none;
    }

    /* =========================================
       3. PANNEAU LAT√âRAL
       ========================================= */
    #panel {
      position: absolute;
      top: 20px;
      left: 20px;
      background: var(--panel-bg);
      padding: 65px 20px 20px 20px;
      /* Padding haut pour les boutons */
      border-radius: 8px;
      box-shadow: 0 2px 10px var(--shadow-color);
      max-height: 90vh;
      overflow-y: auto;
      width: 320px;
      transition: transform 0.3s ease, background-color 0.3s ease;
      z-index: 999;
      scrollbar-width: thin;
      scrollbar-color: var(--text-secondary) var(--panel-bg);
    }

    #panel.hidden {
      transform: translateX(calc(-100% - 20px));
    }

    /* Scrollbar Webkit */
    #panel::-webkit-scrollbar {
      width: 8px;
    }

    #panel::-webkit-scrollbar-track {
      background: var(--panel-bg);
    }

    #panel::-webkit-scrollbar-thumb {
      background-color: var(--text-secondary);
      border-radius: 4px;
      border: 2px solid var(--panel-bg);
    }

    /* =========================================
       4. BOUTONS DE NAVIGATION (Burger & Th√®me)
       ========================================= */
    /* Bouton Burger (Fermer) dans le panneau */
    #toggleBtn {
      position: absolute;
      top: 15px;
      left: 15px;
      background: transparent;
      z-index: 1001;
    }

    /* Bouton Th√®me (Lune/Soleil) dans le panneau */
    #themeToggleBtn {
      position: absolute;
      top: 15px;
      right: 15px;
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 18px;
      color: var(--text-color);
      padding: 8px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: background-color 0.2s;
    }

    #themeToggleBtn:hover {
      background-color: var(--hover-bg);
    }

    /* Bouton Burger (Ouvrir) flottant */
    #openBtn {
      position: fixed;
      top: 20px;
      left: 20px;
      background: var(--panel-bg);
      box-shadow: 0 2px 10px var(--shadow-color);
      z-index: 998;
      display: none;
    }

    #openBtn.show {
      display: flex;
    }

    /* Lignes du Burger */
    .burger-btn {
      width: 40px;
      height: 40px;
      padding: 8px;
      border-radius: 6px;
      cursor: pointer;
      border: none;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 4px;
      background-color: transparent;
    }

    .burger-btn:hover {
      background-color: var(--hover-bg) !important;
    }

    .burger-line {
      width: 20px;
      height: 2px;
      background-color: var(--burger-color);
      transition: all 0.3s ease;
    }

    /* =========================================
       5. TYPOGRAPHIE & SECTIONS
       ========================================= */
    h3 {
      margin: 0;
      font-size: 18px;
      color: var(--text-color);
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
      position: relative;
    }

    .section-header h3 {
      font-size: 16px;
      font-weight: bold;
      flex-grow: 1;
    }

    .header-icon {
      font-size: 20px;
      width: 24px;
      text-align: center;
      flex-shrink: 0;
      color: var(--text-color);
    }

    .section {
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--section-border);
    }

    .section:last-of-type {
      border-bottom: none;
      margin-bottom: 0;
    }

    /* Fl√®che d√©pliante */
    .section.collapsible .section-header::after {
      content: "‚ñ≤";
      font-size: 12px;
      color: var(--text-secondary);
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      transition: transform 0.3s ease;
    }

    .section.collapsible.collapsed .section-header::after {
      transform: translateY(-50%) rotate(180deg);
    }

    .section.collapsible.collapsed .section-content {
      display: none;
    }

    .sub-section-title {
      font-size: 13px;
      margin-top: 10px;
      margin-bottom: 10px;
      color: var(--text-color);
      opacity: 0.9;
    }

    /* =========================================
       6. FORMULAIRES & INPUTS
       ========================================= */
    .input-group {
      margin-bottom: 10px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      font-size: 13px;
      font-weight: bold;
      color: var(--text-secondary);
    }

    input,
    select,
    textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--input-border);
      background-color: var(--input-bg);
      color: var(--text-color);
      border-radius: 4px;
      font-size: 13px;
      box-sizing: border-box;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: var(--input-focus);
    }

    .coord-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 8px 0;
    }

    .checkbox-group input {
      width: auto;
    }

    .checkbox-group label {
      margin: 0;
      cursor: pointer;
    }

    .equation-display {
      background: var(--hover-bg);
      padding: 10px;
      border-radius: 4px;
      font-family: "Courier New", monospace;
      font-size: 13px;
      color: var(--text-color);
      min-height: 20px;
      display: block;
      text-align: left;
      word-break: break-all;
      border: 1px solid var(--item-border);
    }

    /* =========================================
       7. BOUTONS D'ACTION
       ========================================= */
    button {
      width: 100%;
      margin: 8px 0;
      padding: 10px;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: background-color 0.2s;
    }

    /* Bouton Principal (Vert) */
    button:not([class]) {
      background: #4caf50;
    }

    button:not([class]):hover {
      background: #45a049;
    }

    #addPointBtn {
      background: #4caf50;
    }

    #addPointBtn:hover {
      background: #45a049;
    }

    /* Classes sp√©cifiques */
    .btn-secondary {
      background: #2196f3;
    }

    .btn-secondary:hover {
      background: #0b7dda;
    }

    .btn-danger {
      background: #f44336;
    }

    .btn-danger:hover {
      background: #da190b;
    }

    .btn-warning {
      background: #ff9800;
    }

    .btn-warning:hover {
      background: #e68900;
    }

    .btn-violet {
      background: #8a2be2;
    }

    .btn-violet:hover {
      background: #7a25c4;
    }

    .btn-violet-light {
      background: #9370db;
    }

    .btn-violet-light:hover {
      background: #825fbc;
    }

    .edit-actions-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-top: 10px;
    }

    .edit-actions-container button {
      font-size: 12px;
      margin: 0;
      padding: 10px 5px;
    }

    /* =========================================
       8. LISTES (Items G√©om√©triques)
       ========================================= */
    .point-list,
    .geometry-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid var(--input-border);
      border-radius: 4px;
      padding: 5px;
      background: var(--hover-bg);
      /* Fond l√©g√®rement diff√©rent du panel */
    }

    .point-item,
    .geometry-item {
      padding: 8px;
      margin: 5px 0;
      background: var(--item-bg);
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      font-size: 13px;
      border: 1px solid var(--item-border);
      color: var(--text-color);
    }

    .geometry-item-main {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      width: 100%;
      gap: 10px;
    }

    .geometry-info {
      flex-grow: 1;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .point-name,
    .geometry-name {
      font-weight: bold;
      color: var(--text-color);
      font-size: 13px;
      word-break: break-word;
    }

    .geometry-coords,
    .geometry-details {
      font-size: 12px;
      color: var(--text-secondary);
      word-break: break-word;
    }

    .geometry-details-secondary {
      font-size: 11px;
      color: var(--text-secondary);
      margin-top: 4px;
      padding-left: 2px;
    }

    /* Force la couleur des spans g√©n√©r√©s dynamiquement si n√©cessaire */
    .geometry-details-secondary span {
      color: var(--text-secondary) !important;
    }

    .geometry-actions {
      display: flex;
      gap: 5px;
      flex-shrink: 0;
    }

    .geometry-actions button {
      width: auto;
      padding: 5px 8px;
      font-size: 11px;
      margin: 0;
    }

    /* =========================================
       9. CONTR√îLES CAM√âRA
       ========================================= */
    #cameraControls {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 990;
      pointer-events: auto;
    }

    .camera-btn {
      width: 40px;
      height: 40px;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: var(--camera-btn-bg);
      border: 1px solid var(--input-border);
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.2s, border-color 0.2s;
      color: var(--text-color);
      font-size: 18px;
      box-shadow: 0 2px 4px var(--shadow-color);
    }

    .camera-btn:hover {
      background-color: var(--camera-btn-hover);
    }

    .camera-btn.active {
      background-color: #2196f3;
      color: white;
      border-color: #2196f3;
    }

    /* Adaptation des SVG cam√©ra pour le mode sombre (optionnel,
       les polygones ont des fills hardcod√©s mais le cadre changera) */

    /* =========================================
       10. MENU CONTEXTUEL & TOOLS
       ========================================= */
    .context-menu {
      position: fixed;
      z-index: 2147483647;
      background-color: var(--panel-bg);
      border: 1px solid var(--input-border);
      box-shadow: 2px 2px 10px var(--shadow-color);
      border-radius: 4px;
      padding: 5px 0;
      min-width: 160px;
      display: none;
    }

    .context-menu-items {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .context-menu-items li {
      padding: 8px 15px;
      font-size: 14px;
      color: var(--text-color);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      border-bottom: 1px solid var(--item-border);
    }

    .context-menu-items li:last-child {
      border-bottom: none;
    }

    .context-menu-items li:hover {
      background-color: var(--hover-bg);
    }

    #splashScreen {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(40, 40, 40, 0.95);
      /* Toujours sombre pour contraste */
      color: white;
      padding: 12px 25px;
      border-radius: 25px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      z-index: 10001;
      font-size: 14px;
      font-weight: bold;
      transition: opacity 0.5s ease-in-out, top 0.5s ease-in-out;
    }

    #splashScreen.splash-hidden {
      opacity: 0;
      top: -100px;
      pointer-events: none;
    }

    #tooltip {
      position: fixed;
      background-color: rgba(0, 0, 0, 0.85);
      /* Toujours sombre */
      color: #fff;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      display: none;
      z-index: 500;
      white-space: nowrap;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      transform: translate(15px, 15px);
    }

    /* =========================================
       11. RESPONSIVE (MOBILE)
       ========================================= */
    @media (max-width: 768px) {
      #panel {
        background: var(--panel-bg);
        width: fit-content;
        min-width: 280px;
        opacity: 0.98;
        /* L√©g√®rement plus opaque sur mobile */
      }

      #openBtn {
        top: 15px;
        left: 15px;
      }

      .camera-btn svg {
        pointer-events: none;
      }
    }

    #panel.no-transition {
      transition: none;
    }
  </style>
</head>

<body>
  <div id="splashScreen" class="splash-hidden">
    <span id="splashMessage"></span>
  </div>

  <div id="tooltip"></div>

  <button id="openBtn" class="burger-btn show" onclick="togglePanel()">
    <span class="burger-line"></span>
    <span class="burger-line"></span>
    <span class="burger-line"></span>
  </button>
  <div id="container">
    <div id="cameraControls">

      <!-- Vue de dessus (XY) : La face sup√©rieure du cube est noire -->
      <div class="camera-btn" id="btnTop" onclick="setCameraView('top', this)" title="Vue de dessus (XY)">
        <svg width="40" height="40" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
          <!-- Face du dessus (noire) -->
          <polygon points="5,15 25,5 45,15 25,25" fill="#222222" />
          <!-- Face de droite (claire) -->
          <polygon points="45,15 45,35 25,45 25,25" fill="#e6e6e6" />
          <!-- Face de gauche (moyenne) -->
          <polygon points="5,15 5,35 25,45 25,25" fill="#cacaca" />
        </svg>

      </div>

      <!-- Vue de face (XZ) : La face de "gauche" (qui repr√©sente l'avant) est noire -->
      <div class="camera-btn" id="btnFront" onclick="setCameraView('front', this)" title="Vue de face (XZ)">
        <svg width="40" height="40" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
          <!-- Face du dessus (moyenne) -->
          <polygon points="5,15 25,5 45,15 25,25" fill="#cacaca" />
          <!-- Face de droite (claire) -->
          <polygon points="45,15 45,35 25,45 25,25" fill="#e6e6e6" />
          <!-- Face de gauche/avant (noire) -->
          <polygon points="5,15 5,35 25,45 25,25" fill="#222222" />
        </svg>
      </div>

      <!-- Vue de c√¥t√© (YZ) : La face de "droite" (qui repr√©sente le c√¥t√©) est noire -->
      <div class="camera-btn" id="btnSide" onclick="setCameraView('side', this)" title="Vue de c√¥t√© (YZ)">
        <svg width="40" height="40" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
          <!-- Face du dessus (moyenne) -->
          <polygon points="5,15 25,5 45,15 25,25" fill="#cacaca" />
          <!-- Face de droite/c√¥t√© (noire) -->
          <polygon points="45,15 45,35 25,45 25,25" fill="#222222" />
          <!-- Face de gauche (claire) -->
          <polygon points="5,15 5,35 25,45 25,25" fill="#e6e6e6" />
        </svg>
      </div>

      <div class="camera-btn" id="btnReset" onclick="resetCamera(this)" title="R√©initialiser la vue (Isom√©trique)">
        <i class="fas fa-sync-alt"></i>
      </div>
      <div class="camera-btn" id="btnUndo" onclick="undo()" title="Annuler (Ctrl+Z)"
        style="opacity: 0.5; pointer-events: none;">
        <i class="fas fa-undo"></i>
      </div>
      <div class="camera-btn" id="btnRedo" onclick="redo()" title="R√©tablir (Ctrl+Y)"
        style="opacity: 0.5; pointer-events: none;">
        <i class="fas fa-redo"></i>
      </div>

    </div>
    <div id="panel" class="hidden">
      <button id="toggleBtn" class="burger-btn" onclick="togglePanel()">
        <span class="burger-line"></span>
        <span class="burger-line"></span>
        <span class="burger-line"></span>
      </button>
      <button id="themeToggleBtn" onclick="toggleTheme()" title="Changer le th√®me">
        <i class="fas fa-moon"></i>
      </button>
      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üíæ Gestion des Sc√®nes</h3>
        </div>
        <div class="section-content">
          <label>Nom de la sc√®ne :</label>
          <input type="text" id="sceneNameInput" placeholder="Ex: Ma Sc√®ne 1" />
          <button class="btn-secondary" onclick="saveScene()">üíæ Enregistrer la sc√®ne</button>

          <h4 class="sub-section-title" style="margin-top: 20px">Charger une sc√®ne :</h4>
          <label>Sc√®nes sauvegard√©es :</label>
          <select id="savedScenesSelect" style="margin-bottom: 8px"></select>

          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px">
            <button class="btn-violet" onclick="loadScene()">üîÑ Charger</button>
            <button class="btn-danger" onclick="deleteScene()">üóëÔ∏è Supprimer</button>
          </div>
          <button class="btn-warning" style="margin-top: 15px; background-color: #607d8b;"
            onclick="downloadDebugJSON()">
            üêû Exporter JSON (Debug)
        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üìç Tracer des points</h3>
        </div>
        <div class="section-content">
          <label>Nom du point :</label>
          <input type="text" id="pointName" placeholder="Ex: A, Point1..." />

          <label style="margin-top: 10px">Coordonn√©es (X, Y, Z) :</label>
          <div class="coord-inputs">
            <input type="number" id="pointX" placeholder="X" step="1" />
            <input type="number" id="pointY" placeholder="Y (Profondeur)" step="1" />
            <input type="number" id="pointZ" placeholder="Z (Hauteur)" step="1" />
          </div>

          <!-- Bouton d'ajout de point, visible par d√©faut -->
          <button id="addPointBtn" onclick="addPoint()">‚ûï Ajouter le point</button>

          <!-- NOUVEAU : Conteneur pour les boutons d'action d'√©dition des points -->
          <input type="hidden" id="editPointIndex" />
          <div id="pointEditActions" class="edit-actions-container" style="display: none">
            <button id="updatePointBtn" class="btn-secondary" onclick="updatePoint()">üíæ Mettre √† jour</button>
            <button id="deleteEditingPointBtn" class="btn-danger" onclick="deleteEditingPoint()">üóëÔ∏è Supprimer</button>
            <button id="cancelEditBtn" class="btn-warning" onclick="cancelEdit()">‚ùå Annuler</button>
          </div>
        </div>
        <div class="section-content">
          <div id="pointList" class="point-list"></div>
          <button class="btn-danger" onclick="clearAllPoints()">üóëÔ∏è Effacer tous les points</button>
        </div>
        <div class="section-content">
          <div class="checkbox-group">
            <input type="checkbox" id="autoLoadTestPointsCheckbox" onchange="toggleAutoLoadTestPoints()" />
            <label for="autoLoadTestPointsCheckbox">Charger A, B, C au d√©marrage</label>
          </div>
          <button class="btn-secondary" onclick="loadTestPointsOnce()">‚ûï Charger points A, B, C maintenant</button>
          <p style="font-size: 11px; color: #666; margin-top: 5px"></p>
        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">‚ÜóÔ∏è Tracer des vecteurs</h3>
        </div>
        <div class="section-content">
          <h4 class="sub-section-title">Vecteur entre deux points :</h4>
          <label>Point de d√©part :</label>
          <select id="vectorStartPoint"></select>

          <label style="margin-top: 10px">Point d'arriv√©e :</label>
          <select id="vectorEndPoint"></select>

          <button id="addVectorFromPointsBtn" class="btn-secondary" onclick="addVectorFromPoints()">
            ‚ûï Tracer le vecteur
          </button>

          <h4 class="sub-section-title">Vecteur par coordonn√©es :</h4>
          <label>Nom du vecteur :</label>
          <input type="text" id="vectorNameCoords" placeholder="Ex: V1, Direction..." />
          <label style="margin-top: 10px; color: #2196f3;">Origine du vecteur (Ox, Oy, Oz) :</label>
          <div class="coord-inputs">
            <input type="number" id="vectorOriginX" placeholder="Ox" step="1" />
            <input type="number" id="vectorOriginY" placeholder="Oy (Prof.)" step="1" />
            <input type="number" id="vectorOriginZ" placeholder="Oz (Haut.)" step="1" />
          </div>
          <label style="margin-top: 10px">Coordonn√©es (Vx, Vy, Vz) :</label>
          <div class="coord-inputs">
            <input type="number" id="vectorCoordX" placeholder="Vx" step="1" />
            <input type="number" id="vectorCoordY" placeholder="Vy" step="1" />
            <input type="number" id="vectorCoordZ" placeholder="Vz" step="1" />
          </div>

          <label style="margin-top: 10px">Origine du vecteur :</label>
          <select id="vectorOriginPoint"></select>
          <button id="addVectorFromCoordsBtn" class="btn-secondary" onclick="addVectorFromCoords()">
            ‚ûï Tracer le vecteur
          </button>

          <input type="hidden" id="editVectorId" />

          <!-- NOUVEAU : Conteneur pour les boutons d'action d'√©dition -->
          <div id="vectorEditActions" class="edit-actions-container" style="display: none">
            <button id="updateVectorBtn" class="btn-secondary" onclick="updateVector()">üíæ Mettre √† jour</button>
            <button id="deleteEditingVectorBtn" class="btn-danger" onclick="deleteEditingVector()">üóëÔ∏è
              Supprimer</button>
            <button id="cancelVectorEditBtn" class="btn-warning" onclick="cancelVectorEdit()">‚ùå Annuler</button>
          </div>

          <h4 class="sub-section-title">Vecteurs existants :</h4>
          <div id="vectorList" class="geometry-list"></div>
          <button class="btn-danger" onclick="clearAllVectors()">üóëÔ∏è Effacer tous les vecteurs</button>
        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üìè Tracer des droites</h3>
        </div>
        <div class="section-content">
          <h4 class="sub-section-title">Droite par deux points :</h4>
          <label>Premier point :</label>
          <select id="lineStart"></select>
          <label style="margin-top: 10px">Deuxi√®me point :</label>
          <select id="lineEnd"></select>
          <button class="btn-secondary" onclick="addStraightLine()">‚ûï Tracer la droite</button>

          <h4 class="sub-section-title">Droite par Point et Vecteur :</h4>
          <label>Nom de la droite :</label>
          <input type="text" id="lineNamePV" placeholder="Ex: D1, Delta..." />

          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; gap: 8px;">
            <div>
              <label style="font-size: 11px;">Point de passage :</label>
              <select id="linePointPVSelect"></select>
            </div>
            <div>
              <label style="font-size: 11px;">Vecteur directeur :</label>
              <select id="lineVectorPVSelect"></select>
            </div>
          </div>

          <button class="btn-secondary" onclick="addLineFromPointVector()">‚ûï Tracer la droite (Point + Vecteur)</button>

          <!-- D√âBUT MODIFICATION √âTAPE 1 : UI pour Droite par √©quation -->
          <h4 class="sub-section-title">Droite par √©quation param√©trique :</h4>
          <label>Nom de la droite :</label>
          <input type="text" id="lineNameFromEquation" placeholder="Ex: D1, MaDroite..." />

          <label style="margin-top: 10px; color: #2196f3;">Point de passage (Optionnel) :</label>
          <select id="lineEquationPointSelect" onchange="onLineEquationPointChange()">
            <!-- Sera rempli par JS -->
          </select>

          <label style="font-size:11px; color:#666;">Ou coordonn√©es manuelles du point ($P_0$) :</label>
          <div class="coord-inputs">
            <input type="number" id="lineEqPointX" placeholder="Px" step="1" />
            <input type="number" id="lineEqPointY" placeholder="Py (Prof.)" step="1" />
            <input type="number" id="lineEqPointZ" placeholder="Pz (Haut.)" step="1" />
          </div>

          <label style="margin-top: 10px">√âquations (pour le vecteur directeur) :</label>
          <textarea id="lineEquationInput" rows="3" placeholder="x = 2t&#10;y = t&#10;z = -5t"
            style="font-family: monospace"></textarea>
          <button class="btn-secondary" onclick="addLineFromEquation()">‚ûï Cr√©er la droite</button>
          <!-- FIN MODIFICATION √âTAPE 1 -->


          <h4 class="sub-section-title">Droites existantes :</h4>
          <div id="lineList" class="geometry-list"></div>
          <button class="btn-danger" onclick="clearStraightLines()">üóëÔ∏è Effacer les droites</button>
        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üî∑ Tracer des plans</h3>
        </div>
        <div class="section-content">
          <h4 class="sub-section-title">Plan par 3 points :</h4>
          <label>Nom du plan :</label>
          <input type="text" id="planeName" placeholder="Ex: P1, MonPlan..." />

          <label style="margin-top: 10px">Premier point :</label>
          <select id="planeSelectP1"></select>

          <label style="margin-top: 10px">Deuxi√®me point :</label>
          <select id="planeSelectP2"></select>

          <label style="margin-top: 10px">Troisi√®me point :</label>
          <select id="planeSelectP3"></select>

          <button class="btn-warning" onclick="addPlane()">‚ûï Ajouter ce plan</button>


          <!-- ... dans la section "Plan par √©quation" ... -->

          <h4 class="sub-section-title">Plan par vecteur normal (√©quation) :</h4>

          <!-- NOUVEAU : S√©lection du point de passage -->
          <label style="color: #2196f3;">Point de passage (Optionnel) :</label>
          <select id="planeEquationPointSelect" onchange="onPlaneEquationPointChange()">
            <!-- Sera rempli par JS -->
          </select>

          <label style="font-size:11px; color:#666;">Ou coordonn√©es manuelles ($P_0$) :</label>
          <div class="coord-inputs">
            <input type="number" id="planeEqPointX" placeholder="Px" step="1" />
            <input type="number" id="planeEqPointY" placeholder="Py (Prof.)" step="1" />
            <input type="number" id="planeEqPointZ" placeholder="Pz (Haut.)" step="1" />
          </div>

          <!-- <label style="margin-top: 10px">√âquation (pour le vecteur normal a,b,c) :</label>
          <input type="text" id="planeEquationInput" placeholder="Ex: 2x - y + 3z = 0" />
          <button class="btn-warning" onclick="addPlaneFromEquation()">‚ûï Cr√©er le plan</button> -->

          <h4 class="sub-section-title">Plan par √©quation :</h4>
          <label>√âquation cart√©sienne (ax+by+cz+d=0) :</label>
          <input type="text" id="planeEquationInput" placeholder="Ex: 2x - y + 3z - 6 = 0" />
          <button class="btn-warning" onclick="addPlaneFromEquation()">‚ûï Cr√©er le plan depuis l'√©quation</button>

          <h4 class="sub-section-title">Plans existants :</h4>
          <div id="planeList" class="geometry-list"></div>
          <button class="btn-danger" onclick="clearAllPlanes()">üóëÔ∏è Effacer tous les plans</button>
        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üìà √âquations g√©om√©triques</h3>
        </div>
        <div class="section-content">
          <h4 class="sub-section-title">√âquation de plan :</h4>
          <label>S√©lectionner un plan pour voir son √©quation :</label>
          <select id="equationPlaneSelect" onchange="displayPlaneEquation()"></select>
          <div id="planeEquationDisplay" class="equation-display"></div>

          <h4 class="sub-section-title" style="margin-top: 20px">√âquation param√©trique de droite :</h4>
          <label>S√©lectionner une droite pour voir son √©quation :</label>
          <select id="equationLineSelect" onchange="displayLineEquation()"></select>

          <div id="lineEquationDisplay" class="equation-display"></div>
        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üßÆ Calculs</h3>
        </div>
        <div class="section-content">
          <!-- Outils de Mesure -->
          <h4 class="sub-section-title" style="margin-top: 20px">Op√©rations sur les Vecteurs</h4>

          <!-- Somme de vecteurs -->
          <label>Somme de deux vecteurs \(\vec{u} + \vec{v}\) :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="sumVectorSelect1"></select>
            <select id="sumVectorSelect2"></select>
          </div>

          <label>Point de d√©part (pour la construction ou le vecteur libre) :</label>
          <select id="sumVectorOrigin" style="margin-bottom: 8px"></select>

          <!-- MODIFICATION: Boutons pour des actions distinctes -->
          <button class="btn-violet" onclick="calculateVectorSumFree()">üñ© Cr√©er le vecteur somme (libre)</button>
          <button class="btn-warning" onclick="constructChaslesSum()">üìê Construire la somme (Chasles)</button>

          <!-- NOUVEAU: Bouton pour nettoyer la construction, cach√© par d√©faut -->
          <button class="btn-danger" onclick="clearChaslesConstruction()" style="display: none; margin-top: 5px"
            id="clearChaslesBtn">
            üóëÔ∏è Effacer la construction
          </button>

          <div id="vectorSumResult" class="equation-display"></div>

          <!-- Produit Scalaire -->
          <label style="margin-top: 15px">Produit scalaire de deux vecteurs \( \vec{u} \cdot \vec{v} \) :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="dotVectorSelect1"></select>
            <select id="dotVectorSelect2"></select>
          </div>
          <button class="btn-warning" onclick="calculateScalarProduct()">üñ© Calculer</button>
          <div id="scalarProductResult" class="equation-display"></div>

          <!-- Produit Vectoriel -->
          <label style="margin-top: 15px">Produit vectoriel de deux vecteurs \( \vec{u} \wedge \vec{v} \) :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="crossVectorSelect1"></select>
            <select id="crossVectorSelect2"></select>
          </div>
          <label>Origine du vecteur produit :</label>
          <select id="crossVectorOrigin" style="margin-bottom: 8px"></select>
          <button class="btn-warning" onclick="calculateVectorProduct()">üñ© Cr√©er le vecteur produit</button>
          <div id="vectorProductResult" class="equation-display"></div>
        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üìê Mesures et Intersections</h3>
        </div>
        <div class="section-content">
          <!-- Outils de Mesure -->
          <h4 class="sub-section-title">Mesure de Distances</h4>

          <!-- Distance Point-Point -->
          <label>Distance entre deux points :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="distPointSelect1"></select>
            <select id="distPointSelect2"></select>
          </div>
          <button class="btn-warning" onclick="calculatePointPointDistance()">üñ© Mesurer</button>
          <div id="distResult1" class="equation-display"></div>

          <!-- Distance Point-Droite -->
          <label style="margin-top: 15px">Distance d'un point √† une droite :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="distPointSelect3"></select>
            <select id="distLineSelect1"></select>
          </div>
          <button class="btn-warning" onclick="calculatePointLineDistance()">üñ© Mesurer</button>
          <div id="distResult2" class="equation-display"></div>

          <!-- Distance Point-Plan -->
          <label style="margin-top: 15px">Distance d'un point √† un plan :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="calcPointSelect"></select>
            <select id="calcPlaneSelect1"></select>
          </div>
          <button class="btn-warning" onclick="calculatePointPlaneDistance()">üñ© Mesurer et projeter</button>
          <div id="calcResultDisplay1" class="equation-display" style="min-height: 50px"></div>

          <!-- Outils d'Angle -->
          <h4 class="sub-section-title" style="margin-top: 20px">Mesure d'Angles</h4>

          <!-- Angle Droite-Droite -->
          <label>Angle entre deux droites :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="angleLineSelect1"></select>
            <select id="angleLineSelect2"></select>
          </div>
          <button class="btn-warning" onclick="calculateLineLineAngle()">üñ© Mesurer</button>
          <div id="angleResult1" class="equation-display"></div>

          <!-- Angle Plan-Plan -->
          <label style="margin-top: 15px">Angle entre deux plans :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="anglePlaneSelect1"></select>
            <select id="anglePlaneSelect2"></select>
          </div>
          <button class="btn-warning" onclick="calculatePlanePlaneAngle()">üñ© Mesurer</button>
          <div id="angleResult2" class="equation-display"></div>

          <!-- Angle Droite-Plan -->
          <label style="margin-top: 15px">Angle entre une droite et un plan :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="angleLineSelect3"></select>
            <select id="anglePlaneSelect3"></select>
          </div>
          <button class="btn-warning" onclick="calculateLinePlaneAngle()">üñ© Mesurer</button>
          <div id="angleResult3" class="equation-display"></div>

          <!-- Intersections -->
          <h4 class="sub-section-title" style="margin-top: 20px">Calcul d'Intersections</h4>

          <!-- Intersection Droite-Plan -->
          <label>Intersection d'une droite et d'un plan :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="calcLineSelect"></select>
            <select id="calcPlaneSelect2"></select>
          </div>
          <button class="btn-warning" onclick="calculateLinePlaneIntersection()">üñ© Calculer l'intersection</button>
          <div id="calcResultDisplay2" class="equation-display"></div>

          <!-- Intersection Plan-Plan -->
          <label style="margin-top: 15px">Intersection de deux plans :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="calcPlaneSelect3"></select>
            <select id="calcPlaneSelect4"></select>
          </div>
          <button class="btn-warning" onclick="calculatePlanePlaneIntersection()">üñ© Calculer l'intersection</button>
          <div id="calcResultDisplay3" class="equation-display" style="min-height: 60px"></div>

          <!-- Intersection Droite-Droite -->
          <h4 class="sub-section-title" style="margin-top: 20px">Intersection de deux droites :</h4>
          <label>S√©lectionner les deux droites :</label>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="calcLineSelect1"></select>
            <select id="calcLineSelect2"></select>
          </div>
          <button class="btn-warning" onclick="calculateLineLineIntersection()">üñ© Analyser l'intersection</button>
          <div id="calcResultDisplay4" class="equation-display" style="margin-top: 10px; min-height: 50px"></div>

          <h4 class="sub-section-title" style="margin-top: 20px">Perpendiculaire commune (Droites)</h4>
          <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
            <select id="perpLine1"></select>
            <select id="perpLine2"></select>
          </div>
          <button class="btn-warning" onclick="calculateCommonPerpendicular()">üñ© Tracer la perpendiculaire</button>
          <div id="perpResult" class="equation-display"></div>

        </div>
      </div>

      <div class="section collapsible collapsed">
        <div class="section-header">
          <h3 style="font-size: 16px">üîÑ Transformations</h3>
        </div>
        <div class="section-content">
          <p id="transformations-hint" style="font-size: 12px; color: #888; text-align: center">
            Veuillez s√©lectionner un objet dans la sc√®ne 3D pour appliquer une transformation.
          </p>

          <!-- Sous-section Translation -->
          <div id="transformations-container" style="display: none">
            <h4 class="sub-section-title">Translation</h4>
            <label>Vecteur de translation (dX, dY, dZ) :</label>
            <div class="coord-inputs">
              <input type="number" id="transX" placeholder="dX" value="0" step="1" />
              <input type="number" id="transY" placeholder="dY" value="0" step="1" />
              <input type="number" id="transZ" placeholder="dZ" value="0" step="1" />
            </div>
            <button class="btn-secondary" onclick="applyTranslation()">‚û°Ô∏è Appliquer la Translation</button>

            <!-- Sous-section Rotation -->
            <h4 class="sub-section-title" style="margin-top: 20px">Rotation</h4>
            <label>Centre de rotation :</label>
            <select id="rotationCenterSelect">
              <option value="origin">Origine du rep√®re (0,0,0)</option>
              <!-- Les points seront ajout√©s dynamiquement ici -->
            </select>
            <label style="margin-top: 10px">Axe de rotation :</label>
            <select id="rotationAxisSelect">
              <option value="x">Axe X</option>
              <option value="y">Axe Y</option>
              <option value="z">Axe Z</option>
            </select>
            <label style="margin-top: 10px">Angle de rotation (en degr√©s) :</label>
            <input type="number" id="rotationAngle" value="90" step="1" />
            <button class="btn-secondary" onclick="applyRotation()">üîÑ Appliquer la Rotation</button>

            <!-- Sous-section Sym√©trie -->
            <h4 class="sub-section-title" style="margin-top: 20px">Sym√©trie</h4>
            <label>Sym√©trie par rapport √† :</label>

            <select id="symmetryTypeSelect" onchange="updateSymmetryUI()">
              <option value="origin">Origine (0,0,0)</option>

              <option value="axis_x">Axe X</option>
              <option value="axis_y">Axe Y (Profondeur)</option>
              <option value="axis_z">Axe Z (Hauteur)</option>

              <option value="plane_xy">Plan XY (Sol)</option>
              <option value="plane_xz">Plan XZ (Face)</option>
              <option value="plane_yz">Plan YZ (C√¥t√©)</option>
              <option value="">-- Choisir un type --</option>
              <option value="point">Un Point</option>
              <option value="line">Une Droite</option>
              <option value="plane">Un Plan</option>
            </select>
            <div id="symmetryOptionsContainer" style="margin-top: 10px">
              <!-- Les options (s√©lecteurs de point, droite, plan) appara√Ætront ici -->
            </div>
            <button class="btn-secondary" id="applySymmetryBtn" style="display: none" onclick="applySymmetry()">
              üîπ Appliquer la Sym√©trie
            </button>
          </div>
        </div>
      </div>
      <div style="text-align: center; font-size: 10px; color: #888; margin-top: 20px; padding-top: 5px">
        Copyright Michel ESPARSA 15/11/2025
      </div>

      <!-- START: HTML pour le menu contextuel -->
      <div id="contextMenu" class="context-menu" style="display: none">
        <ul id="contextMenuItems" class="context-menu-items">
          <!-- Les options du menu seront inject√©es ici par JavaScript -->
        </ul>
      </div>
      <!-- END: HTML pour le menu contextuel -->
    </div>
    <script>
      // =====================================================================================
      // SECTION 1 : CLASSES DES OBJETS G√âOM√âTRIQUES
      // =====================================================================================

      /**
       * Classe repr√©sentant un point 3D.
       */
      class Point {
        constructor(name, x, y, z, color = 0xff6b35, derivedFrom = null) {
          this.name = name;
          this.position = new THREE.Vector3(x, y, z);
          this.color = new THREE.Color(color);
          this.derivedFrom = derivedFrom;
          const sphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
          const sphereMaterial = new THREE.MeshPhongMaterial({
            color: this.color,
          });
          this.mesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
          this.mesh.position.copy(this.position);
          this.mesh.userData = { type: "point", instance: this };
          this.label = createGenericTextLabel(name);
          this.updateLabelPosition();
        }
        // Dans la classe Point
        createTextLabel(text) {
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          canvas.width = 512;
          canvas.height = 256;

          // Vider le canvas pour un fond transparent
          context.clearRect(0, 0, canvas.width, canvas.height);

          context.font = "Bold 96px Arial";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.strokeStyle = "white";
          context.lineWidth = 12;
          context.strokeText(text, canvas.width / 2, canvas.height / 2);
          context.fillStyle = "black";
          context.fillText(text, canvas.width / 2, canvas.height / 2);

          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;

          // La correction est ici
          const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false, // Garantit que le label est toujours visible
          });

          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.scale.set(2, 1, 1);
          sprite.center.set(0.5, 0);
          return sprite;
        }

        updateLabelPosition() {
          this.label.position.set(this.position.x, this.position.y + 0.35, this.position.z);
        }
        update(name, x, y, z) {
          this.name = name;
          this.position.set(x, y, z);
          this.mesh.position.copy(this.position);
          scene.remove(this.label);
          this.label = createGenericTextLabel(name);
          this.updateLabelPosition();
          scene.add(this.label);
        }
        addToScene(scene) {
          // On s'assure que les points ont un renderOrder plus √©lev√© que les axes
          this.mesh.renderOrder = 10;
          this.label.renderOrder = 11; // Les labels doivent √™tre au-dessus des points

          scene.add(this.mesh);
          scene.add(this.label);
        }
        removeFromScene(scene) {
          scene.remove(this.mesh);
          scene.remove(this.label);
          if (this.mesh.geometry) this.mesh.geometry.dispose();
          if (this.mesh.material) this.mesh.material.dispose();
          if (this.label.material) {
            if (this.label.material.map) this.label.material.map.dispose(); // Texture du texte
            this.label.material.dispose();
          }
        }
      }

      /**
       * Classe repr√©sentant une droite 3D.
       */
      class Line3D {
        constructor(name, startPoint, directorVector, color = 0x00ced1, derivedFrom = null) {
          this.id = nextStraightLineId++;
          this.name = name;
          this.startPoint = startPoint.clone();
          this.directorVector = directorVector.clone();
          this.color = new THREE.Color(color);
          this.derivedFrom = derivedFrom;
          this.isVisible = true;
          const lineLength = 100;
          const dir = this.directorVector.clone().normalize();
          const visualStart = new THREE.Vector3().addVectors(this.startPoint, dir.clone().multiplyScalar(-lineLength));
          const visualEnd = new THREE.Vector3().addVectors(this.startPoint, dir.clone().multiplyScalar(lineLength));
          const geometry = new THREE.BufferGeometry().setFromPoints([visualStart, visualEnd]);
          const material = new THREE.LineBasicMaterial({ color: this.color });
          this.mesh = new THREE.Line(geometry, material);
          this.mesh.userData = { type: "line", instance: this };
        }

        // --- NOUVELLE M√âTHODE √Ä AJOUTER ---
        setVisibility(visible) {
          this.isVisible = visible;
          this.mesh.visible = visible;
        }
        // --- FIN DE L'AJOUT ---

        addToScene(scene) {
          scene.add(this.mesh);
        }
        removeFromScene(scene) {
          scene.remove(this.mesh);
          if (this.mesh.geometry) this.mesh.geometry.dispose();
          if (this.mesh.material) this.mesh.material.dispose();
        }
      }
      /**
       * Classe repr√©sentant un plan 3D.
       */
      class Plane {
        constructor(
          name,
          pointOnPlane,
          normal, // C'est le vecteur AVANT normalisation
          color = 0xffeb3b,
          derivedFrom = null
        ) {
          this.id = nextPlaneId++;
          this.name = name;
          this.pointOnPlane = pointOnPlane.clone();

          // --- MODIFICATION ---
          // On stocke le vecteur original pour l'affichage des √©quations
          this.displayNormal = normal.clone();
          // On utilise le vecteur normalis√© pour le rendu 3D
          this.normal = normal.clone().normalize();
          // --- FIN DE LA MODIFICATION ---

          this.color = new THREE.Color(color);
          this.derivedFrom = derivedFrom;
          this.isVisible = true;
          const planeGeometry = new THREE.PlaneGeometry(15, 15);
          const planeMaterial = new THREE.MeshPhongMaterial({
            color: this.color,
            transparent: true,
            opacity: 0.4, // Opacit√© r√©duite pour une meilleure visibilit√© des axes
            side: THREE.DoubleSide,
            depthWrite: false, // Important pour la visibilit√© des axes
            polygonOffset: true, // √âvite les probl√®mes de z-fighting
            polygonOffsetFactor: 1, // Ajuste la profondeur du plan
            polygonOffsetUnits: 1,
          });
          this.mesh = new THREE.Mesh(planeGeometry, planeMaterial);
          this.mesh.position.copy(this.pointOnPlane);
          // La normalisation est importante pour la ligne suivante
          this.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), this.normal);
          this.mesh.userData = { type: "plane", instance: this };
        }
        // ... le reste de la classe (setVisibility, addToScene, etc.) ne change pas
        setVisibility(visible) {
          this.isVisible = visible;
          this.mesh.visible = visible;
        }
        addToScene(scene) {
          scene.add(this.mesh);
        }
        removeFromScene(scene) {
          scene.remove(this.mesh);
          if (this.mesh.geometry) this.mesh.geometry.dispose();
          if (this.mesh.material) this.mesh.material.dispose();
        }
      }
      /**
       * Classe repr√©sentant un vecteur 3D.
       */

      class Vector {
        constructor(name, origin, components, color = 0xffa500, derivedFrom = null) {
          this.id = nextVectorId++;
          this.name = name;
          this.origin = origin.clone();
          this.components = components.clone();
          this.color = new THREE.Color(color);
          this.derivedFrom = derivedFrom;
          this.isVisible = true;
          this.arrowHelper = null;

          // --- AJOUTS POUR L'√âTIQUETTE ---
          this.isLabelVisible = true; // Par d√©faut, l'√©tiquette est visible
          this.label = createGenericTextLabel(name);
          this.updateLabelPosition();
          // --- FIN DES AJOUTS ---

          this.createArrowHelper();
        }

        // --- NOUVELLE M√âTHODE (copi√©e de la classe Point) ---
        createTextLabel(text) {
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          canvas.width = 512;
          canvas.height = 256;

          context.clearRect(0, 0, canvas.width, canvas.height);

          context.font = "Bold 96px Arial";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.strokeStyle = "white";
          context.lineWidth = 12;
          context.strokeText(text, canvas.width / 2, canvas.height / 2);
          context.fillStyle = "black";
          context.fillText(text, canvas.width / 2, canvas.height / 2);

          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;

          const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false,
          });

          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.scale.set(2, 1, 1);
          sprite.center.set(0.5, 0);
          return sprite;
        }

        // --- NOUVELLE M√âTHODE ---
        updateLabelPosition() {
          if (!this.label) return;
          // Positionne l'√©tiquette au milieu du vecteur
          const midPoint = new THREE.Vector3().addVectors(this.origin, this.components.clone().multiplyScalar(0.5));
          this.label.position.copy(midPoint);
          // On peut ajouter un petit d√©calage pour √©viter que ce soit directement sur la fl√®che
          this.label.position.y += 0.2;
        }

        // --- NOUVELLE M√âTHODE ---
        setLabelVisibility(visible) {
          this.isLabelVisible = visible;
          if (this.label) {
            this.label.visible = visible;
          }
        }

        createArrowHelper() {
          if (this.arrowHelper) this.removeFromScene(scene);
          const length = this.components.length();
          if (length > 1e-6) {
            this.arrowHelper = new THREE.ArrowHelper(
              this.components.clone().normalize(),
              this.origin,
              length,
              this.color,
              0.4,
              0.2
            );
            this.arrowHelper.line.userData = { type: "vector", instance: this };
            this.arrowHelper.cone.userData = { type: "vector", instance: this };
          } else {
            this.arrowHelper = null;
          }
        }

        update(name, origin, components) {
          this.name = name;
          this.origin.copy(origin);
          this.components.copy(components);

          // --- MISE √Ä JOUR DE L'√âTIQUETTE ---
          if (this.label) scene.remove(this.label);
          this.label = createGenericTextLabel(name);
          this.updateLabelPosition();
          if (this.isVisible) scene.add(this.label);
          this.setLabelVisibility(this.isLabelVisible); // Applique la visibilit√© actuelle
          // --- FIN DE LA MISE √Ä JOUR ---

          this.createArrowHelper();
          this.addToScene(scene);
          this.setVisibility(this.isVisible);
        }

        setVisibility(visible) {
          this.isVisible = visible;
          if (this.arrowHelper) this.arrowHelper.visible = visible;
          // --- AJOUT ---
          // La visibilit√© globale du vecteur affecte aussi son √©tiquette
          if (this.label) this.label.visible = visible && this.isLabelVisible;
        }

        addToScene(scene) {
          if (this.arrowHelper) scene.add(this.arrowHelper);
          // --- AJOUT ---
          if (this.label) {
            this.label.renderOrder = 11; // Pour √™tre au-dessus des autres objets
            scene.add(this.label);
          }
        }

        removeFromScene(scene) {
          if (this.arrowHelper) scene.remove(this.arrowHelper);
          // --- AJOUT ---
          if (this.label) scene.remove(this.label);
        }
      }
      // =====================================================================================
      // SECTION 2 : GESTIONNAIRE CENTRAL DE LA G√âOM√âTRIE
      // =====================================================================================

      class GeometryManager {
        constructor(scene) {
          this.scene = scene;
          this.points = [];
          this.lines = [];
          this.planes = [];
          this.vectors = [];
        }
        /**
         * G√©n√®re un nom unique pour un type d'objet donn√© en ajoutant un suffixe si n√©cessaire.
         * @param {string} baseName Le nom de base souhait√©.
         * @param {string} objectType Le type d'objet : 'point', 'line', 'plane', ou 'vector'.
         * @returns {string} Un nom garanti unique.
         */
        generateUniqueName(baseName, objectType) {
          let nameList;
          // 1. S√©lectionner la bonne liste d'objets en fonction du type
          switch (objectType) {
            case "point":
              nameList = this.points.map((p) => p.name);
              break;
            case "line":
              nameList = this.lines.map((l) => l.name);
              break;
            case "plane":
              nameList = this.planes.map((p) => p.name);
              break;
            case "vector":
              nameList = this.vectors.map((v) => v.name);
              break;
            default:
              // Si le type est inconnu, on ne peut pas v√©rifier, on retourne le nom de base
              return baseName;
          }

          // 2. V√©rifier si le nom de base est d√©j√† pris
          if (!nameList.includes(baseName)) {
            return baseName; // Le nom est d√©j√† unique, on le retourne
          }

          // 3. Si le nom est pris, on cherche un suffixe
          let uniqueName = baseName;
          let counter = 1;
          do {
            uniqueName = `${baseName}_${counter}`;
            counter++;
          } while (nameList.includes(uniqueName));

          return uniqueName;
        }

        addPoint(point) {
          this.points.push(point);
          point.addToScene(this.scene);
        }
        addLine(line) {
          this.lines.push(line);
          line.addToScene(this.scene);
        }
        addPlane(plane) {
          this.planes.push(plane);
          plane.addToScene(this.scene);
        }
        addVector(vector) {
          this.vectors.push(vector);
          vector.addToScene(this.scene);
        }
        _removeInstance(array, instance) {
          const index = array.indexOf(instance);
          if (index > -1) {
            instance.removeFromScene(this.scene);
            array.splice(index, 1);
            return true;
          }
          return false;
        }
        removePoint(instance) {
          return this._removeInstance(this.points, instance);
        }
        removeLine(instance) {
          return this._removeInstance(this.lines, instance);
        }
        removePlane(instance) {
          return this._removeInstance(this.planes, instance);
        }
        removeVector(instance) {
          return this._removeInstance(this.vectors, instance);
        }
        findLineById(id) {
          return this.lines.find((l) => l.id === id);
        }
        findPlaneById(id) {
          return this.planes.find((p) => p.id === id);
        }
        findVectorById(id) {
          return this.vectors.find((v) => v.id === id);
        }

        findPointAt(position) {
          const tolerance = 0.01;
          for (const point of this.points) {
            if (point.position.distanceTo(position) < tolerance) {
              return point;
            }
          }
          return null;
        }
        findObjectByName(name) {
          const allObjects = [...this.points, ...this.lines, ...this.planes];
          return allObjects.find((obj) => obj.name === name);
        }

        clearAll() {
          [...this.points, ...this.lines, ...this.planes, ...this.vectors].forEach((obj) =>
            obj.removeFromScene(this.scene)
          );
          this.points = [];
          this.lines = [];
          this.planes = [];
          this.vectors = [];
          nextStraightLineId = 0;
          nextPlaneId = 0;
          nextVectorId = 0;
        }
      }

      // =====================================================================================
      // SECTION 3 : VARIABLES GLOBALES ET INITIALISATION
      // =====================================================================================

      let scene, camera, renderer, geometryManager;
      let isDragging = false,
        isPanning = false,
        wasDragged = false;
      let previousMousePosition = { x: 0, y: 0 };
      let cameraRotation = { x: 0.5, y: 0.5 };
      let cameraDistance = 15;
      let cameraTarget = new THREE.Vector3(0, 0, 0);
      let initialPinchDistance = 0;
      let panelOpen = false;
      let nextStraightLineId = 0;
      let nextPlaneId = 0;
      let nextVectorId = 0;
      let raycaster,
        mouse,
        selectedObjectInstance = null;
      // let wasPanningOrZooming = false; // Pour distinguer un geste cam√©ra d'un tap
      let currentConstructionObjects = [];
      let splashTimer = null;
      let blockNextClick = false; // Variable pour bloquer le "clic fant√¥me" sur mobile
      const HIGHLIGHT_COLOR = 0xffcc00; // Jaune vif pour la surbrillance
      let longPressTimer = null;
      const LONG_PRESS_DURATION = 500;
      let touchStartPosition = { x: 0, y: 0 };
      let transformControl;
      let isGizmoDragging = false;
      let lastTooltipX = 0;
      let lastTooltipY = 0;
      const swipeState = {
        isSwiping: false, // VRAI si un geste de balayage du panneau est en cours
        lock: null, // deviendra 'horizontal' ou 'vertical'
        startX: 0,
        startY: 0,
        panelStartTranslateX: 0,
      };
      const SWIPE_EDGE_ZONE = 40; // Zone de d√©tection sur le bord gauche

      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        return b === 0 ? a : gcd(b, a % b);
      }

      function gcdOfThree(a, b, c) {
        return gcd(gcd(a, b), c);
      }

      function init() {
        // 1. Initialisation de base (Sc√®ne, Cam√©ra, Rendu)
        scene = new THREE.Scene();
        geometryManager = new GeometryManager(scene);
        scene.background = new THREE.Color(0xf0f0f0);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("container").appendChild(renderer.domElement);

        // 2. Lumi√®res
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 15, 10);
        scene.add(directionalLight);

        // 3. Aides visuelles (Axes et Grille)
        // createAxes();
        // const gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xe0e0e0);
        // On place le quadrillage en arri√®re-plan
        // gridHelper.renderOrder = -1;
        // gridHelper.material.depthTest = false;
        // scene.add(gridHelper);
        initTheme(); // Cela va cr√©er la grille, les axes et d√©finir la couleur de fond
        // ============================================================
        // 4. CORRECTION GIZMO (TransformControls)
        // ============================================================
        transformControl = new THREE.TransformControls(camera, renderer.domElement);

        // A. √âcouteur : Quand on commence ou finit de bouger le Gizmo
        transformControl.addEventListener('dragging-changed', function (event) {
          isGizmoDragging = event.value;

          if (isGizmoDragging) {
            // D√âBUT du d√©placement
            isDragging = false;
            isPanning = false;
          } else {
            // FIN du d√©placement (rel√¢chement de la souris)

            // --- AJOUT STEP 3 : On valide math√©matiquement le mouvement ---
            finalizeGizmoMovement();
            // -------------------------------------------------------------

            // NOTE : finalizeGizmoMovement appelle d√©j√† updateAllUI() et saveState()
            // donc pas besoin de le refaire ici.

            blockNextClick = true;
            setTimeout(() => {
              blockNextClick = false;
            }, 100);
          }
        });


        // B. √âcouteur : Pendant que l'objet bouge (Mise √† jour temps r√©el)
        transformControl.addEventListener('change', function () {
          // On ne fait rien si aucun objet n'est s√©lectionn√©
          if (!selectedObjectInstance) return;

          // Cette fonction met √† jour les coordonn√©es JS et les inputs du formulaire
          syncDataFromGizmo();
          //Met √† jour l'info-bulle en temps r√©el
          updateTooltipFromGizmo();
        });

        scene.add(transformControl);
        // ============================================================


        // 5. Reste de l'initialisation
        setupEventListeners();
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Gestion de la case √† cocher "Chargement auto"
        const autoLoadCheckbox = document.getElementById("autoLoadTestPointsCheckbox");
        if (localStorage.getItem("autoLoadTestPoints") === "true") {
          autoLoadCheckbox.checked = true;
          addFixedTestPoints();
        }

        // Valeurs par d√©faut pour les √©quations
        document.getElementById("lineEquationInput").value = "x = 1 + 2t\ny = -3 + 3t\nz = 4 - 5t";
        document.getElementById("planeEquationInput").value = "2x - y + 3z - 4 = 0";

        document.getElementById("vectorOriginPoint").addEventListener("change", function () {
          const selectedValue = this.value;

          // 1. Si on choisit l'Origine (0,0,0)
          if (selectedValue === "origin") {
            document.getElementById("vectorOriginX").value = "0";
            document.getElementById("vectorOriginY").value = "0";
            document.getElementById("vectorOriginZ").value = "0";
          }
          // 2. Si on choisit un Point existant (A, B, C...)
          else if (selectedValue !== "") {
            const pointIndex = parseInt(selectedValue);
            const p = geometryManager.points[pointIndex];

            if (p) {
              // Remplissage automatique des champs (Attention √† l'inversion Y/Z pour l'UI)
              document.getElementById("vectorOriginX").value = formatNumber(p.position.x);
              document.getElementById("vectorOriginY").value = formatNumber(p.position.z); // Profondeur (UI Y)
              document.getElementById("vectorOriginZ").value = formatNumber(p.position.y); // Hauteur (UI Z)
            }
          }
        });
        // Lancement
        updateCameraPosition();
        animate();
        updateAllUI();
        saveState();
        document.getElementById("lineEqPointX").value = "";
        document.getElementById("lineEqPointY").value = "";
        document.getElementById("lineEqPointZ").value = "";
        document.getElementById("lineEquationPointSelect").value = "";
      }

      function formatNumber(value, decimalPlaces = 2) {
        if (typeof value !== "number" || isNaN(value)) {
          return value; // Retourne la valeur telle quelle si ce n'est pas un nombre
        }
        // V√©rifie si la valeur est "proche" d'un entier
        if (Math.abs(value - Math.round(value)) < 1e-6) {
          return Math.round(value).toString();
        }
        return value.toFixed(decimalPlaces);
      }

      function createGenericTextLabel(text) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = 512;
        canvas.height = 256;

        context.clearRect(0, 0, canvas.width, canvas.height);

        context.font = "Bold 96px Arial";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.lineWidth = 12;

        if (isDarkMode) {
          // Mode Sombre : Texte Blanc avec contour Noir (pour contraste sur fond sombre)
          context.strokeStyle = "black";
          context.strokeText(text, canvas.width / 2, canvas.height / 2);
          context.fillStyle = "white";
          context.fillText(text, canvas.width / 2, canvas.height / 2);
        } else {
          // Mode Clair : Texte Noir avec contour Blanc (standard)
          context.strokeStyle = "white";
          context.strokeText(text, canvas.width / 2, canvas.height / 2);
          context.fillStyle = "black";
          context.fillText(text, canvas.width / 2, canvas.height / 2);
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;

        const spriteMaterial = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          depthTest: false,
        });

        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(2, 1, 1);
        sprite.center.set(0.5, 0);
        return sprite;
      }

      function setupEventListeners() {
        const canvas = renderer.domElement;
        const panel = document.getElementById("panel");

        canvas.addEventListener("contextmenu", onRightClick);
        canvas.addEventListener("click", onObjectClick);
        canvas.addEventListener("mousedown", onMouseDown);
        canvas.addEventListener("mousemove", onMouseMove);
        canvas.addEventListener("mouseup", onMouseUp);
        canvas.addEventListener("wheel", onWheel);

        document.addEventListener("touchstart", handleTouchStart, { passive: false });
        document.addEventListener("touchmove", handleTouchMove, { passive: false });
        document.addEventListener("touchend", handleTouchEnd);

        window.addEventListener("resize", onWindowResize);


        window.addEventListener("keydown", (event) => {
          // 1. Raccourcis existants (T, R, Echap, Ctrl+Z)
          if (event.key.toLowerCase() === 't') transformControl.setMode('translate');
          if (event.key.toLowerCase() === 'r') transformControl.setMode('rotate');

          if (event.key === "Escape") {
            hideContextMenu();
            if (panelOpen) togglePanel();
            if (selectedObjectInstance) {
              deselectCurrentObject();
              cancelEdit();
              cancelVectorEdit();
            }
          }

          if ((event.ctrlKey || event.metaKey) && event.key === 'z') {
            event.preventDefault();
            undo();
          }
          if ((event.ctrlKey || event.metaKey) && event.key === 'y') {
            event.preventDefault();
            redo();
          }

          // 2. NOUVEAU : Gestion de la touche SUPPR (Delete)
          // --- DANS setupEventListeners, partie window.addEventListener("keydown"...) ---

          // Remplacez le bloc "if (event.key === "Delete" || event.key === "Del")" par ceci :

          if (event.key === "Delete" || event.key === "Del") {
            // AJOUT DE LA S√âCURIT√â ICI :
            const tag = document.activeElement.tagName.toUpperCase();
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') {
              return; // On ne fait rien si l'utilisateur √©crit
            }

            // Le reste reste identique :
            if (selectedObjectInstance) {
              const inst = selectedObjectInstance;
              if (inst instanceof Point) {
                const index = geometryManager.points.indexOf(inst);
                if (index > -1) removePoint(index);
              } else if (inst instanceof Vector) {
                removeVectorById(inst.id);
              } else if (inst instanceof Line3D) {
                removeStraightLineById(inst.id);
              } else if (inst instanceof Plane) {
                removePlaneById(inst.id);
              }
            }
          }

        });

        document.addEventListener("mousedown", (e) => {
          const menu = document.getElementById("contextMenu");
          if (menu.style.display === "block" && !menu.contains(e.target)) {
            hideContextMenu();
          }
        });

        document.getElementById("contextMenu").addEventListener("mousedown", (e) => e.stopPropagation());

        const stopPropagation = (e) => e.stopPropagation();
        panel.addEventListener("mousedown", stopPropagation);
        panel.addEventListener("wheel", stopPropagation);
        panel.addEventListener("contextmenu", stopPropagation);
      }

      function onRightClick(event) {
        event.preventDefault();
        console.log("üëâ 1. Clic droit d√©tect√© √† :", event.clientX, event.clientY);
        findObjectAndShowMenu(event.clientX, event.clientY);
      }

      function onObjectClick(event) {
        if (blockNextClick) {
          blockNextClick = false;
          return;
        }
        if (wasDragged) return;
        performRaycastSelection(event.clientX, event.clientY);
      }

      function handleTouchStart(e) {
        wasDragged = false;
        // On nettoie d'anciens timers
        clearTimeout(longPressTimer);
        longPressTimer = null;

        const touch = e.touches[0];

        // ============================================================
        // 1. PROTECTION UI (Boutons fixes & Panneau) - PRIORIT√â ABSOLUE
        // ============================================================

        // A. Boutons (Menu Burger, Cam√©ra)
        if (e.target.closest("#openBtn") || e.target.closest("#cameraControls")) {
          return;
        }

        // B. LOGIQUE SWIPE (Panneau Lat√©ral)
        // On v√©rifie ICI si l'utilisateur interagit avec le panneau AVANT de v√©rifier la 3D
        const canStartOpening = !panelOpen && touch.clientX < SWIPE_EDGE_ZONE;
        // Si le panneau est ouvert, tout contact avec lui est prioritaire
        const canStartClosing = panelOpen && e.target.closest("#panel");

        if (canStartOpening || canStartClosing) {
          swipeState.isSwiping = true;
          swipeState.lock = null;
          swipeState.startX = touch.clientX;
          swipeState.startY = touch.clientY;
          const panel = document.getElementById("panel");
          const panelRect = panel.getBoundingClientRect();
          swipeState.panelStartTranslateX = panel.classList.contains("hidden") ? -panelRect.width : 0;

          // C'est ici que la correction op√®re :
          // On retourne imm√©diatement. Le code ne lira jamais la partie Gizmo ci-dessous.
          return;
        }

        swipeState.isSwiping = false;

        // ============================================================
        // 2. PROTECTION GIZMO (TransformControls)
        // ============================================================
        // Maintenant, on est s√ªr que l'utilisateur ne touche pas l'interface 2D.
        // On peut v√©rifier s'il touche le Gizmo 3D.
        if (typeof transformControl !== 'undefined' && transformControl && selectedObjectInstance) {
          mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
          raycaster.setFromCamera(mouse, camera);

          // On v√©rifie si on touche le Gizmo
          const gizmoIntersects = raycaster.intersectObjects(transformControl.children, true);
          if (gizmoIntersects.length > 0) {
            return; // On laisse Three.js g√©rer le d√©placement de l'objet
          }
        }

        // ============================================================
        // 3. INITIALISATION MOUVEMENTS CAM√âRA
        // ============================================================

        // --- CAS A : 1 DOIGT (Rotation) ---
        if (e.touches.length === 1) {
          isDragging = true;
          isPanning = false;
          previousMousePosition = { x: touch.clientX, y: touch.clientY };
          touchStartPosition = { x: touch.clientX, y: touch.clientY };
        }

        // --- CAS B : 2 DOIGTS (Zoom + Panoramique) ---
        else if (e.touches.length >= 2) {
          isPanning = true;
          isDragging = false;
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
          previousMousePosition = {
            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
            y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
          };
        }
      }

      function handleTouchMove(e) {
        // 1. S√©curit√©s (Gizmo, Swipe...)
        if (typeof isGizmoDragging !== 'undefined' && isGizmoDragging) return;
        if (swipeState.isSwiping) {
          const touch = e.touches[0];
          const deltaX = touch.clientX - swipeState.startX;
          const deltaY = touch.clientY - swipeState.startY;
          if (!swipeState.lock) {
            swipeState.lock = Math.abs(deltaX) > Math.abs(deltaY) ? "horizontal" : "vertical";
          }
          if (swipeState.lock === "horizontal") {
            e.preventDefault();
            const panel = document.getElementById("panel");
            panel.classList.add("no-transition");
            let newX = swipeState.panelStartTranslateX + deltaX;
            newX = Math.max(-panel.offsetWidth, Math.min(0, newX));
            panel.style.transform = `translateX(${newX}px)`;
          }
          return;
        }

        // 2. Rotation (1 doigt)
        if (isDragging && e.touches.length === 1) {
          e.preventDefault();
          wasDragged = true;
          const touch = e.touches[0];
          const dX = touch.clientX - previousMousePosition.x;
          const dY = touch.clientY - previousMousePosition.y;

          cameraRotation.y += dX * 0.005;
          cameraRotation.x += dY * 0.005;
          cameraRotation.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraRotation.x));

          updateCameraPosition();
          previousMousePosition = { x: touch.clientX, y: touch.clientY };
        }

        // 3. Zoom et Panoramique (2 doigts)
        else if (isPanning && e.touches.length >= 2) {
          e.preventDefault();

          const touch1 = e.touches[0];
          const touch2 = e.touches[1];

          // --- A. Calcul du point milieu actuel (pour le Pan) ---
          const currentMidX = (touch1.clientX + touch2.clientX) / 2;
          const currentMidY = (touch1.clientY + touch2.clientY) / 2;

          // --- B. Calcul de la distance actuelle (pour le Zoom) ---
          const dx = touch1.clientX - touch2.clientX;
          const dy = touch1.clientY - touch2.clientY;
          const currentPinchDistance = Math.sqrt(dx * dx + dy * dy);

          // --- C. Application du PAN (D√©placement) ---
          // On compare le milieu actuel avec le milieu pr√©c√©dent
          const panDX = currentMidX - previousMousePosition.x;
          const panDY = currentMidY - previousMousePosition.y;

          // On applique le d√©placement si significatif
          if (Math.abs(panDX) > 0.5 || Math.abs(panDY) > 0.5) {
            panCamera(panDX, panDY);
          }

          // --- D. Application du ZOOM ---
          const diff = initialPinchDistance - currentPinchDistance;
          // Sensibilit√© du zoom
          if (Math.abs(diff) > 1) {
            zoomCamera(diff * 0.05); // Facteur 0.05 pour un zoom doux
            // On met √† jour la distance de r√©f√©rence pour √©viter l'acc√©l√©ration exponentielle
            initialPinchDistance = currentPinchDistance;
          }

          // --- E. Mise √† jour de la position de r√©f√©rence pour le prochain mouvement ---
          previousMousePosition = { x: currentMidX, y: currentMidY };
        }
      }

      function handleTouchEnd(e) {
        if (swipeState.isSwiping) {
          if (swipeState.lock === "horizontal") {
            const panel = document.getElementById("panel");
            panel.classList.remove("no-transition");
            panel.style.transform = "";
            const panelRect = panel.getBoundingClientRect();
            if (panelRect.left > -panel.offsetWidth / 2) {
              panelOpen = true;
              panel.classList.remove("hidden");
              document.getElementById("openBtn").classList.remove("show");
            } else {
              panelOpen = false;
              panel.classList.add("hidden");
              document.getElementById("openBtn").classList.add("show");
            }
          }
        } else {
          if (longPressTimer) {
            clearTimeout(longPressTimer);
            e.preventDefault();
            performRaycastSelection(touchStartPosition.x, touchStartPosition.y);
          }
        }
        swipeState.isSwiping = false;
        swipeState.lock = null;
        isDragging = false;
        isPanning = false;
        longPressTimer = null;
      }

      // Variable r√©utilis√©e pour √©viter l'allocation m√©moire √† chaque frame
      const raycastCandidates = [];

      function getIntersectionResult(x, y) {
        // 1. Transformation des coordonn√©es (inchang√©)
        mouse.x = (x / window.innerWidth) * 2 - 1;
        mouse.y = -(y / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        // 2. Optimisation : Remplissage du tableau sans cr√©er de sous-tableaux interm√©diaires
        raycastCandidates.length = 0; // Vider le tableau sans le d√©truire

        // A. Points
        const points = geometryManager.points;
        for (let i = 0; i < points.length; i++) {
          if (points[i].mesh.visible) raycastCandidates.push(points[i].mesh);
        }

        // B. Droites
        const lines = geometryManager.lines;
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].isVisible) raycastCandidates.push(lines[i].mesh);
        }

        // C. Plans
        const planes = geometryManager.planes;
        for (let i = 0; i < planes.length; i++) {
          if (planes[i].isVisible) raycastCandidates.push(planes[i].mesh);
        }

        // D. Vecteurs (Ligne et C√¥ne)
        const vectors = geometryManager.vectors;
        for (let i = 0; i < vectors.length; i++) {
          const v = vectors[i];
          if (v.isVisible && v.arrowHelper) {
            raycastCandidates.push(v.arrowHelper.line);
            raycastCandidates.push(v.arrowHelper.cone);
          }
        }

        // 3. Lancement du rayon sur la liste consolid√©e
        const intersects = raycaster.intersectObjects(raycastCandidates);

        return intersects.length > 0 ? intersects[0] : null;
      }

      function findObjectAndShowMenu(x, y) {
        // On v√©rifie que la fonction existe bien avant de l'appeler
        if (typeof hideContextMenu === "function") {
          hideContextMenu();
        } else {
          console.error("‚ùå Erreur : hideContextMenu n'est pas d√©finie !");
          return;
        }

        const intersection = getIntersectionResult(x, y);

        if (intersection) {
          console.log("‚úÖ 2. Objet touch√© !", intersection.object);

          if (intersection.object.userData && intersection.object.userData.instance) {
            console.log("‚úÖ 3. Instance trouv√©e, lancement du menu...");
            populateAndShowContextMenu(x, y, intersection.object.userData.instance);
          } else {
            console.warn("‚ö†Ô∏è Objet touch√© mais pas de donn√©es 'instance' (userData vide ?)");
          }
        } else {
          console.log("‚ùå 2. Aucun objet trouv√© sous la souris.");
        }
      }

      function populateAndShowContextMenu(x, y, instance) {
        console.log("üõ†Ô∏è Construction du menu pour :", instance.constructor.name);

        const menu = document.getElementById("contextMenu");
        const menuItemsContainer = document.getElementById("contextMenuItems");

        // 1. Vider le menu pr√©c√©dent
        menuItemsContainer.innerHTML = "";

        // Helper pour cr√©er les lignes (li)
        const createAction = (action, text) =>
          `<li onclick="${action}; hideContextMenu();" style="padding:8px 15px; cursor:pointer; border-bottom:1px solid #eee; color:#333;">${text}</li>`;

        let htmlContent = "";

        // 2. G√©n√©rer le contenu selon le type
        if (instance instanceof Point) {
          const index = geometryManager.points.indexOf(instance);
          htmlContent += createAction(`editPoint(${index})`, "‚úèÔ∏è Modifier le point");
          // --- AJOUT ---
          htmlContent += createAction(`openTransformationPanel('point', ${index})`, "üîÑ Transformations");
          // -------------
          htmlContent += createAction(`removePoint(${index})`, "üóëÔ∏è Supprimer le point");

        } else if (instance instanceof Vector) {
          htmlContent += createAction(`editVector(${instance.id})`, "‚úèÔ∏è Modifier le vecteur");
          // --- AJOUT ---
          htmlContent += createAction(`openTransformationPanel('vector', ${instance.id})`, "üîÑ Transformations");
          // -------------
          htmlContent += createAction(
            `toggleVectorVisibility(${instance.id})`,
            instance.isVisible ? "üôà Cacher" : "üëÅÔ∏è Afficher"
          );
          htmlContent += createAction(`removeVectorById(${instance.id})`, "üóëÔ∏è Supprimer");

        } else if (instance instanceof Line3D) {
          htmlContent += createAction(`editLine(${instance.id})`, "‚úèÔ∏è Modifier la droite");
          // --- AJOUT ---
          htmlContent += createAction(`openTransformationPanel('line', ${instance.id})`, "üîÑ Transformations");
          // -------------
          htmlContent += createAction(
            `toggleStraightLineVisibility(${instance.id})`,
            instance.isVisible ? "üôà Cacher" : "üëÅÔ∏è Afficher"
          );
          htmlContent += createAction(`removeStraightLineById(${instance.id})`, "üóëÔ∏è Supprimer");

        } else if (instance instanceof Plane) {
          htmlContent += createAction(`editPlane(${instance.id})`, "‚úèÔ∏è Modifier le plan");
          // --- AJOUT ---
          htmlContent += createAction(`openTransformationPanel('plane', ${instance.id})`, "üîÑ Transformations");
          // -------------
          htmlContent += createAction(
            `togglePlaneVisibility(${instance.id})`,
            instance.isVisible ? "üôà Cacher" : "üëÅÔ∏è Afficher"
          );
          htmlContent += createAction(`toggleNormalVector(${instance.id})`, "üìè Vecteur Normal (Vn)");
          htmlContent += createAction(`removePlaneById(${instance.id})`, "üóëÔ∏è Supprimer");
        }

        // 3. V√©rifier si du contenu a √©t√© g√©n√©r√©
        if (htmlContent === "") {
          console.warn("‚ö†Ô∏è Menu vide : type d'objet non reconnu", instance);
          return;
        }

        menuItemsContainer.innerHTML = htmlContent;

        // 4. Affichage et Positionnement
        menu.style.display = "block";

        const menuWidth = menu.offsetWidth || 160;
        const menuHeight = menu.offsetHeight || 100;

        let finalX = x;
        let finalY = y;

        if (x + menuWidth > window.innerWidth) {
          finalX = window.innerWidth - menuWidth - 10;
        }
        if (y + menuHeight > window.innerHeight) {
          finalY = window.innerHeight - menuHeight - 10;
        }

        menu.style.left = finalX + "px";
        menu.style.top = finalY + "px";
      }

      // =====================================================================================
      // END: GESTION DES √âV√âNEMENTS
      // =====================================================================================
      function createAxes() {
        // 1. Nettoyage si les axes existent d√©j√†
        if (axesGroup) {
          scene.remove(axesGroup);
          // Nettoyage m√©moire basique
          axesGroup.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
              if (child.material.map) child.material.map.dispose();
              child.material.dispose();
            }
          });
          axesGroup = null;
        }

        axesGroup = new THREE.Group(); // Cr√©er un conteneur global

        const axisLength = 10;
        const axisRadius = 0.04;
        const headLength = 0.4;
        const headRadius = 0.12;

        // --- Helper pour cr√©er le texte (Label) ---
        const createAxisLabel = (text, colorHex) => {
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          canvas.width = 256;
          canvas.height = 256;

          context.clearRect(0, 0, canvas.width, canvas.height);
          context.font = "bold 60px Arial"; // Un peu plus gras
          context.textAlign = "center";
          context.textBaseline = "middle";

          // LOGIQUE DE COULEUR DES AXES
          // En dark mode, on veut que le texte soit blanc ou de la couleur de l'axe mais plus clair
          // Ici on garde la couleur de l'axe, mais on ajoute un contour (stroke) pour la lisibilit√©

          context.lineWidth = 8;
          context.strokeStyle = isDarkMode ? "black" : "white"; // Contour selon le th√®me
          context.strokeText(text, canvas.width / 2, canvas.height / 2);

          context.fillStyle = "#" + new THREE.Color(colorHex).getHexString();
          context.fillText(text, canvas.width / 2, canvas.height / 2);

          const texture = new THREE.CanvasTexture(canvas);
          const material = new THREE.SpriteMaterial({
            map: texture,
            depthTest: false,
            transparent: true,
          });

          const sprite = new THREE.Sprite(material);
          sprite.scale.set(2.5, 2.5, 1);
          return sprite;
        };

        const createAxisArrow = (color, direction, labelText) => {
          // ... (garder le code existant de cr√©ation de fl√®che) ...
          // SAUF : au lieu de 'group.add(shaft)', faire 'localGroup.add(shaft)'
          // et retourner localGroup

          // POUR SIMPLIFIER : Copiez-collez votre logique existante mais ajoutez tout √† axesGroup

          const material = new THREE.MeshBasicMaterial({ color: color, depthTest: false });
          // ... g√©om√©trie cylindre + cone ...

          // Je r√©√©cris la version courte compatible avec votre code existant :
          const localGroup = new THREE.Group();

          const shaftGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 12);
          const shaft = new THREE.Mesh(shaftGeometry, material);
          shaft.position.copy(direction).multiplyScalar(axisLength / 2);
          shaft.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
          localGroup.add(shaft);

          const headGeometry = new THREE.ConeGeometry(headRadius, headLength, 12);
          const head = new THREE.Mesh(headGeometry, material);
          head.position.copy(direction).multiplyScalar(axisLength);
          head.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
          localGroup.add(head);

          const label = createAxisLabel(labelText, color);
          const labelPos = direction.clone().multiplyScalar(axisLength + 1.5);
          label.position.copy(labelPos);
          localGroup.add(label);

          return localGroup;
        };

        // Cr√©ation
        const xAxis = createAxisArrow(0xff0000, new THREE.Vector3(1, 0, 0), "X");
        const yAxis = createAxisArrow(0x00ff00, new THREE.Vector3(0, 1, 0), "Z");
        const zAxis = createAxisArrow(0x0000ff, new THREE.Vector3(0, 0, 1), "Y");

        axesGroup.add(xAxis);
        axesGroup.add(yAxis);
        axesGroup.add(zAxis);

        // Configuration rendu
        axesGroup.traverse((child) => {
          if (child.material) {
            child.material.depthTest = true;
            child.material.transparent = true;
            child.material.opacity = 1.0;
            child.renderOrder = 1;
          }
        });

        scene.add(axesGroup);
      }

      let lastCameraHash = ""; // Pour suivre les changements de cam√©ra

      function animate() {
        requestAnimationFrame(animate);

        // G√©n√©rer une signature simple de la position/rotation cam√©ra
        const currentCameraHash = `${camera.position.x.toFixed(3)},${camera.position.y.toFixed(3)},${camera.position.z.toFixed(3)},${camera.rotation.x.toFixed(3)},${camera.rotation.y.toFixed(3)}`;

        // Optimisation : On ne met √† jour les labels que si la cam√©ra a boug√©
        // OU si un gizmo est en cours d'utilisation (car les objets bougent)
        if (currentCameraHash !== lastCameraHash || isGizmoDragging) {
          const scaleFactor = 0.12;

          // Mise √† jour labels Points
          for (let i = 0, l = geometryManager.points.length; i < l; i++) {
            const p = geometryManager.points[i];
            if (p.label) {
              const dist = camera.position.distanceTo(p.label.position);
              const desiredScale = dist * scaleFactor;
              p.label.scale.set(desiredScale, desiredScale * 0.5, 1);
            }
          }

          // Mise √† jour labels Vecteurs
          for (let i = 0, l = geometryManager.vectors.length; i < l; i++) {
            const v = geometryManager.vectors[i];
            if (v.label && v.label.visible) { // V√©rif visibilit√© pour √©conomiser calculs
              const dist = camera.position.distanceTo(v.label.position);
              const desiredScale = dist * scaleFactor;
              v.label.scale.set(desiredScale, desiredScale * 0.5, 1);
            }
          }

          lastCameraHash = currentCameraHash;
        }

        renderer.render(scene, camera);
      }
      // =====================================================================================
      // SECTION 4 : MISE √Ä JOUR DE L'INTERFACE UTILISATEUR (UI)
      // =====================================================================================

      function updateAllUI() {
        updatePointList();
        updateStraightLineList();
        updatePlaneList();
        updateVectorList();
        updateSelects();
      }

      function updatePointList() {
        const list = document.getElementById("pointList");
        list.innerHTML = "";
        geometryManager.points.forEach((p, i) => {
          const item = document.createElement("div");
          item.className = "point-item";
          const coordsText = `(${formatNumber(p.position.x, 1)}, ${formatNumber(p.position.z, 1)}, ${formatNumber(
            p.position.y,
            1
          )})`;

          item.innerHTML = `
      <div class="geometry-item-main">
          <div class="geometry-info">
              <span class="point-name">${p.name}</span>
              <span class="geometry-coords">${coordsText}</span>
          </div>
          <div class="geometry-actions">
              <button class="btn-secondary" onclick="editPoint(${i})" title="Modifier">‚úèÔ∏è</button>
              <button class="btn-danger" onclick="removePoint(${i})" title="Supprimer">üóëÔ∏è</button>
          </div>
      </div>`;
          list.appendChild(item);
        });
      }

      function updateStraightLineList() {
        const list = document.getElementById("lineList");
        list.innerHTML =
          geometryManager.lines.length === 0 ? '<div class="point-item">Aucune droite trac√©e.</div>' : "";

        geometryManager.lines.forEach((line) => {
          const item = document.createElement("div");
          item.className = "geometry-item";
          item.id = `line-item-${line.id}`;

          // 1. Vecteur Directeur (Formatage UI: X, Z(Prof), Y(Haut))
          const v = line.directorVector;
          const vText = `u(${formatNumber(v.x, 1)}, ${formatNumber(v.z, 1)}, ${formatNumber(v.y, 1)})`;

          // 2. Point de Passage (Formatage UI: X, Z(Prof), Y(Haut))
          // C'est l'ajout principal de cette √©tape
          const p = line.startPoint;
          const pText = `(${formatNumber(p.x, 1)}, ${formatNumber(p.z, 1)}, ${formatNumber(p.y, 1)})`;

          // 3. Construction du HTML
          // J'ai ajout√© des ID sp√©cifiques (line-vector-ID et line-point-ID) pour faciliter
          // la mise √† jour temps r√©el √† l'√©tape 3.
          item.innerHTML = `
    <div class="geometry-item-main">
        <div class="geometry-info">
            <span class="geometry-name">${line.name}</span>
            <span class="geometry-details" id="line-vector-${line.id}">Vect: ${vText}</span>
        </div>
        <div class="geometry-actions">
            <!-- Bouton pour ouvrir le panel transformation -->
            <button class="btn-secondary" onclick="openTransformationPanel('line', ${line.id})" title="Transformations">üîÑ</button>

            <button class="btn-secondary" onclick="toggleStraightLineVisibility(${line.id})" title="${line.isVisible ? "Masquer" : "Afficher"
            }">${line.isVisible ? "üëÅÔ∏è" : "üôà"}</button>
            <button class="btn-danger" onclick="removeStraightLineById(${line.id})" title="Supprimer">üóëÔ∏è</button>
        </div>
    </div>
    <!-- NOUVEAU : Ligne secondaire pour afficher le point -->
    <div class="geometry-details-secondary">
        <span id="line-point-${line.id}" style="color: #666;">
            Passe par : <strong>${pText}</strong>
        </span>
    </div>`;

          list.appendChild(item);
        });
      }

      function updatePlaneList() {
        const list = document.getElementById("planeList");
        list.innerHTML = geometryManager.planes.length === 0 ? '<div class="point-item">Aucun plan cr√©√©.</div>' : "";

        geometryManager.planes.forEach((plane) => {
          const item = document.createElement("div");
          item.className = "geometry-item";
          item.id = `plane-item-${plane.id}`;

          // 1. Pr√©parer le texte du vecteur normal
          const n = plane.displayNormal;
          const normalText = `Vn : n(${formatNumber(n.x, 1)}, ${formatNumber(n.z, 1)}, ${formatNumber(n.y, 1)})`;

          // 2. Pr√©parer le texte du point de passage (NOUVEAU)
          const p = plane.pointOnPlane;
          const pointText = `(${formatNumber(p.x, 1)}, ${formatNumber(p.z, 1)}, ${formatNumber(p.y, 1)})`;

          // 3. Bouton Vn (logique existante)
          const existingNormalVector = geometryManager.vectors.find(
            (v) => v.parentPlaneId === plane.id && v.isNormalVector
          );
          let normalBtnHtml;
          if (existingNormalVector) {
            normalBtnHtml = `<button class="btn-violet-light" onclick="toggleNormalVector(${plane.id})" title="Masquer le vecteur normal">Vn ‚ûñ</button>`;
          } else {
            normalBtnHtml = `<button class="btn-violet" onclick="toggleNormalVector(${plane.id})" title="Afficher le vecteur normal">Vn ‚ûï</button>`;
          }

          // 4. Structure HTML mise √† jour
          // Notez l'ajout de la div "geometry-details-secondary" avec l'ID "plane-point-ID"
          item.innerHTML = `
  <div class="geometry-item-main">
      <div class="geometry-info">
          <span class="geometry-name">${plane.name}</span>
          <span class="geometry-details" id="plane-normal-${plane.id}">${normalText}</span>
      </div>
      <div class="geometry-actions">
          ${normalBtnHtml}
          <button class="btn-secondary" onclick="openTransformationPanel('plane', ${plane.id})" title="Transformations">üîÑ</button>
          <button class="btn-secondary" onclick="togglePlaneVisibility(${plane.id})" title="${plane.isVisible ? "Masquer" : "Afficher"}">${plane.isVisible ? "üëÅÔ∏è" : "üôà"}</button>
          <button class="btn-danger" onclick="removePlaneById(${plane.id})" title="Supprimer">üóëÔ∏è</button>
      </div>
  </div>
  <div class="geometry-details-secondary">
      <span id="plane-point-${plane.id}" style="color: #666;">
          Passe par : <strong>${pointText}</strong>
      </span>
  </div>`;

          list.appendChild(item);
        });
      }

      function updateVectorList() {
        const list = document.getElementById("vectorList");
        list.innerHTML = geometryManager.vectors.length === 0 ? '<div class="point-item">Aucun vecteur trac√©.</div>' : "";

        geometryManager.vectors.forEach((vector) => {
          const item = document.createElement("div");
          item.className = "geometry-item";

          // R√©cup√©ration des valeurs
          const v = vector.components;
          const o = vector.origin;

          // Formatage Composantes (Vx, Vy, Vz)
          const coordsText = `(${formatNumber(v.x, 1)}, ${formatNumber(v.z, 1)}, ${formatNumber(v.y, 1)})`;

          // Formatage Origine (Ox, Oy, Oz) - Attention inversion Y/Z pour l'UI
          const originText = `(${formatNumber(o.x, 1)}, ${formatNumber(o.z, 1)}, ${formatNumber(o.y, 1)})`;

          const normText = formatNumber(vector.components.length(), 2);

          item.innerHTML = `
    <div class="geometry-item-main">
        <div class="geometry-info">
            <span class="geometry-name">${vector.name}</span>
            <!-- On donne des ID uniques aux spans pour pouvoir les mettre √† jour en temps r√©el -->
            <span class="geometry-coords" id="vector-comps-list-${vector.id}">Coord: ${coordsText}</span>
        </div>
        <div class="geometry-actions">
            <button class="btn-secondary" onclick="editVector(${vector.id})" title="Modifier">‚úèÔ∏è</button>
            <button class="btn-violet-light" onclick="toggleVectorLabelVisibility(${vector.id})" title="${vector.isLabelVisible ? "Masquer le nom" : "Afficher le nom"}">${vector.isLabelVisible ? "üëÅÔ∏è" : "üôà"}</button>
            <button class="btn-secondary" onclick="toggleVectorVisibility(${vector.id})" title="${vector.isVisible ? "Masquer" : "Afficher"}">${vector.isVisible ? "üëÅÔ∏è" : "üôà"}</button>
            <button class="btn-danger" onclick="removeVectorById(${vector.id})" title="Supprimer">üóëÔ∏è</button>
        </div>
    </div>
    <div class="geometry-details-secondary">
        <!-- C'est ici qu'on ajoute le champ Origine avec un ID unique -->
        <span id="vector-origin-list-${vector.id}" style="display:block; margin-bottom:2px; color:#555;">
            Origine: <strong>${originText}</strong>
        </span>
        Norme: <strong>${normText}</strong>
    </div>`;

          list.appendChild(item);
        });
      }

      function toggleVectorLabelVisibility(id) {
        const vector = geometryManager.findVectorById(id);
        if (vector) {
          // Appelle la nouvelle m√©thode de la classe Vector
          vector.setLabelVisibility(!vector.isLabelVisible);
          // Met √† jour la liste pour que le texte du bouton change
          updateVectorList();
        }
      }

      function toggleNormalVector(planeId) {
        const plane = geometryManager.findPlaneById(planeId);
        if (!plane) return;

        // Chercher si un vecteur normal existe d√©j√† pour ce plan
        const existingVector = geometryManager.vectors.find((v) => v.parentPlaneId === planeId && v.isNormalVector);

        if (existingVector) {
          // Le vecteur existe, on le supprime
          geometryManager.removeVector(existingVector);
        } else {
          // Le vecteur n'existe pas, on le cr√©e
          const normalVectorName = `Vn(${plane.name})`;
          const normalVectorLength = 2.5;
          const normalVectorComponents = plane.normal.clone().normalize().multiplyScalar(normalVectorLength);

          const normalVector = new Vector(
            normalVectorName,
            plane.mesh.position, // Origine du vecteur
            normalVectorComponents,
            0x800080 // Couleur violette
          );

          // On stocke des informations pour le retrouver
          normalVector.isNormalVector = true;
          normalVector.parentPlaneId = plane.id;
          geometryManager.addVector(normalVector);
        }

        // Mettre √† jour l'UI pour refl√©ter le changement de bouton et la liste des vecteurs
        updateAllUI();
        saveState();
      }

      function updateSelects() {
        const allSelects = document.querySelectorAll("select");
        const menusWithOrigin = ["vectorOriginPoint", "sumVectorOrigin", "crossVectorOrigin", "rotationCenterSelect", "planeEquationPointSelect", "lineEquationPointSelect"];


        allSelects.forEach((select) => {
          const id = select.id;
          const currentValue = select.value;

          // 1. On ignore les menus qui ne d√©pendent pas de la boucle g√©n√©rale
          // (Sauf s'ils ont besoin d'√™tre rafraichis par une fonction sp√©cifique ailleurs)
          if (["rotationAxisSelect", "symmetryTypeSelect", "savedScenesSelect", "symmetryRefSelect"].includes(id)) {
            return;
          }

          // On vide le menu pour le reconstruire
          select.innerHTML = "";

          // --- CAS SP√âCIAL 1 : Point de passage pour cr√©ation de Plan (Nouveau) ---
          if (id === "planeEquationPointSelect") {
            select.add(new Option("-- Par d√©faut (selon constante d) --", ""));
            select.add(new Option("Origine (0,0,0)", "origin"));
            geometryManager.points.forEach((p, i) => select.add(new Option(p.name, i)));
            select.value = currentValue;
            return; // On a fini pour ce menu sp√©cifique
          }

          // --- CAS SP√âCIAL 2 : Point de passage pour cr√©ation de Droite ---
          if (id === "lineEquationPointSelect") {
            select.add(new Option("-- Point de passage (d√©faut: √©quation) --", ""));
            select.add(new Option("Origine (0,0,0)", "origin"));
            geometryManager.points.forEach((p, i) => select.add(new Option(p.name, i)));
            select.value = currentValue;
            return; // On a fini pour ce menu sp√©cifique
          }

          // --- LOGIQUE G√âN√âRALE ---

          // A. Les Vecteurs
          if (id.includes("Vector")) {
            select.add(new Option("-- Vecteur --", ""));
            geometryManager.vectors.forEach((v) => select.add(new Option(v.name, v.id)));
          }
          // B. Les Droites (inclut 'equationLineSelect')
          else if (id.includes("Line")) {
            // Ajout des droites (fonctionne pour "lineSelect" ET "perpLine1")
            select.add(new Option("-- Droite --", ""));
            geometryManager.lines.forEach((l) => select.add(new Option(l.name, l.id)));
          }
          // C. Les Plans (inclut 'equationPlaneSelect')
          else if (id.includes("Plane")) {
            select.add(new Option("-- Plan --", ""));
            geometryManager.planes.forEach((p) => select.add(new Option(p.name, p.id)));
          }
          // D. Les Points (Par d√©faut pour tout le reste)
          else {
            select.add(new Option("-- Point --", ""));
            geometryManager.points.forEach((p, i) => select.add(new Option(p.name, i)));
          }

          // --- OPTIONS SUPPL√âMENTAIRES (Origine) ---
          if (menusWithOrigin.includes(id)) {
            // On ins√®re l'option Origine intelligemment
            // Si le menu a d√©j√† une option (le titre "-- Choisir --"), on ins√®re apr√®s
            const originOpt = new Option("Origine (0,0,0)", "origin");
            if (select.options.length > 0) {
              select.add(originOpt, select.options[1]); // Index 1 = apr√®s le titre
            } else {
              select.add(originOpt);
            }
          }
          // if (["vectorOriginPoint", "sumVectorOrigin", "crossVectorOrigin", "rotationCenterSelect"].includes(id)) {
          //   if (select.options.length > 0) {
          //     const originOpt = new Option("Origine (0,0,0)", "origin");
          //     select.add(originOpt, select.options[1]);
          //   } else {
          //     select.add(new Option("Origine (0,0,0)", "origin"));
          //   }
          // }

          // Restauration de la valeur s√©lectionn√©e (si elle existe encore)
          select.value = currentValue;
        });

        // --- IMPORTANT : Mise √† jour des zones d'affichage des √©quations ---
        // C'est ce qui permet de rafra√Æchir le texte de l'√©quation si une droite/plan est d√©j√† s√©lectionn√©
        displayPlaneEquation();
        displayLineEquation();

        // Mise √† jour du menu de sym√©trie s'il existe
        if (document.getElementById("symmetryTypeSelect")) {
          updateSymmetryUI();
        }
      }

      // =====================================================================================
      // SECTION 5 : CR√âATION / MODIFICATION / SUPPRESSION D'OBJETS
      // =====================================================================================
      function editPoint(index, forceOpen = true) {
        // MODIFICATION : On n'ouvre le panneau que si forceOpen est vrai
        if (forceOpen) {
          ensurePanelVisible();
        }

        const p = geometryManager.points[index];
        if (!p) return;

        document.getElementById("pointName").value = p.name;
        document.getElementById("pointX").value = formatNumber(p.position.x);
        document.getElementById("pointY").value = formatNumber(p.position.z);
        document.getElementById("pointZ").value = formatNumber(p.position.y);
        document.getElementById("editPointIndex").value = index;

        document.getElementById("addPointBtn").style.display = "none";
        document.getElementById("pointEditActions").style.display = "grid";

        // MODIFICATION : On ne fait d√©filer que si le panneau est cens√© s'ouvrir
        if (forceOpen) {
          const s = document.getElementById("pointList").closest(".section.collapsible");
          if (s && s.classList.contains("collapsed")) {
            s.classList.remove("collapsed");
          }
        }
      }

      function editVector(id, forceOpen = true) {
        // 1. Si demand√©, on ouvre le panneau lat√©ral
        if (forceOpen) ensurePanelVisible();

        // 2. On r√©cup√®re le vecteur par son ID
        const v = geometryManager.findVectorById(id);
        if (!v) {
          console.error("Vecteur introuvable pour l'id :", id);
          return;
        }

        // 3. Remplissage des champs (Nom)
        document.getElementById("vectorNameCoords").value = v.name;

        // 4. Remplissage des Composantes (Vx, Vy, Vz)
        // On utilise une s√©curit√© (|| 0) au cas o√π les donn√©es seraient incompl√®tes
        document.getElementById("vectorCoordX").value = formatNumber(v.components.x || 0);
        document.getElementById("vectorCoordY").value = formatNumber(v.components.z || 0); // Z ThreeJS -> Y UI
        document.getElementById("vectorCoordZ").value = formatNumber(v.components.y || 0); // Y ThreeJS -> Z UI

        // 5. Remplissage de l'Origine (Ox, Oy, Oz)
        const ox = v.origin.x || 0;
        const oy = v.origin.y || 0; // Y ThreeJS -> Z UI (Hauteur)
        const oz = v.origin.z || 0; // Z ThreeJS -> Y UI (Profondeur)

        document.getElementById("vectorOriginX").value = formatNumber(ox);
        document.getElementById("vectorOriginY").value = formatNumber(oz); // Attention inversion affichage
        document.getElementById("vectorOriginZ").value = formatNumber(oy); // Attention inversion affichage

        // 6. Gestion du menu d√©roulant "Origine" (VERSION CORRIG√âE ET S√âCURIS√âE)
        const originSelect = document.getElementById("vectorOriginPoint");
        if (originSelect) {
          originSelect.value = "";

          // Calcul manuel de la longueur au carr√© pour √©viter "distanceToSq is not a function"
          const originLengthSq = ox * ox + oy * oy + oz * oz;

          // Si l'origine est (0,0,0) (ou tr√®s proche)
          if (originLengthSq < 0.0001) {
            originSelect.value = "origin";
          }
          // Sinon on cherche si √ßa correspond √† un point existant
          else {
            for (let i = 0; i < geometryManager.points.length; i++) {
              const p = geometryManager.points[i].position;
              // Calcul manuel de la distance au carr√© entre l'origine du vecteur et le point p
              const dx = ox - p.x;
              const dy = oy - p.y;
              const dz = oz - p.z;
              const distSq = dx * dx + dy * dy + dz * dz;

              if (distSq < 0.0001) {
                originSelect.value = i.toString();
                break;
              }
            }
          }
        }

        // 7. Stockage de l'ID en cours d'√©dition
        document.getElementById("editVectorId").value = id;

        // 8. GESTION DES BOUTONS
        // A. Cacher le bouton "Tracer le vecteur"
        const addBtn = document.getElementById("addVectorFromCoordsBtn");
        if (addBtn) addBtn.style.display = "none";

        // B. Afficher le groupe de boutons "Mettre √† jour / Supprimer / Annuler"
        const editActions = document.getElementById("vectorEditActions");
        if (editActions) {
          editActions.style.display = "grid";
        }

        // 9. OUVERTURE DE LA SECTION ET D√âFILEMENT
        if (forceOpen) {
          const inputField = document.getElementById("vectorNameCoords");
          const section = inputField.closest(".section.collapsible");

          if (section && section.classList.contains("collapsed")) {
            section.classList.remove("collapsed");
          }

        }
      }


      function editLine(id, forceOpen = true) {
        // MODIFICATION : Si on ne force pas l'ouverture (mobile), on ne fait rien de visuel dans le panneau
        if (forceOpen) {
          ensurePanelVisible();
          expandSectionAndScrollToItem(`line-item-${id}`, "lineList");
        }
      }

      function editPlane(id, forceOpen = true) {
        // MODIFICATION
        if (forceOpen) {
          ensurePanelVisible();
          expandSectionAndScrollToItem(`plane-item-${id}`, "planeList");
        }
      }

      function openTransformationPanel(type, id) {
        ensurePanelVisible(); // Ouvre le panneau lat√©ral s'il est ferm√©

        // 1. Retrouver l'instance de l'objet
        let instance = null;
        if (type === 'point') {
          instance = geometryManager.points[id];
        } else if (type === 'line') {
          instance = geometryManager.findLineById(id);
        } else if (type === 'plane') {
          instance = geometryManager.findPlaneById(id);
        } else if (type === 'vector') {
          instance = geometryManager.findVectorById(id);
        }

        if (instance) {
          // 2. Forcer la s√©lection de cet objet (indispensable pour que les boutons fonctionnent)
          // On d√©s√©lectionne l'ancien d'abord pour nettoyer
          if (selectedObjectInstance && selectedObjectInstance !== instance) {
            deselectCurrentObject();
          }
          selectedObjectInstance = instance;

          // 3. Mettre l'objet en surbrillance (jaune)
          const HIGHLIGHT_COLOR = 0xffff00;
          if (instance instanceof Vector) {
            if (instance.arrowHelper) instance.arrowHelper.setColor(HIGHLIGHT_COLOR);
          } else if (instance.mesh) {
            instance.mesh.material.color.set(HIGHLIGHT_COLOR);
            if (instance instanceof Plane) instance.mesh.material.opacity = 0.75;
          }

          // 4. Afficher l'interface de transformation
          document.getElementById("transformations-hint").style.display = "none";
          document.getElementById("transformations-container").style.display = "block";

          // 5. D√©plier la section "Transformations"
          const transContainer = document.getElementById("transformations-container");
          const section = transContainer.closest(".section");
          if (section && section.classList.contains("collapsed")) {
            section.classList.remove("collapsed");
          }

          // 6. Faire d√©filer jusqu'aux options
          setTimeout(() => {
            transContainer.scrollIntoView({ behavior: "smooth", block: "start" });
          }, 100); // Petit d√©lai pour laisser le temps au d√©pliage
        }
      }

      function addPoint() {
        const n = document.getElementById("pointName").value.trim();
        const x = parseFloat(document.getElementById("pointX").value);
        const y_from_ui = parseFloat(document.getElementById("pointY").value); // Profondeur
        const z_from_ui = parseFloat(document.getElementById("pointZ").value); // Hauteur
        if (!n || isNaN(x) || isNaN(y_from_ui) || isNaN(z_from_ui)) {
          showSplashScreen("Donn√©es invalides.");
          return;
        }
        // Le constructeur Point attend un nom et un Vector3, pas des coordonn√©es s√©par√©es
        geometryManager.addPoint(new Point(n, x, z_from_ui, y_from_ui));

        cancelEdit();

        updateAllUI();
        saveState();
      }

      function updatePoint() {
        const i = document.getElementById("editPointIndex").value;
        const p = geometryManager.points[i];
        if (!p) return;

        const n = document.getElementById("pointName").value.trim();

        // --- D√âBUT DE LA CORRECTION ---
        // On utilise les bons IDs pour lire les coordonn√©es depuis le formulaire
        const x = parseFloat(document.getElementById("pointX").value);
        const y_from_ui = parseFloat(document.getElementById("pointY").value); // Profondeur
        const z_from_ui = parseFloat(document.getElementById("pointZ").value); // Hauteur
        // --- FIN DE LA CORRECTION ---

        if (!n || isNaN(x) || isNaN(y_from_ui) || isNaN(z_from_ui)) {
          showSplashScreen("Donn√©es invalides.");
          return;
        }

        // --- AJOUT DE LA V√âRIFICATION ---
        // On v√©rifie si le nouveau nom est d√©j√† pris par un AUTRE objet
        const existingObject = geometryManager.findObjectByName(n);
        if (existingObject && existingObject.id !== p.id) {
          showSplashScreen(`Le nom "${n}" est d√©j√† utilis√©. Veuillez en choisir un autre.`);
          return;
        }
        // --- FIN DE L'AJOUT ---

        // On garde votre logique de mise √† jour, elle est parfaite
        p.update(n, x, z_from_ui, y_from_ui);

        updateAllUI();
        cancelEdit();
        saveState();
      }

      function cancelEdit() {
        // Vider les champs
        document.getElementById("pointName").value = "";
        document.getElementById("pointX").value = "";
        document.getElementById("pointY").value = "";
        document.getElementById("pointZ").value = "";
        document.getElementById("editPointIndex").value = "";

        // --- PARTIE CORRIG√âE ---
        // Afficher le bouton "Ajouter"
        document.getElementById("addPointBtn").style.display = "block";
        // Cacher le CONTENEUR des boutons d'√©dition
        document.getElementById("pointEditActions").style.display = "none";
      }

      function deleteEditingPoint() {
        // R√©cup√®re l'index du point depuis le champ cach√©
        const index = parseInt(document.getElementById("editPointIndex").value);
        if (isNaN(index)) return; // S√©curit√©

        // Appelle la fonction de suppression existante qui g√®re d√©j√† la confirmation
        removePoint(index);

        // R√©initialise le formulaire pour quitter le mode √©dition
        cancelEdit();
      }

      function removePoint(index) {
        const p = geometryManager.points[index];
        if (p && confirm(`Supprimer "${p.name}" ?`)) {
          if (selectedObjectInstance === p) {
            deselectCurrentObject();
          }
          geometryManager.removePoint(p);
          updateAllUI();
          saveState();
        }
      }

      function clearAllPoints() {
        // 1. Modifier le message de confirmation pour qu'il soit pr√©cis.
        if (
          confirm(
            "√ätes-vous s√ªr de vouloir effacer tous les points ? (Les droites, plans et vecteurs existants seront conserv√©s)"
          )
        ) {
          deselectCurrentObject();
          // 2. Parcourir chaque point pour le retirer de la sc√®ne 3D.
          geometryManager.points.forEach((point) => {
            point.removeFromScene(scene);
          });

          // 3. Vider le tableau des points dans le gestionnaire.
          geometryManager.points = [];

          // 4. Mettre √† jour l'interface utilisateur pour refl√©ter la suppression.
          updateAllUI();
          saveState();
        }
      }

      // --- Droites ---

      // Dans la SECTION 5
      function addStraightLine() {
        const [i1, i2] = [document.getElementById("lineStart").value, document.getElementById("lineEnd").value];
        if (i1 === "" || i2 === "" || i1 === i2) {
          showSplashScreen("S√©lectionnez deux points diff√©rents.");
          return;
        }
        const p1 = geometryManager.points[i1],
          p2 = geometryManager.points[i2];
        const d = new THREE.Vector3().subVectors(p2.position, p1.position);

        const baseName = `Droite(${p1.name},${p2.name})`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "line"); // On passe 'line'
        geometryManager.addLine(new Line3D(uniqueName, p1.position, d));
        updateAllUI();
        saveState();
      }

      function removeStraightLineById(id) {
        const l = geometryManager.findLineById(id);
        if (l && confirm(`Supprimer "${l.name}" ?`)) {
          if (selectedObjectInstance === l) {
            deselectCurrentObject();
          }
          geometryManager.removeLine(l);
          updateAllUI();
          saveState();
        }
      }

      function onLineEquationPointChange() {
        const val = document.getElementById("lineEquationPointSelect").value;

        // On r√©cup√®re les √©l√©ments DOM directement
        const xInput = document.getElementById("lineEqPointX");
        const yInput = document.getElementById("lineEqPointY");
        const zInput = document.getElementById("lineEqPointZ");

        if (val === "origin") {
          xInput.value = 0; yInput.value = 0; zInput.value = 0;
        } else if (val !== "") {
          const p = geometryManager.points[parseInt(val)];
          if (p) {
            xInput.value = formatNumber(p.position.x);
            // Inversion UI Y/Z pour l'affichage
            yInput.value = formatNumber(p.position.z);
            zInput.value = formatNumber(p.position.y);
          }
        } else {
          // CAS CRUCIAL : Si on revient sur "D√©faut", on VIDE les champs
          // C'est ce qui permet ensuite √† la fonction de cr√©ation de savoir
          // qu'elle doit utiliser les constantes de l'√©quation.
          xInput.value = "";
          yInput.value = "";
          zInput.value = "";
        }
      }

      function addLineFromEquation() {
        const name = document.getElementById("lineNameFromEquation").value.trim() || "Droite (Eq)";
        const equationsText = document.getElementById("lineEquationInput").value;
        const lines = equationsText.split("\n").filter((line) => line.trim() !== "");

        if (lines.length < 3) {
          showSplashScreen("Veuillez entrer les 3 √©quations param√©triques (x, y, et z).");
          return;
        }

        // --- 1. Analyse du texte (Vecteur ET Point du texte) ---
        let textPoint = { x: 0, y: 0, z: 0 };
        let vector = { x: 0, y: 0, z: 0 };
        const axesFound = { x: false, y: false, z: false };

        for (const line of lines) {
          const axisChar = line.trim().charAt(0).toLowerCase();
          if (!["x", "y", "z"].includes(axisChar)) continue;

          const cleanLine = line.substring(line.indexOf("=") + 1);

          // Extraction vecteur (t)
          let tMatch = cleanLine.match(/[+-]?\s*[\d.]*t/);
          let vectorComp = 0;
          let lineWithoutT = cleanLine;

          if (tMatch) {
            let tPart = tMatch[0].replace(/\s/g, "").replace("t", "");
            if (tPart === "+" || tPart === "") vectorComp = 1;
            else if (tPart === "-") vectorComp = -1;
            else vectorComp = parseFloat(tPart);
            lineWithoutT = cleanLine.replace(tMatch[0], "");
          }

          // Extraction point (constante)
          let pointCoord = parseFloat(lineWithoutT.trim() || "0"); // Par d√©faut 0 si pas de constante

          if (isNaN(pointCoord) || isNaN(vectorComp)) {
            showSplashScreen(`Erreur de syntaxe axe '${axisChar}'.`);
            return;
          }

          textPoint[axisChar] = pointCoord;
          vector[axisChar] = vectorComp;
          axesFound[axisChar] = true;
        }

        if (!axesFound.x || !axesFound.y || !axesFound.z) {
          showSplashScreen("Equations incompl√®tes (besoin de x, y, z).");
          return;
        }

        // --- 2. D√âCISION DU POINT DE D√âPART (HI√âRARCHIE STRICTE) ---

        // R√©cup√©ration des valeurs BRUTES (chaines de caract√®res)
        const xStr = document.getElementById("lineEqPointX").value.trim();
        const yStr = document.getElementById("lineEqPointY").value.trim();
        const zStr = document.getElementById("lineEqPointZ").value.trim();
        const selectVal = document.getElementById("lineEquationPointSelect").value;

        let finalStartPoint;

        // PRIORIT√â 1 : Les champs manuels (seulement si au moins un est rempli par l'utilisateur)
        if (xStr !== "" || yStr !== "" || zStr !== "") {
          // Si l'utilisateur a tap√© quelque chose, on prend ses valeurs.
          // Si un champ est vide mais qu'un autre est rempli, on consid√®re le vide comme 0.
          finalStartPoint = new THREE.Vector3(
            parseFloat(xStr) || 0,
            parseFloat(zStr) || 0, // UI Z (Haut) -> 3JS Y
            parseFloat(yStr) || 0  // UI Y (Prof) -> 3JS Z
          );
        }
        // PRIORIT√â 2 : Le menu d√©roulant (si une option est choisie)
        else if (selectVal !== "") {
          if (selectVal === "origin") {
            finalStartPoint = new THREE.Vector3(0, 0, 0);
          } else {
            const p = geometryManager.points[parseInt(selectVal)];
            if (p) finalStartPoint = p.position.clone();
            else finalStartPoint = new THREE.Vector3(0, 0, 0); // S√©curit√©
          }
        }
        // PRIORIT√â 3 : Le texte de l'√©quation (fallback par d√©faut)
        else {
          // C'est ici qu'on utilise les constantes extraites (ex: 1, 0, 4 pour x=1+2t...)
          finalStartPoint = new THREE.Vector3(textPoint.x, textPoint.y, textPoint.z);
        }

        // --- 3. Cr√©ation ---
        const directorVector = new THREE.Vector3(vector.x, vector.y, vector.z);

        if (directorVector.lengthSq() < 1e-8) {
          showSplashScreen("Vecteur directeur nul.");
          return;
        }

        const uniqueName = geometryManager.generateUniqueName(name, "line");
        geometryManager.addLine(new Line3D(uniqueName, finalStartPoint, directorVector));

        updateAllUI();
        saveState();

        // --- CORRECTION : NETTOYAGE COMPLET ---
        // 1. On vide le nom pour la prochaine
        document.getElementById("lineNameFromEquation").value = "";

        // 2. IMPORTANT : On remet le selecteur sur "D√©faut"
        const select = document.getElementById("lineEquationPointSelect");
        if (select) select.value = "";

        // 3. CRUCIAL : On vide les champs manuels pour que la prochaine √©quation soit prioritaire
        document.getElementById("lineEqPointX").value = "";
        document.getElementById("lineEqPointY").value = "";
        document.getElementById("lineEqPointZ").value = "";
      }

      function toggleStraightLineVisibility(lineId) {
        const line = geometryManager.findLineById(lineId);
        if (line) {
          line.setVisibility(!line.isVisible);
          // Met √† jour la liste pour changer le texte du bouton
          updateStraightLineList();
        }
      }

      function clearStraightLines() {
        if (confirm("Effacer toutes les droites ?")) {
          deselectCurrentObject();
          geometryManager.lines.forEach((line) => line.removeFromScene(scene));
          geometryManager.lines = [];
          updateAllUI();
          saveState();
        }
      }

      // --- Plans ---
      function addPlane() {
        const n = document.getElementById("planeName").value.trim() || "Plan";

        // --- V√©rification du nom unique ---
        if (geometryManager.planes.some((p) => p.name === n)) {
          showSplashScreen(`Le nom de plan "${n}" est d√©j√† utilis√©. Veuillez en choisir un autre.`);
          return;
        }
        // --- Fin de la v√©rification ---

        const [i1, i2, i3] = ["planeSelectP1", "planeSelectP2", "planeSelectP3"].map(
          (id) => document.getElementById(id).value
        );
        if (i1 === "" || i2 === "" || i3 === "" || i1 === i2 || i1 === i3 || i2 === i3) {
          showSplashScreen("S√©lectionnez trois points distincts.");
          return;
        }
        const [p1, p2, p3] = [i1, i2, i3].map((i) => geometryManager.points[i].position);
        const norm = new THREE.Vector3().crossVectors(
          new THREE.Vector3().subVectors(p2, p1),
          new THREE.Vector3().subVectors(p3, p1)
        );
        if (norm.lengthSq() < 1e-6) {
          showSplashScreen("Points colin√©aires.");
          return;
        }

        const areIntegers = Number.isInteger(norm.x) && Number.isInteger(norm.y) && Number.isInteger(norm.z);

        if (areIntegers) {
          const commonDivisor = gcdOfThree(norm.x, norm.y, norm.z);
          if (commonDivisor > 1) {
            norm.divideScalar(commonDivisor);
          }
        }

        const newPlane = new Plane(n, p1, norm);
        geometryManager.addPlane(newPlane);
        saveState();
        updateAllUI();
        document.getElementById("planeName").value = "";
      }

      function onPlaneEquationPointChange() {
        const val = document.getElementById("planeEquationPointSelect").value;
        const xInput = document.getElementById("planeEqPointX");
        const yInput = document.getElementById("planeEqPointY");
        const zInput = document.getElementById("planeEqPointZ");

        if (val === "origin") {
          xInput.value = 0;
          yInput.value = 0;
          zInput.value = 0;
        } else if (val !== "") {
          const p = geometryManager.points[parseInt(val)];
          if (p) {
            xInput.value = formatNumber(p.position.x);
            // Attention : Inversion UI Y/Z standard dans votre code
            yInput.value = formatNumber(p.position.z); // Profondeur (UI Y) -> ThreeJS Z
            zInput.value = formatNumber(p.position.y); // Hauteur (UI Z) -> ThreeJS Y
          }
        } else {
          // Si on revient sur "D√©faut", on vide pour laisser la priorit√© √† la constante 'd' de l'√©quation
          xInput.value = "";
          yInput.value = "";
          zInput.value = "";
        }
      }

      function addPlaneFromEquation() {
        let equationStr = document.getElementById("planeEquationInput").value.trim();

        // ========================================
        // 1. VALIDATION DE L'ENTR√âE
        // ========================================
        if (!equationStr) {
          showSplashScreen("‚ö†Ô∏è Veuillez entrer une √©quation (ex: 2x + y + z = 6).");
          return;
        }

        // ========================================
        // 2. NORMALISATION DE L'√âQUATION
        // ========================================
        // Convertir "2x - y + 3z = 6" en "2x - y + 3z - 6"
        if (equationStr.includes("=")) {
          const parts = equationStr.split("=");
          equationStr = `${parts[0]} - (${parts[1]})`;
        }

        // ========================================
        // 3. EXTRACTION DES COEFFICIENTS (a, b, c)
        // ========================================
        const getCoefficient = (variable) => {
          const regex = new RegExp(`([+-]?[\\d\\.]*)\\s*\\*?\\s*${variable}`, "gi");
          let totalCoeff = 0;
          let match;

          while ((match = regex.exec(equationStr)) !== null) {
            let coeffStr = match[1].replace(/\s/g, "");
            if (coeffStr === "" || coeffStr === "+") totalCoeff += 1;
            else if (coeffStr === "-") totalCoeff += -1;
            else totalCoeff += parseFloat(coeffStr);
          }
          return totalCoeff;
        };

        const a = getCoefficient("x");
        const b = getCoefficient("y"); // UI Y (Profondeur) ‚Üí ThreeJS Z
        const c = getCoefficient("z"); // UI Z (Hauteur) ‚Üí ThreeJS Y

        // Construction du vecteur normal Three.js
        // RAPPEL : a ‚Üí x, c ‚Üí y (hauteur), b ‚Üí z (profondeur)
        const normal = new THREE.Vector3(a, c, b);

        if (normal.lengthSq() < 1e-8) {
          showSplashScreen("‚ùå Vecteur normal nul ou invalide. V√©rifiez l'√©quation.");
          return;
        }

        // ========================================
        // 4. D√âTERMINATION DU POINT DE PASSAGE
        // ========================================
        const pxStr = document.getElementById("planeEqPointX").value.trim();
        const pyStr = document.getElementById("planeEqPointY").value.trim();
        const pzStr = document.getElementById("planeEqPointZ").value.trim();

        let pointOnPlane = null;
        let calculationMode = "auto"; // "auto" (constante d) ou "point" (point impos√©)

        // CAS A : L'utilisateur a rempli les coordonn√©es (ou s√©lectionn√© un point)
        if (pxStr !== "" || pyStr !== "" || pzStr !== "") {
          calculationMode = "point";
          const px = parseFloat(pxStr) || 0;
          const py_ui = parseFloat(pyStr) || 0; // Profondeur
          const pz_ui = parseFloat(pzStr) || 0; // Hauteur

          // Cr√©ation du point ThreeJS (X, Hauteur, Profondeur)
          pointOnPlane = new THREE.Vector3(px, pz_ui, py_ui);
        }
        // CAS B : Calcul automatique via la constante 'd' de l'√©quation
        else {
          // Extraction de la constante 'd'
          let constantStr = equationStr
            .replace(/[+-]?[\d\\.]*\s*\*?\s*[xyz]/gi, "") // Enlever tous les termes en x, y, z
            .replace(/--/g, "+")                          // Nettoyer les doubles signes
            .trim();

          let d = 0;
          try {
            if (constantStr) {
              // √âvaluer l'expression math√©matique restante (ex: "- 6" ‚Üí -6)
              d = new Function("return " + constantStr)();
            }
          } catch (e) {
            console.error("Erreur lors du calcul de la constante d:", e);
          }

          // Trouver un point arbitraire qui satisfait ax + by + cz + d = 0
          // On choisit le plus simple (mettre 2 coordonn√©es √† 0)
          if (Math.abs(normal.x) > 1e-6) {
            pointOnPlane = new THREE.Vector3(-d / normal.x, 0, 0);
          } else if (Math.abs(normal.z) > 1e-6) {
            pointOnPlane = new THREE.Vector3(0, 0, -d / normal.z);
          } else if (Math.abs(normal.y) > 1e-6) {
            pointOnPlane = new THREE.Vector3(0, -d / normal.y, 0);
          } else {
            pointOnPlane = new THREE.Vector3(0, 0, 0);
          }
        }

        // ========================================
        // 5. G√âN√âRATION DU NOM ET CR√âATION
        // ========================================
        let baseName;
        if (calculationMode === "point") {
          // Nom bas√© sur la normale (plus explicite)
          baseName = `Plan(n[${a},${b},${c}])`;
        } else {
          // Nom bas√© sur l'√©quation (tronqu√©e pour la lisibilit√©)
          baseName = `Plan(${formatNumber(a)}x+${formatNumber(b)}y+${formatNumber(c)}z...)`;
        }

        const uniqueName = geometryManager.generateUniqueName(baseName, "plane");
        const newPlane = new Plane(uniqueName, pointOnPlane, normal, 0xffeb3b);

        geometryManager.addPlane(newPlane);
        updateAllUI();
        saveState();

        // ========================================
        // 6. NETTOYAGE DES CHAMPS
        // ========================================
        document.getElementById("planeEquationInput").value = "";

        // Remettre le select sur "d√©faut"
        const select = document.getElementById("planeEquationPointSelect");
        if (select) select.value = "";

        // Vider les champs manuels
        document.getElementById("planeEqPointX").value = "";
        document.getElementById("planeEqPointY").value = "";
        document.getElementById("planeEqPointZ").value = "";

        // Message de confirmation
        showSplashScreen(`‚úÖ Plan "${uniqueName}" cr√©√© !`);
      }
      function removePlaneById(id) {
        const p = geometryManager.findPlaneById(id);
        if (p && confirm(`Supprimer le plan "${p.name}" ?`)) {
          if (selectedObjectInstance === p) {
            deselectCurrentObject();
          }
          // Chercher et supprimer le vecteur normal associ√© s'il existe
          const normalVector = geometryManager.vectors.find((v) => v.parentPlaneId === p.id && v.isNormalVector);
          if (normalVector) {
            geometryManager.removeVector(normalVector);
          }

          // Supprimer le plan lui-m√™me
          geometryManager.removePlane(p);
          updateAllUI();
          saveState();
        }
      }

      function clearAllPlanes() {
        if (confirm("Effacer tous les plans et leurs normales associ√©es ?")) {
          // D'abord, trouver et supprimer tous les vecteurs normaux
          deselectCurrentObject()
          const normalVectors = geometryManager.vectors.filter((v) => v.isNormalVector);
          normalVectors.forEach((v) => geometryManager.removeVector(v));

          // Ensuite, supprimer tous les plans
          geometryManager.planes.forEach((plane) => plane.removeFromScene(scene));
          geometryManager.planes = [];
          updateAllUI();
          saveState();
        }
      }

      function togglePlaneVisibility(id) {
        const p = geometryManager.findPlaneById(id);
        if (p) {
          p.setVisibility(!p.isVisible);
          updatePlaneList();
        }
      }

      // --- Vecteurs ---
      function addVectorFromPoints() {
        const [sIdx, eIdx] = ["vectorStartPoint", "vectorEndPoint"].map((id) => document.getElementById(id).value);
        if (sIdx === "" || eIdx === "" || sIdx === eIdx) {
          showSplashScreen("S√©lectionnez deux points diff√©rents.");
          return;
        }
        const pS = geometryManager.points[sIdx],
          pE = geometryManager.points[eIdx];
        const c = new THREE.Vector3().subVectors(pE.position, pS.position);
        const n = `Vecteur(${pS.name}${pE.name})`;

        const baseName = `Vecteur(${pS.name}${pE.name})`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "vector");
        geometryManager.addVector(new Vector(uniqueName, pS.position, c));
        updateAllUI();
        saveState();
      }

      function addVectorFromCoords() {
        const n = document.getElementById("vectorNameCoords").value.trim() || "Vecteur";

        // V√©rification doublon de nom
        if (geometryManager.vectors.some((vector) => vector.name === n)) {
          showSplashScreen(`Le nom de vecteur "${n}" est d√©j√† utilis√©. Veuillez en choisir un autre.`);
          return;
        }

        // 1. Lecture des COMPOSANTES du vecteur (Vx, Vy, Vz)
        const vx = parseFloat(document.getElementById("vectorCoordX").value);
        const vy_vec = parseFloat(document.getElementById("vectorCoordY").value); // Profondeur (UI)
        const vz_vec = parseFloat(document.getElementById("vectorCoordZ").value); // Hauteur (UI)

        // 2. Lecture de l'ORIGINE du vecteur (Ox, Oy, Oz) - C'est ici qu'√©tait le probl√®me
        // On lit maintenant ce que vous tapez, ou ce qui a √©t√© rempli automatiquement
        const ox = parseFloat(document.getElementById("vectorOriginX").value);
        const oy_org = parseFloat(document.getElementById("vectorOriginY").value); // Profondeur (UI)
        const oz_org = parseFloat(document.getElementById("vectorOriginZ").value); // Hauteur (UI)

        // 3. Validation
        // On v√©rifie que TOUT est num√©rique. Si une case origine est vide, on consid√®re que c'est invalide (ou on pourrait mettre 0 par d√©faut).
        if ([vx, vy_vec, vz_vec, ox, oy_org, oz_org].some(isNaN)) {
          showSplashScreen("Veuillez remplir toutes les coordonn√©es (Composantes ET Origine).");
          return;
        }

        // 4. Cr√©ation des objets Three.js
        // Attention √† l'inversion Y/Z sp√©cifique √† votre application :
        // UI (X, Profondeur, Hauteur) -> ThreeJS (x, z, y)
        const comps = new THREE.Vector3(vx, vz_vec, vy_vec);
        const origin = new THREE.Vector3(ox, oz_org, oy_org);

        // 5. Ajout
        geometryManager.addVector(new Vector(n, origin, comps));

        cancelVectorEdit(); // Vide les champs proprement
        updateAllUI();
        saveState();
      }

      function updateVector() {
        const id = parseInt(document.getElementById("editVectorId").value);
        const v = geometryManager.findVectorById(id);
        if (!v) return;

        const n = document.getElementById("vectorNameCoords").value.trim();

        // V√©rif doublon de nom
        if (geometryManager.vectors.some((vec) => vec.name === n && vec.id !== id)) {
          showSplashScreen(`Le nom "${n}" est d√©j√† utilis√©.`);
          return;
        }

        // 1. Lecture des COMPOSANTES (Vx, Vy, Vz)
        const vx = parseFloat(document.getElementById("vectorCoordX").value);
        const vy_ui = parseFloat(document.getElementById("vectorCoordY").value);
        const vz_ui = parseFloat(document.getElementById("vectorCoordZ").value);

        // 2. Lecture de l'ORIGINE (Ox, Oy, Oz) - AJOUT CRUCIAL
        // On lit maintenant les valeurs que vous avez saisies manuellement
        const ox = parseFloat(document.getElementById("vectorOriginX").value);
        const oy_ui = parseFloat(document.getElementById("vectorOriginY").value);
        const oz_ui = parseFloat(document.getElementById("vectorOriginZ").value);

        // V√©rification de validit√©
        if ([vx, vy_ui, vz_ui, ox, oy_ui, oz_ui].some(val => isNaN(val))) {
          showSplashScreen("Toutes les coordonn√©es (Composantes et Origine) doivent √™tre valides.");
          return;
        }

        // 3. Cr√©ation des vecteurs ThreeJS (Attention √† l'inversion Y/Z)
        const components = new THREE.Vector3(vx, vz_ui, vy_ui);
        const origin = new THREE.Vector3(ox, oz_ui, oy_ui);

        // 4. Application de la mise √† jour
        // On ignore d√©sormais le menu d√©roulant, on fait confiance aux champs de saisie
        v.update(n, origin, components);

        // 5. Finalisation
        updateAllUI();
        cancelVectorEdit();
        saveState();
        showSplashScreen("Vecteur mis √† jour !");
      }

      function deleteEditingVector() {
        const id = parseInt(document.getElementById("editVectorId").value);
        if (isNaN(id)) return; // S√©curit√© pour √©viter les erreurs

        const vector = geometryManager.findVectorById(id);
        if (vector) {
          // On utilise la fonction de suppression existante, qui g√®re la confirmation
          removeVectorById(id);
          // On r√©initialise le formulaire
          cancelVectorEdit();
        }
      }

      function cancelVectorEdit() {
        // 1. Vider les champs
        document.getElementById("vectorNameCoords").value = "";
        document.getElementById("vectorCoordX").value = "";
        document.getElementById("vectorCoordY").value = "";
        document.getElementById("vectorCoordZ").value = "";
        document.getElementById("vectorOriginX").value = "";
        document.getElementById("vectorOriginY").value = "";
        document.getElementById("vectorOriginZ").value = "";
        document.getElementById("editVectorId").value = "";
        document.getElementById("vectorOriginPoint").value = "";

        // 2. R√©tablir les boutons
        const addBtn = document.getElementById("addVectorFromCoordsBtn");
        if (addBtn) addBtn.style.display = "block"; // On r√©affiche "Ajouter"

        const editActions = document.getElementById("vectorEditActions");
        if (editActions) editActions.style.display = "none"; // On cache "Mettre √† jour"

        // 3. D√©s√©lectionner l'objet 3D (optionnel mais recommand√©)
        deselectCurrentObject();
      }

      function removeVectorById(id) {
        const v = geometryManager.findVectorById(id);
        if (v && confirm(`Supprimer "${v.name}" ?`)) {
          if (selectedObjectInstance === v) {
            deselectCurrentObject();
          }
          geometryManager.removeVector(v);
          updateAllUI();
          saveState();
        }
      }

      function clearAllVectors() {
        if (confirm("Effacer tous les vecteurs ?")) {

          geometryManager.vectors.forEach((vector) => vector.removeFromScene(scene));
          geometryManager.vectors = [];
          updateAllUI();
        }
      }

      function toggleVectorVisibility(id) {
        const v = geometryManager.findVectorById(id);
        if (v) {
          v.setVisibility(!v.isVisible);
          updateVectorList();
        }
      }

      function performRaycastSelection(screenX, screenY) {
        mouse.x = (screenX / window.innerWidth) * 2 - 1;
        mouse.y = -(screenY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const meshes = [
          ...geometryManager.points.map((p) => p.mesh),
          ...geometryManager.lines.map((l) => l.mesh),
          ...geometryManager.planes.map((p) => p.mesh),
          ...geometryManager.vectors
            .map((v) => v.arrowHelper)
            .filter(Boolean)
            .flatMap((a) => [a.line, a.cone]),
        ];

        const intersects = raycaster.intersectObjects(meshes);

        if (intersects.length > 0) {
          // Un objet est touch√©, on le s√©lectionne
          handleSelection(intersects[0].object);
        } else {
          // Aucun objet n'est touch√©, on d√©s√©lectionne tout
          deselectCurrentObject();
          cancelEdit();
          cancelVectorEdit();
        }
      }

      function handleSelection(mesh) {
        const inst = mesh.userData.instance;
        if (!inst) return;

        if (inst === selectedObjectInstance) {
          deselectCurrentObject();
          cancelEdit();
          cancelVectorEdit();
          return;
        }

        deselectCurrentObject();
        selectedObjectInstance = inst;

        // Attachement du Gizmo
        if (inst instanceof Vector) {
          if (inst.arrowHelper) transformControl.attach(inst.arrowHelper);
        } else {
          transformControl.attach(mesh);
        }
        transformControl.setMode('translate');

        // Surbrillance
        if (inst instanceof Vector) {
          inst.arrowHelper.setColor(HIGHLIGHT_COLOR);
        } else {
          mesh.material.color.set(HIGHLIGHT_COLOR);
          if (inst instanceof Plane) mesh.material.opacity = 0.75;
        }

        // Gestion de l'affichage "Transformations" selon la taille d'√©cran
        const isMobile = window.innerWidth <= 768;

        // On rend le conteneur visible (pour que le formulaire existe)
        document.getElementById("transformations-hint").style.display = "none";
        document.getElementById("transformations-container").style.display = "block";

        // MAIS on ne force le d√©pliage et le scroll QUE sur ordinateur
        if (!isMobile) {
          document.getElementById("transformations-hint").style.display = "none";
          document.getElementById("transformations-container").style.display = "block";

          // On d√©plie la section si elle est ferm√©e, mais SANS SCROLLER
          const transContainer = document.getElementById("transformations-container");
          const section = transContainer.closest(".section");
          if (section && section.classList.contains("collapsed")) {
            section.classList.remove("collapsed");
          }
        }

        // Appel de la mise √† jour du panneau (qui n'ouvrira PAS le panneau sur mobile)
        updatePanelForSelection(inst);
      }

      function deselectCurrentObject() {
        if (transformControl) {
          transformControl.detach();
        }
        if (!selectedObjectInstance) return;

        const inst = selectedObjectInstance;

        // 1. Restaurer la couleur
        if (inst instanceof Vector) {
          inst.arrowHelper.setColor(inst.color);
        } else if (inst.mesh) {
          inst.mesh.material.color.copy(inst.color);
          if (inst instanceof Plane) inst.mesh.material.opacity = 0.5;
        }

        // 2. Mettre √† jour l'√©tat
        selectedObjectInstance = null;

        // 3. Mettre √† jour l'UI (c'est la partie cruciale)
        document.getElementById("transformations-hint").style.display = "block";
        document.getElementById("transformations-container").style.display = "none";
      }

      function updatePanelForSelection(inst) {
        // D√âTECTION : Si largeur √©cran <= 768px, on consid√®re que c'est du mobile/tactile
        const isMobile = window.innerWidth <= 768;

        // Si on est sur mobile, shouldOpen sera FALSE.
        // Le panneau restera donc ferm√© gr√¢ce aux modifications ci-dessus.
        const shouldOpen = !isMobile;

        if (inst instanceof Point) {
          // On passe l'index et le bool√©en
          editPoint(geometryManager.points.indexOf(inst), shouldOpen);
        } else if (inst instanceof Vector) {
          editVector(inst.id, shouldOpen);
        } else if (inst instanceof Line3D) {
          editLine(inst.id, shouldOpen);
        } else if (inst instanceof Plane) {
          editPlane(inst.id, shouldOpen);
        }
      }

      function constructChaslesSum() {
        // 1. Nettoyer toute construction pr√©c√©dente pour repartir de z√©ro
        clearChaslesConstruction();

        // 2. R√©cup√©rer les objets s√©lectionn√©s dans l'interface
        const u = geometryManager.findVectorById(parseInt(document.getElementById("sumVectorSelect1").value));
        const v = geometryManager.findVectorById(parseInt(document.getElementById("sumVectorSelect2").value));
        const originId = document.getElementById("sumVectorOrigin").value;
        const resultDiv = document.getElementById("vectorSumResult");

        if (!u || !v || originId === "") {
          showSplashScreen("Veuillez s√©lectionner deux vecteurs et un point de d√©part pour la construction.");
          resultDiv.textContent = "S√©lection invalide.";
          return;
        }

        const pointA =
          originId === "origin"
            ? new THREE.Vector3(0, 0, 0)
            : geometryManager.points[parseInt(originId)].position.clone();

        // 3. Calculer les points cl√©s de la construction
        const pointB = new THREE.Vector3().addVectors(pointA, u.components);

        // 4. Cr√©er les objets visuels et les ajouter au suivi
        // Repr√©sentant de u (bleu)
        const u_rep = new Vector(
          geometryManager.generateUniqueName(`Rep(${u.name})`, "vector"),
          pointA,
          u.components,
          0x2196f3
        );
        geometryManager.addVector(u_rep);
        currentConstructionObjects.push(u_rep);

        // Repr√©sentant de v (rouge)
        const v_rep = new Vector(
          geometryManager.generateUniqueName(`Rep(${v.name})`, "vector"),
          pointB,
          v.components,
          0xf44336
        );
        geometryManager.addVector(v_rep);
        currentConstructionObjects.push(v_rep);

        // Vecteur somme (violet)
        const sumComponents = new THREE.Vector3().addVectors(u.components, v.components);
        const sum_vec = new Vector(
          geometryManager.generateUniqueName(`Somme(${u.name},${v.name})`, "vector"),
          pointA,
          sumComponents,
          0x8a2be2
        );
        geometryManager.addVector(sum_vec);
        currentConstructionObjects.push(sum_vec);

        // 5. Afficher le r√©sultat dans l'UI
        resultDiv.innerHTML = `Construction de Chasles effectu√©e.<br>
                               <strong>${u_rep.name} + ${v_rep.name} = ${sum_vec.name}</strong><br>
                               Composantes somme: <strong>(${formatNumber(sumComponents.x)}, ${formatNumber(
          sumComponents.y
        )}, ${formatNumber(sumComponents.z)})</strong>`;

        // 6. Mettre √† jour la sc√®ne et afficher le bouton de nettoyage
        updateAllUI();
        saveState();
        document.getElementById("clearChaslesBtn").style.display = "block";
      }

      function clearChaslesConstruction() {
        if (currentConstructionObjects.length === 0) {
          return; // Rien √† faire
        }

        // Parcourir la liste des objets suivis et les supprimer
        currentConstructionObjects.forEach((obj) => {
          if (obj instanceof Vector) {
            geometryManager.removeVector(obj);
          }
        });

        // Vider la liste de suivi
        currentConstructionObjects = [];

        // R√©initialiser l'interface
        document.getElementById("clearChaslesBtn").style.display = "none";
        document.getElementById("vectorSumResult").innerHTML = "";

        updateAllUI();
      }

      function displayPlaneEquation() {
        const s = document.getElementById("equationPlaneSelect"),
          r = document.getElementById("planeEquationDisplay");
        if (!s || !r) return;

        const pId = parseInt(s.value),
          p = geometryManager.findPlaneById(pId);
        if (!p) {
          r.innerHTML = "Aucun plan s√©lectionn√©.";
          return;
        }

        const n = p.displayNormal;
        const p0 = p.pointOnPlane;
        // La constante 'd' de l'√©quation ax+by+cz+d=0
        const d = -n.dot(p0);

        const terms = [];

        // Terme en X
        if (Math.abs(n.x) > 1e-6) {
          if (Math.abs(n.x - 1) < 1e-6) terms.push("x");
          else if (Math.abs(n.x + 1) < 1e-6) terms.push("-x");
          else terms.push(`${formatNumber(n.x, 2)}x`);
        }

        // Terme en Y (profondeur) -> utilise n.z
        if (Math.abs(n.z) > 1e-6) {
          const sign = n.z > 0 ? " + " : " - ";
          const absValue = Math.abs(n.z);
          if (absValue === 1) terms.push(`${sign}y`);
          else terms.push(`${sign}${formatNumber(absValue, 2)}y`);
        }

        // Terme en Z (hauteur) -> utilise n.y
        if (Math.abs(n.y) > 1e-6) {
          const sign = n.y > 0 ? " + " : " - ";
          const absValue = Math.abs(n.y);
          if (absValue === 1) terms.push(`${sign}z`);
          else terms.push(`${sign}${formatNumber(absValue, 2)}z`);
        }

        // Terme constant D
        if (Math.abs(d) > 1e-6) {
          const sign = d > 0 ? " + " : " - ";
          terms.push(`${sign}${formatNumber(Math.abs(d), 2)}`);
        }

        // Si tous les coefficients sont nuls
        if (terms.length === 0) {
          r.innerHTML = "<strong>0 = 0</strong>";
          return;
        }

        // On assemble l'√©quation en joignant les termes
        let equation = terms.join(" ").trim();

        // On nettoie le d√©but de la cha√Æne pour un affichage parfait
        if (equation.startsWith("+ ")) {
          // Enl√®ve le " + " initial si le premier terme est positif
          equation = equation.substring(2);
        } else if (equation.startsWith("- ")) {
          // Enl√®ve l'espace apr√®s le "-" initial si le premier terme est n√©gatif
          equation = "-" + equation.substring(2);
        }

        r.innerHTML = `<strong>${equation} = 0</strong>`;
      }

      function displayLineEquation(tempLineInstance = null) {
        const s = document.getElementById("equationLineSelect"),
          r = document.getElementById("lineEquationDisplay");
        if (!s || !r) return;

        let l;

        // Si une instance temporaire est fournie (pendant le drag), on l'utilise
        if (tempLineInstance) {
          l = tempLineInstance;
        } else {
          // Sinon, on cherche la droite s√©lectionn√©e dans le gestionnaire
          const lId = parseInt(s.value);
          l = geometryManager.findLineById(lId);
        }

        if (!l) {
          r.innerHTML = "Aucune droite s√©lectionn√©e.";
          return;
        }

        const p0 = l.startPoint;
        const v = l.directorVector;

        const formatTTerm = (coefficient) => {
          if (Math.abs(coefficient) < 1e-6) return "";
          const sign = coefficient > 0 ? " + " : " - ";
          const absValue = Math.abs(coefficient);
          if (Math.abs(absValue - 1) < 1e-6) return `${sign}t`;
          else return `${sign}${formatNumber(absValue, 2)}t`;
        };

        const eX = `x = ${formatNumber(p0.x, 2)}${formatTTerm(v.x)}`;

        // La ligne 'y' (profondeur) doit afficher les composantes Z de Three.js
        const eY = `y = ${formatNumber(p0.z, 2)}${formatTTerm(v.z)}`;
        // La ligne 'z' (hauteur) doit afficher les composantes Y de Three.js
        const eZ = `z = ${formatNumber(p0.y, 2)}${formatTTerm(v.y)}`;

        r.innerHTML = `<strong>${eX}<br>${eY}<br>${eZ}</strong>`;
      }

      function calculateVectorSumFree() {
        // Nettoyer toute construction visuelle de Chasles qui pourrait √™tre active
        clearChaslesConstruction();

        const v1 = geometryManager.findVectorById(parseInt(document.getElementById("sumVectorSelect1").value));
        const v2 = geometryManager.findVectorById(parseInt(document.getElementById("sumVectorSelect2").value));
        const r = document.getElementById("vectorSumResult");

        if (!v1 || !v2) {
          showSplashScreen("Veuillez s√©lectionner deux vecteurs.");
          r.textContent = "Veuillez s√©lectionner deux vecteurs.";
          return;
        }

        const sumComponents = new THREE.Vector3().addVectors(v1.components, v2.components);

        let sumOrigin;
        const originSelection = document.getElementById("sumVectorOrigin").value;
        let originPointName = "l'origine du rep√®re";

        if (originSelection !== "origin" && originSelection !== "") {
          const originPoint = geometryManager.points[parseInt(originSelection)];
          sumOrigin = originPoint.position.clone();
          originPointName = `point ${originPoint.name}`;
        } else {
          sumOrigin = new THREE.Vector3(0, 0, 0); // Origine par d√©faut
        }

        const baseName = `Somme(${v1.name},${v2.name})`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "vector");

        const newVector = new Vector(uniqueName, sumOrigin, sumComponents, 0x9932cc);
        geometryManager.addVector(newVector);

        const componentsText = `(${formatNumber(sumComponents.x)}, ${formatNumber(sumComponents.y)}, ${formatNumber(
          sumComponents.z
        )})`;
        const normText = formatNumber(sumComponents.length(), 3);

        r.innerHTML = `Vecteur somme "${uniqueName}" cr√©√© depuis ${originPointName}.<br>
                     Composantes: <strong>${componentsText}</strong><br>
                     Norme ‚âà <strong>${normText}</strong>`;

        updateAllUI();
        saveState();
      }

      function calculateScalarProduct() {
        const [v1, v2] = [
          geometryManager.findVectorById(parseInt(document.getElementById("dotVectorSelect1").value)),
          geometryManager.findVectorById(parseInt(document.getElementById("dotVectorSelect2").value)),
        ];
        const r = document.getElementById("scalarProductResult");

        if (!v1 || !v2) {
          r.textContent = "S√©lectionnez deux vecteurs.";
          return;
        }

        // 1. Calcul du produit scalaire
        const dP = v1.components.dot(v2.components);

        // 2. Calcul des normes
        const len1 = v1.components.length();
        const len2 = v2.components.length();
        const productLen = len1 * len2;

        let angleInfo = "";

        // 3. Calcul de l'angle et du cosinus (si les vecteurs ne sont pas nuls)
        if (productLen > 1e-9) {
          // Calcul du cosinus
          let cosTheta = dP / productLen;

          // Correction des erreurs d'arrondi flottant (ex: 1.000000002 qui ferait planter acos)
          cosTheta = Math.max(-1, Math.min(1, cosTheta));

          // Calcul de l'angle en radians puis degr√©s
          const angleRad = Math.acos(cosTheta);
          const angleDeg = angleRad * (180 / Math.PI);

          angleInfo = `<br>
                 <span style="font-size:0.9em; color:#555;">
                    cos(Œ∏) = <strong>${cosTheta.toFixed(4)}</strong><br>
                    Angle Œ∏ ‚âà <strong>${angleDeg.toFixed(2)}¬∞</strong>
                 </span>`;
        } else {
          angleInfo = `<br><span style="font-size:0.9em; color:#a00;">Angle ind√©fini (vecteur nul)</span>`;
        }

        // 4. Affichage du r√©sultat complet
        r.innerHTML = `<strong>${v1.name} ‚ãÖ ${v2.name} = ${parseFloat(dP.toFixed(4))}</strong>${angleInfo}`;
      }

      function calculateVectorProduct() {
        const [v1, v2] = [
          geometryManager.findVectorById(parseInt(document.getElementById("crossVectorSelect1").value)),
          geometryManager.findVectorById(parseInt(document.getElementById("crossVectorSelect2").value)),
        ];
        const r = document.getElementById("vectorProductResult");

        if (!v1 || !v2) {
          showSplashScreen("S√©lectionnez deux vecteurs.");
          r.textContent = "Veuillez s√©lectionner deux vecteurs.";
          return;
        }

        let o = new THREE.Vector3(0, 0, 0);
        const oS = document.getElementById("crossVectorOrigin").value;
        if (oS !== "origin" && oS !== "") {
          o = geometryManager.points[parseInt(oS)].position;
        }
        const rC = new THREE.Vector3().crossVectors(v1.components, v2.components);

        const baseName = `ProduitVect(${v1.name},${v2.name})`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "vector");

        const newVector = new Vector(uniqueName, o, rC, 0x4682b4);
        geometryManager.addVector(newVector);

        // --- NOUVELLE MISE EN FORME HTML (SIMPLE ET ALIGN√âE √Ä GAUCHE) ---
        const componentsText = `(${formatNumber(rC.x)}, ${formatNumber(rC.y)}, ${formatNumber(rC.z)})`;
        const normText = formatNumber(rC.length(), 3);

        r.innerHTML = `Vecteur "${uniqueName}" cr√©√©<br>
                     Composantes: <strong>${componentsText}</strong><br>
                     Norme ‚âà <strong>${normText}</strong>`;
        // --- FIN DE LA MODIFICATION ---

        updateAllUI();
        saveState();
      }

      function calculatePointPointDistance() {
        const [i1, i2] = [
          document.getElementById("distPointSelect1").value,
          document.getElementById("distPointSelect2").value,
        ];
        if (i1 === "" || i2 === "") return;
        const p1 = geometryManager.points[i1],
          p2 = geometryManager.points[i2];
        const d = p1.position.distanceTo(p2.position);
        document.getElementById("distResult1").innerHTML = `Dist(${p1.name},${p2.name}) = <strong>${d.toFixed(
          3
        )}</strong>`;
      }

      function calculatePointLineDistance() {
        const pI = document.getElementById("distPointSelect3").value,
          lI = document.getElementById("distLineSelect1").value;
        if (pI === "" || lI === "") return;
        const p = geometryManager.points[pI],
          l = geometryManager.findLineById(parseInt(lI));

        // --- CORRECTION APPLIQU√âE ---
        const lineMath = new THREE.Line3(
          l.startPoint.clone().add(l.directorVector.clone().normalize().multiplyScalar(-1000)),
          l.startPoint.clone().add(l.directorVector.clone().normalize().multiplyScalar(1000))
        );
        const closestPoint = new THREE.Vector3();
        lineMath.closestPointToPoint(p.position, true, closestPoint);
        const d = p.position.distanceTo(closestPoint);
        // --- FIN DE LA CORRECTION ---

        document.getElementById("distResult2").innerHTML = `Dist(${p.name}, ${l.name}) = <strong>${d.toFixed(
          3
        )}</strong>`;
      }

      function calculatePointPlaneDistance() {
        const pI = document.getElementById("calcPointSelect").value,
          plId = parseInt(document.getElementById("calcPlaneSelect1").value);
        const r = document.getElementById("calcResultDisplay1"); // CORRECTED ID
        if (pI === "" || isNaN(plId)) {
          r.textContent = "S√©lectionnez un point et un plan.";
          return;
        }
        const pt = geometryManager.points[pI],
          pl = geometryManager.findPlaneById(plId);
        const vP0P = new THREE.Vector3().subVectors(pt.position, pl.pointOnPlane);
        const d = Math.abs(vP0P.dot(pl.normal));
        r.innerHTML = `Distance = <strong>${d.toFixed(3)}</strong>`;
      }

      function calculateLineLineAngle() {
        const [l1, l2] = [
          geometryManager.findLineById(parseInt(document.getElementById("angleLineSelect1").value)),
          geometryManager.findLineById(parseInt(document.getElementById("angleLineSelect2").value)),
        ];
        const r = document.getElementById("angleResult1");
        if (!l1 || !l2) {
          r.textContent = "S√©lectionnez deux droites.";
          return;
        }
        let a = (l1.directorVector.angleTo(l2.directorVector) * 180) / Math.PI;
        if (a > 90) a = 180 - a;
        r.innerHTML = `Angle ‚âà <strong>${a.toFixed(2)}¬∞</strong>`;
      }

      function calculatePlanePlaneAngle() {
        const [p1, p2] = [
          geometryManager.findPlaneById(parseInt(document.getElementById("anglePlaneSelect1").value)),
          geometryManager.findPlaneById(parseInt(document.getElementById("anglePlaneSelect2").value)),
        ];
        const r = document.getElementById("angleResult2");
        if (!p1 || !p2) {
          r.textContent = "S√©lectionnez deux plans.";
          return;
        }
        let a = (p1.normal.angleTo(p2.normal) * 180) / Math.PI;
        if (a > 90) a = 180 - a;
        r.innerHTML = `Angle ‚âà <strong>${a.toFixed(2)}¬∞</strong>`;
      }

      function calculateLinePlaneAngle() {
        const l = geometryManager.findLineById(parseInt(document.getElementById("angleLineSelect3").value)),
          p = geometryManager.findPlaneById(parseInt(document.getElementById("anglePlaneSelect3").value));

        const r = document.getElementById("angleResult3");
        if (!l || !p) {
          r.textContent = "S√©lectionnez une droite et un plan.";
          return;
        }
        const dot = Math.abs(l.directorVector.clone().normalize().dot(p.normal));
        const a = (Math.asin(dot) * 180) / Math.PI;
        r.innerHTML = `Angle ‚âà <strong>${a.toFixed(2)}¬∞</strong>`;
      }

      function calculateLinePlaneIntersection() {
        console.log("calculateLinePlaneIntersection1");
        // 1. R√©cup√©ration des √©l√©ments UI (inchang√©)
        const lineSelect = document.getElementById("calcLineSelect");
        const planeSelect = document.getElementById("calcPlaneSelect2");
        const resultDisplay = document.getElementById("calcResultDisplay2");

        if (!lineSelect || !planeSelect || !resultDisplay) {
          console.error("IDs de s√©lection pour le calcul d'intersection non trouv√©s.");
          return;
        }

        // 2. R√©cup√©ration des objets g√©om√©triques (inchang√©)
        const line = geometryManager.findLineById(parseInt(lineSelect.value));
        const plane = geometryManager.findPlaneById(parseInt(planeSelect.value));

        if (!line || !plane) {
          resultDisplay.innerHTML = "Veuillez s√©lectionner une droite et un plan valides.";
          return;
        }

        // 3. Calcul de l'intersection (inchang√©)
        const p0 = line.startPoint;
        const v = line.directorVector;
        const planePoint = plane.pointOnPlane;
        const n = plane.displayNormal;
        const dotNV = n.dot(v);

        if (Math.abs(dotNV) < 1e-6) {
          const pointIsOnPlane = Math.abs(n.dot(new THREE.Vector3().subVectors(p0, planePoint))) < 1e-6;
          if (pointIsOnPlane) {
            resultDisplay.innerHTML = "La droite est contenue dans le plan (infinit√© d'intersections).";
          } else {
            resultDisplay.innerHTML = "La droite est parall√®le au plan (aucune intersection).";
          }
          return;
        }

        const t = n.dot(new THREE.Vector3().subVectors(planePoint, p0)) / dotNV;
        const intersectionPoint = new THREE.Vector3().copy(p0).addScaledVector(v, t);

        // --- D√âBUT DE LA MODIFICATION ---
        // On applique VOTRE fonction formatNumber aux r√©sultats du calcul

        // 4. Formatage des coordonn√©es pour l'affichage et la saisie
        const formattedX = formatNumber(intersectionPoint.x);
        const formattedY_UI = formatNumber(intersectionPoint.z); // Le Z de Three.js est le Y de l'UI (profondeur)
        const formattedZ_UI = formatNumber(intersectionPoint.y); // Le Y de Three.js est le Z de l'UI (hauteur)

        // 5. Remplissage des champs de saisie avec les valeurs format√©es
        const pointNameInput = document.getElementById("pointName");
        const pointXInput = document.getElementById("pointX");
        const pointYInput = document.getElementById("pointY");
        const pointZInput = document.getElementById("pointZ");

        const baseName = `Intersect(${line.name},${plane.name})`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "point");

        pointNameInput.value = uniqueName;
        pointXInput.value = formattedX;
        pointYInput.value = formattedY_UI;
        pointZInput.value = formattedZ_UI;

        // 6. Affichage du r√©sultat format√© dans la bo√Æte de dialogue
        const displayCoords = `(${formattedX}, ${formattedY_UI}, ${formattedZ_UI})`;

        resultDisplay.innerHTML = `Coordonn√©es ins√©r√©es dans la section 'Ajouter un point'.<br>
                               Nom sugg√©r√© : <strong>${uniqueName}</strong><br>
                               Coordonn√©es calcul√©es : <strong>${displayCoords}</strong>`;

        // --- FIN DE LA MODIFICATION ---
      }

      function calculatePlanePlaneIntersection() {
        console.log("calculatePlanePlaneIntersection");
        const plane1Id = parseInt(document.getElementById("calcPlaneSelect3").value); // CORRECTED ID
        const plane2Id = parseInt(document.getElementById("calcPlaneSelect4").value); // CORRECTED ID
        const r = document.getElementById("calcResultDisplay3");

        const p1 = geometryManager.findPlaneById(plane1Id);
        const p2 = geometryManager.findPlaneById(plane2Id);

        if (!p1 || !p2) {
          r.textContent = "Veuillez s√©lectionner deux plans distincts.";
          return;
        }

        const n1 = p1.normal;
        const n2 = p2.normal;
        const lineDirection = new THREE.Vector3().crossVectors(n1, n2);

        if (lineDirection.lengthSq() < 1e-8) {
          const vec_p1_p2 = new THREE.Vector3().subVectors(p1.pointOnPlane, p2.pointOnPlane);
          if (Math.abs(vec_p1_p2.dot(n2)) < 1e-6) {
            r.textContent = "Les plans sont confondus.";
          } else {
            r.textContent = "Les plans sont parall√®les et distincts.";
          }
          return;
        }

        let linePoint;
        const d1 = n1.dot(p1.pointOnPlane);
        const d2 = n2.dot(p2.pointOnPlane);
        const absDir = new THREE.Vector3(
          Math.abs(lineDirection.x),
          Math.abs(lineDirection.y),
          Math.abs(lineDirection.z)
        );

        try {
          if (absDir.z > absDir.x && absDir.z > absDir.y) {
            const det = n1.x * n2.y - n2.x * n1.y;
            const x = (n2.y * d1 - n1.y * d2) / det;
            const y = (n1.x * d2 - n2.x * d1) / det;
            linePoint = new THREE.Vector3(x, y, 0);
          } else if (absDir.y > absDir.x) {
            const det = n1.x * n2.z - n2.x * n1.z;
            const x = (n2.z * d1 - n1.z * d2) / det;
            const z = (n1.x * d2 - n2.x * d1) / det;
            linePoint = new THREE.Vector3(x, 0, z);
          } else {
            const det = n1.y * n2.z - n1.z * n2.y; // CORRECTION
            const y = (n2.z * d1 - n1.z * d2) / det;
            const z = (n1.y * d2 - n2.y * d1) / det;
            linePoint = new THREE.Vector3(0, y, z);
          }
        } catch (error) {
          r.textContent = "Erreur num√©rique. Plans quasi parall√®les ?";
          return;
        }

        if (isNaN(linePoint.x)) {
          r.textContent = "Calcul impossible (division par z√©ro).";
          return;
        }

        const baseName = `Intersect(${p1.name}, ${p2.name})`;
        const lineName = geometryManager.generateUniqueName(baseName, "line");
        const newLine = new Line3D(lineName, linePoint, lineDirection, 0xff1493);
        geometryManager.addLine(newLine);
        r.textContent = `Droite d'intersection "${lineName}" cr√©√©e.`;
        updateAllUI();
        saveState();
      }

      function calculateLineLineIntersection() {
        const line1Id = parseInt(document.getElementById("calcLineSelect1").value); // CORRECTED ID
        const line2Id = parseInt(document.getElementById("calcLineSelect2").value); // CORRECTED ID
        const r = document.getElementById("calcResultDisplay4");

        const d1 = geometryManager.findLineById(line1Id);
        const d2 = geometryManager.findLineById(line2Id);

        if (!d1 || !d2) {
          r.textContent = "Veuillez s√©lectionner deux droites distinctes.";
          return;
        }

        const p1 = d1.startPoint,
          v1 = d1.directorVector.clone().normalize();
        const p2 = d2.startPoint,
          v2 = d2.directorVector.clone().normalize();

        const v1_cross_v2 = new THREE.Vector3().crossVectors(v1, v2);
        const p1_minus_p2 = new THREE.Vector3().subVectors(p1, p2);

        if (v1_cross_v2.lengthSq() < 1e-8) {
          if (p1_minus_p2.clone().cross(v1).lengthSq() < 1e-8) {
            r.textContent = "Droites colin√©aires (confondues).";
          } else {
            r.textContent = "Droites parall√®les et distinctes.";
          }
          return;
        }

        const mixedProduct = p1_minus_p2.dot(v1_cross_v2);

        if (Math.abs(mixedProduct) < 1e-6) {
          const p2_minus_p1 = p1_minus_p2.clone().negate();
          const v2_cross_p2p1 = new THREE.Vector3().crossVectors(v2, p2_minus_p1);
          const t = v2_cross_p2p1.dot(v1_cross_v2) / v1_cross_v2.lengthSq();
          const intersectionPoint = p1.clone().add(v1.clone().multiplyScalar(t));
          const baseName = `Intersect(${d1.name}, ${d2.name})`;
          const pointName = geometryManager.generateUniqueName(baseName, "point");
          const newPoint = new Point(
            pointName,
            intersectionPoint.x,
            intersectionPoint.y,
            intersectionPoint.z,
            0x00ff00
          );
          geometryManager.addPoint(newPoint);
          r.innerHTML = `Droites s√©cantes.<br>Point "${pointName}" cr√©√©.`;
          updateAllUI();
          saveState();
        } else {
          const distance = Math.abs(mixedProduct) / v1_cross_v2.length();
          r.innerHTML = `Droites non-coplanaires.<br>Distance min ‚âà <strong>${distance.toFixed(3)}</strong>.`;
        }
      }

      // =====================================================================================
      // SECTION 8 : CONTR√îLE CAM√âRA ET FONCTIONS UTILITAIRES
      // =====================================================================================

      function expandSectionAndScrollToItem(itemId, listId) {
        const listElement = document.getElementById(listId);
        if (!listElement) return;

        // 1. Trouver la section parente et la d√©plier si elle est ferm√©e
        const section = listElement.closest(".section.collapsible");
        if (section && section.classList.contains("collapsed")) {
          section.classList.remove("collapsed");
        }

        // 2. On ne fait PLUS d√©filer la page.
        // La ligne suivante est supprim√©e :
        // itemElement.scrollIntoView({ behavior: "smooth", block: "center" });
      }

      function togglePanel() {
        const p = document.getElementById("panel"),
          o = document.getElementById("openBtn");
        panelOpen = !panelOpen;
        p.classList.toggle("hidden", !panelOpen);
        o.classList.toggle("show", !panelOpen);
      }

      function ensurePanelVisible() {
        // La variable globale 'panelOpen' nous indique l'√©tat actuel du panneau.
        if (!panelOpen) {
          // Si le panneau n'est pas ouvert, on appelle la fonction existante pour l'ouvrir.
          togglePanel();
        }
      }

      function addFixedTestPoints() {
        const pts = [
          { n: "A", x: 2, y: 0, z: 0 },
          { n: "B", x: 0, y: 3, z: 0 },
          { n: "C", x: 0, y: 0, z: 4 },
        ];
        pts.forEach((p) => {
          if (!geometryManager.points.some((gp) => gp.name === p.n))
            geometryManager.addPoint(new Point(p.n, p.x, p.y, p.z));
        });
        updateAllUI();
        saveState();
      }

      function toggleAutoLoadTestPoints() {
        const c = document.getElementById("autoLoadTestPointsCheckbox");
        localStorage.setItem("autoLoadTestPoints", c.checked);
      }

      function loadTestPointsOnce() {
        addFixedTestPoints();
      }

      function updateCameraPosition() {
        camera.position.x = cameraTarget.x + cameraDistance * Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x);
        camera.position.y = cameraTarget.y + cameraDistance * Math.sin(cameraRotation.x);
        camera.position.z = cameraTarget.z + cameraDistance * Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x);
        camera.lookAt(cameraTarget);
      }

      function onMouseDown(e) {
        if (isGizmoDragging) return; // <--- AJOUT IMPORTANT
        wasDragged = false;
        if (e.target.closest("#cameraControls")) return;
        if (e.button === 0) isDragging = true;
        else if (e.button === 2) isPanning = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
      }

      function onMouseMove(e) {
        if (isGizmoDragging) return;
        lastTooltipX = e.clientX;
        lastTooltipY = e.clientY;
        const dX = e.clientX - previousMousePosition.x,
          dY = e.clientY - previousMousePosition.y;
        if (isDragging || isPanning) if (Math.abs(dX) > 3 || Math.abs(dY) > 3) wasDragged = true;
        if (isDragging) {
          cameraRotation.y += dX * 0.005;
          cameraRotation.x += dY * 0.005;
          cameraRotation.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraRotation.x));
          updateCameraPosition();
        } else if (isPanning) panCamera(dX, dY);
        previousMousePosition = { x: e.clientX, y: e.clientY };
        if (!isDragging && !isPanning) {
          handleHover(e.clientX, e.clientY);
        }
      }

      function onMouseUp() {
        isDragging = false;
        isPanning = false;
      }

      function onWheel(e) {
        e.preventDefault();
        zoomCamera(e.deltaY * 0.01);
      }

      function panCamera(dX, dY) {
        // Vitesse dynamique : plus on est loin, plus √ßa bouge vite
        // 0.002 est un facteur de sensibilit√© (ajustable)
        const speed = cameraDistance * 0.002;

        const r = new THREE.Vector3();
        camera.getWorldDirection(r);

        const u = camera.up.clone();

        // Produit vectoriel pour avoir la droite/gauche par rapport √† la vue
        r.cross(u).normalize();

        // D√©placement du point cible (Target)
        // Note : On inverse dX pour que le mouvement suive le doigt
        cameraTarget.addScaledVector(r, -dX * speed);
        cameraTarget.addScaledVector(u, dY * speed);

        updateCameraPosition();
      }

      function zoomCamera(d) {
        cameraDistance = Math.max(3, Math.min(50, cameraDistance + d));
        updateCameraPosition();
      }

      function resetCamera(btn) {
        setCameraView("isometric", btn);
      }

      function setCameraView(v, btn) {
        cameraTarget.set(0, 0, 0);
        cameraDistance = 15;
        switch (v) {
          case "top": // Vue de dessus (regarde le plan XY de l'utilisateur, donc XZ interne)
            cameraRotation.x = Math.PI / 2 - 0.001;
            cameraRotation.y = 0;
            break;
          case "front": // Vue de face (regarde le plan XZ de l'utilisateur, donc XY interne)
            cameraRotation.x = 0;
            cameraRotation.y = Math.PI / 2; // On tourne la cam√©ra pour voir le plan XY interne
            break;
          case "side": // Vue de c√¥t√© (regarde le plan YZ de l'utilisateur, donc YZ interne)
            cameraRotation.x = 0;
            cameraRotation.y = 0;
            break;
          default: // Vue isom√©trique
            cameraRotation.x = 0.5;
            cameraRotation.y = 0.5;
        }
        updateCameraPosition();
        toggleButtonState(btn);
      }

      function toggleButtonState(btn) {
        document.querySelectorAll("#cameraControls .camera-btn").forEach((b) => b.classList.remove("active"));
        if (btn) btn.classList.add("active");
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      document.addEventListener("DOMContentLoaded", () => {
        document.querySelectorAll(".section-header").forEach((header) => {
          header.addEventListener("click", () => header.closest(".section").classList.toggle("collapsed"));
        });
        init();
        const resetBtn = document.getElementById("btnReset");
        resetCamera(resetBtn);
      });

      function applyTranslation() {
        if (!selectedObjectInstance) {
          showSplashScreen("Aucun objet n'est s√©lectionn√©.");
          return;
        }

        // 1. R√©cup√©ration des valeurs de l'interface
        const dx = parseFloat(document.getElementById("transX").value) || 0;
        const dy_ui = parseFloat(document.getElementById("transY").value) || 0; // L'utilisateur pense "Y" (Profondeur)
        const dz_ui = parseFloat(document.getElementById("transZ").value) || 0; // L'utilisateur pense "Z" (Hauteur)

        // 2. CORRECTION DE L'AXE : Conversion vers le rep√®re Three.js
        // Three.js X = UI X
        // Three.js Y (Vertical) = UI Z (Hauteur)
        // Three.js Z (Profondeur) = UI Y (Profondeur)
        const translationVector = new THREE.Vector3(dx, dz_ui, dy_ui);

        const inst = selectedObjectInstance;

        // 3. Application de la translation selon le type d'objet
        if (inst instanceof Point) {
          const newPos = inst.position.clone().add(translationVector);
          // Note : update() attend (nom, x, z, y) car elle refait la conversion en interne,
          // mais ici on manipule directement des positions Three.js, donc on passe x, y, z du vecteur position
          // C'est une petite subtilit√© : on met √† jour la position brute.
          inst.position.copy(newPos);
          inst.mesh.position.copy(inst.position);
          inst.updateLabelPosition();
        } else if (inst instanceof Vector) {
          const newOrigin = inst.origin.clone().add(translationVector);
          // Pour le vecteur, on met √† jour l'origine, les composantes ne changent pas
          inst.update(inst.name, newOrigin, inst.components);
        } else if (inst instanceof Plane) {
          inst.pointOnPlane.add(translationVector);
          inst.mesh.position.copy(inst.pointOnPlane);
        } else if (inst instanceof Line3D) {
          // D√©placer le point de d√©part
          inst.startPoint.add(translationVector);

          // Recalculer la g√©om√©trie visuelle
          const lineLength = 100;
          const dir = inst.directorVector.clone().normalize();
          const start = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(-lineLength));
          const end = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(lineLength));

          // Mise √† jour propre de la g√©om√©trie
          inst.mesh.geometry.dispose(); // Nettoyage m√©moire
          inst.mesh.geometry = new THREE.BufferGeometry().setFromPoints([start, end]);

          // R√©initialiser la couleur si n√©cessaire (garde la s√©lection active visuellement)
          if (inst === selectedObjectInstance) {
            inst.mesh.material.color.set(HIGHLIGHT_COLOR);
          }
        }

        // 4. Mise √† jour de l'interface (notamment les coordonn√©es dans la liste)
        updateAllUI();
        saveState();
      }

      function applyRotation() {
        if (!selectedObjectInstance) {
          showSplashScreen("Aucun objet n'est s√©lectionn√©.");
          return;
        }

        // 1. R√©cup√©ration de l'angle
        const angleDeg = parseFloat(document.getElementById("rotationAngle").value) || 0;
        const angleRad = (angleDeg * Math.PI) / 180;

        // 2. R√©cup√©ration et correction de l'Axe
        const axisSelect = document.getElementById("rotationAxisSelect");
        const axisValue = axisSelect.value.toLowerCase().trim(); // S√©curit√© contre les majuscules/espaces

        let rotationAxis;

        // --- C'EST ICI QUE SE JOUE LA CORRECTION ---
        if (axisValue === "x") {
          // Axe X (Rouge) : Ne change pas
          rotationAxis = new THREE.Vector3(1, 0, 0);
        } else if (axisValue === "y") {
          // L'utilisateur choisit "Axe Y" (Profondeur dans votre interface)
          // Cela correspond √† l'axe Z de Three.js (L'axe BLEU)
          rotationAxis = new THREE.Vector3(0, 0, 1);
        } else {
          // L'utilisateur choisit "Axe Z" (Hauteur/Verticale)
          // Cela correspond √† l'axe Y de Three.js (L'axe VERT)
          rotationAxis = new THREE.Vector3(0, 1, 0);
        }

        // 3. R√©cup√©ration du centre de rotation
        const centerValue = document.getElementById("rotationCenterSelect").value;
        const centerOfRotation =
          centerValue === "origin"
            ? new THREE.Vector3(0, 0, 0)
            : geometryManager.points[parseInt(centerValue)].position.clone();

        const inst = selectedObjectInstance;

        // Helper : Appliquer la rotation math√©matique √† un point
        const rotatePoint = (p, c) => {
          p.sub(c); // Ramener au centre relatif
          p.applyAxisAngle(rotationAxis, angleRad); // Tourner
          p.add(c); // Remettre √† la position absolue
        };

        // 4. Application de la rotation selon le type d'objet
        if (inst instanceof Point) {
          const newPos = inst.position.clone();
          rotatePoint(newPos, centerOfRotation);

          // Mise √† jour directe des positions Three.js
          inst.position.copy(newPos);
          inst.mesh.position.copy(inst.position);
          inst.updateLabelPosition();
        } else if (inst instanceof Vector) {
          const newOrigin = inst.origin.clone();
          rotatePoint(newOrigin, centerOfRotation);

          // Le vecteur lui-m√™me (ses composantes) tourne aussi
          const newComponents = inst.components.clone().applyAxisAngle(rotationAxis, angleRad);

          inst.update(inst.name, newOrigin, newComponents);
        } else if (inst instanceof Plane) {
          rotatePoint(inst.pointOnPlane, centerOfRotation);

          // La normale du plan tourne aussi
          inst.normal.applyAxisAngle(rotationAxis, angleRad);
          inst.displayNormal.applyAxisAngle(rotationAxis, angleRad);

          inst.mesh.position.copy(inst.pointOnPlane);
          inst.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), inst.normal.clone().normalize());
        } else if (inst instanceof Line3D) {
          rotatePoint(inst.startPoint, centerOfRotation);
          inst.directorVector.applyAxisAngle(rotationAxis, angleRad);

          // Recalcul g√©om√©trie (identique au fix de translation)
          const lineLength = 100;
          const dir = inst.directorVector.clone().normalize();
          const start = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(-lineLength));
          const end = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(lineLength));

          inst.mesh.geometry.dispose();
          inst.mesh.geometry = new THREE.BufferGeometry().setFromPoints([start, end]);

          // Conserver la couleur de s√©lection
          if (inst === selectedObjectInstance) {
            inst.mesh.material.color.set(HIGHLIGHT_COLOR);
          }
        }

        updateAllUI();
        saveState();
      }

      function updateSymmetryUI() {
        const type = document.getElementById("symmetryTypeSelect").value;
        const container = document.getElementById("symmetryOptionsContainer");
        const applyBtn = document.getElementById("applySymmetryBtn");
        container.innerHTML = ""; // Vider les anciennes options

        if (!type) {
          applyBtn.style.display = "none";
          return;
        }

        // Liste des types qui n√©cessitent une s√©lection d'objet dans la sc√®ne
        const needsSelection = ["point", "line", "plane"];

        if (!needsSelection.includes(type)) {
          // CAS 1 : Sym√©trie "Fixe" (Origine, Axes, Plans principaux)
          // Pas de menu secondaire, on affiche juste le bouton
          container.innerHTML = `<p style="font-size:11px; color:#666; margin:5px 0;">Sym√©trie standard s√©lectionn√©e.</p>`;
          applyBtn.style.display = "block";
          return;
        }

        // CAS 2 : Sym√©trie par rapport √† un objet existant (Code existant)
        let selectHTML = `<label>R√©f√©rence :</label><select id="symmetryRefSelect" style="width: 100%;">`;
        let hasOptions = false;

        if (type === "point") {
          if (geometryManager.points.length > 0) {
            geometryManager.points.forEach((p, i) => {
              selectHTML += `<option value="${i}">${p.name}</option>`;
            });
            hasOptions = true;
          } else {
            selectHTML += `<option value="">Aucun point disponible</option>`;
          }
        } else if (type === "line") {
          if (geometryManager.lines.length > 0) {
            geometryManager.lines.forEach((l) => {
              selectHTML += `<option value="${l.id}">${l.name}</option>`;
            });
            hasOptions = true;
          } else {
            selectHTML += `<option value="">Aucune droite disponible</option>`;
          }
        } else if (type === "plane") {
          if (geometryManager.planes.length > 0) {
            geometryManager.planes.forEach((p) => {
              selectHTML += `<option value="${p.id}">${p.name}</option>`;
            });
            hasOptions = true;
          } else {
            selectHTML += `<option value="">Aucun plan disponible</option>`;
          }
        }

        selectHTML += `</select>`;
        container.innerHTML = selectHTML;
        applyBtn.style.display = hasOptions ? "block" : "none";
      }

      function applySymmetry() {
        if (!selectedObjectInstance) {
          showSplashScreen("Aucun objet n'est s√©lectionn√©.");
          return;
        }

        const type = document.getElementById("symmetryTypeSelect").value;
        let refObject = null;

        // Gestion des types n√©cessitant une r√©f√©rence
        if (["point", "line", "plane"].includes(type)) {
          const refId = document.getElementById("symmetryRefSelect").value;
          if (!refId) return;
          if (type === "point") refObject = geometryManager.points[parseInt(refId)];
          else if (type === "line") refObject = geometryManager.findLineById(parseInt(refId));
          else if (type === "plane") refObject = geometryManager.findPlaneById(parseInt(refId));
        }

        // --- FONCTION DE TRANSFORMATION UNIFI√âE ---
        // Cette fonction prend un Vector3 (position) et renvoie le nouveau Vector3 transform√©
        const transformVector = (v) => {
          const p = v.clone();

          switch (type) {
            // --- CAS STANDARD (Fixes) ---
            case "origin":
              return p.negate(); // (-x, -y, -z)

            case "axis_x": // Sym√©trie axe X : on garde X, on inverse le reste
              return new THREE.Vector3(p.x, -p.y, -p.z);

            case "axis_y": // UI Axe Y (Profondeur) -> ThreeJS Axe Z. On garde Z, on inverse X et Y(hauteur)
              return new THREE.Vector3(-p.x, -p.y, p.z);

            case "axis_z": // UI Axe Z (Hauteur) -> ThreeJS Axe Y. On garde Y, on inverse X et Z
              return new THREE.Vector3(-p.x, p.y, -p.z);

            case "plane_xy": // UI Plan XY (Sol) -> On inverse la Hauteur (ThreeJS Y)
              return new THREE.Vector3(p.x, -p.y, p.z);

            case "plane_xz": // UI Plan XZ (Face) -> On inverse la Profondeur (ThreeJS Z)
              return new THREE.Vector3(p.x, p.y, -p.z);

            case "plane_yz": // UI Plan YZ (C√¥t√©) -> On inverse X
              return new THREE.Vector3(-p.x, p.y, p.z);

            // --- CAS AVANC√âS (Objets de r√©f√©rence) ---
            case "point":
              // p' = center - (p - center) = 2*center - p
              return refObject.position.clone().multiplyScalar(2).sub(p);

            case "line":
              const lineStart = refObject.startPoint;
              const lineDir = refObject.directorVector.clone().normalize();
              const vStartToP = new THREE.Vector3().subVectors(p, lineStart);
              const projection = lineDir.multiplyScalar(vStartToP.dot(lineDir));
              const projectedPoint = new THREE.Vector3().addVectors(lineStart, projection);
              // p' = proj - (p - proj) = 2*proj - p
              return projectedPoint.multiplyScalar(2).sub(p);

            case "plane":
              const vP0P = new THREE.Vector3().subVectors(p, refObject.pointOnPlane);
              const dist = vP0P.dot(refObject.normal); // Distance sign√©e
              // p' = p - 2 * dist * normal
              return p.clone().addScaledVector(refObject.normal, -2 * dist);

            default:
              return p;
          }
        };

        // --- APPLICATION DE LA TRANSFORMATION √Ä L'OBJET S√âLECTIONN√â ---
        const inst = selectedObjectInstance;

        if (inst instanceof Point) {
          const newPos = transformVector(inst.position);
          inst.update(inst.name, newPos.x, newPos.y, newPos.z); // Note: update g√®re l'inversion Y/Z interne si on passe des coords brutes, ici on passe x,y,z du vecteur ThreeJS, donc attention.
          // CORRECTION POUR POINT : update() prend (x, y_ui, z_ui).
          // Si on a un vecteur ThreeJS (x, y_3js, z_3js), y_ui = z_3js et z_ui = y_3js.
          // MAIS votre classe Point stocke directement new THREE.Vector3(x, y, z).
          // La m√©thode update() fait : this.position.set(x, y, z).
          // Donc on peut simplement faire :
          inst.position.copy(newPos);
          inst.mesh.position.copy(inst.position);
          inst.updateLabelPosition();
        } else if (inst instanceof Vector) {
          const newOrigin = transformVector(inst.origin);
          const endPoint = new THREE.Vector3().addVectors(inst.origin, inst.components);
          const newEndPoint = transformVector(endPoint);
          const newComponents = new THREE.Vector3().subVectors(newEndPoint, newOrigin);

          inst.update(inst.name, newOrigin, newComponents);
        } else if (inst instanceof Line3D) {
          const newStart = transformVector(inst.startPoint);
          // Pour le vecteur directeur, on transforme le point "start + dir" et on soustrait le nouveau start
          const endPoint = new THREE.Vector3().addVectors(inst.startPoint, inst.directorVector);
          const newEnd = transformVector(endPoint);
          const newDir = new THREE.Vector3().subVectors(newEnd, newStart);

          // Mise √† jour manuelle (similaire √† translation/rotation)
          inst.startPoint.copy(newStart);
          inst.directorVector.copy(newDir);

          const lineLength = 100;
          const dir = inst.directorVector.clone().normalize();
          const start = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(-lineLength));
          const end = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(lineLength));

          inst.mesh.geometry.dispose();
          inst.mesh.geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
          if (inst === selectedObjectInstance) inst.mesh.material.color.set(HIGHLIGHT_COLOR);
        } else if (inst instanceof Plane) {
          // Transformation du point d'ancrage
          const newPointOnPlane = transformVector(inst.pointOnPlane);

          // Transformation de la normale : on transforme (point + normal) et on soustrait le nouveau point
          const pointPlusNormal = new THREE.Vector3().addVectors(inst.pointOnPlane, inst.normal);
          const newPointPlusNormal = transformVector(pointPlusNormal);
          const newNormal = new THREE.Vector3().subVectors(newPointPlusNormal, newPointOnPlane).normalize();

          inst.pointOnPlane.copy(newPointOnPlane);
          inst.normal.copy(newNormal);
          inst.displayNormal.copy(newNormal);

          inst.mesh.position.copy(inst.pointOnPlane);
          inst.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), inst.normal);
        }

        updateAllUI();
        saveState();
      }

      function saveScene() {
        const sceneName = document.getElementById("sceneNameInput").value.trim();
        if (!sceneName) {
          showSplashScreen("Veuillez donner un nom √† votre sc√®ne.");
          return;
        }
        // 1. S√©rialiser la g√©om√©trie actuelle
        const sceneData = {
          name: sceneName,
          timestamp: new Date().toISOString(),
          geometry: {
            points: geometryManager.points.map((p) => ({
              name: p.name,
              position: { x: p.position.x, y: p.position.y, z: p.position.z },
            })),
            vectors: geometryManager.vectors.map((v) => ({
              id: v.id,
              name: v.name,
              origin: { x: v.origin.x, y: v.origin.y, z: v.origin.z },
              components: { x: v.components.x, y: v.components.y, z: v.components.z },
              isLabelVisible: v.isLabelVisible,
            })),
            lines: geometryManager.lines.map((l) => ({
              id: l.id,
              name: l.name,
              startPoint: { x: l.startPoint.x, y: l.startPoint.y, z: l.startPoint.z },
              directorVector: { x: l.directorVector.x, y: l.directorVector.y, z: l.directorVector.z },
            })),
            planes: geometryManager.planes.map((p) => ({
              id: p.id,
              name: p.name,
              pointOnPlane: { x: p.pointOnPlane.x, y: p.pointOnPlane.y, z: p.pointOnPlane.z },
              displayNormal: { x: p.displayNormal.x, y: p.displayNormal.y, z: p.displayNormal.z },
            })),
          },
        };

        // 2. G√©rer le stockage
        let savedScenes = JSON.parse(localStorage.getItem("savedScenes")) || [];

        // V√©rifier si une sc√®ne avec le m√™me nom existe d√©j√†
        const existingSceneIndex = savedScenes.findIndex((s) => s.name === sceneName);
        if (existingSceneIndex > -1) {
          if (confirm(`Une sc√®ne nomm√©e "${sceneName}" existe d√©j√†. Voulez-vous la remplacer ?`)) {
            savedScenes[existingSceneIndex] = sceneData;
          } else {
            return; // L'utilisateur a annul√©
          }
        } else {
          savedScenes.push(sceneData);
        }

        // 3. Sauvegarder dans localStorage
        localStorage.setItem("savedScenes", JSON.stringify(savedScenes));
        showSplashScreen(`‚úÖ Sc√®ne "${sceneName}" enregistr√©e !`);

        // 4. Mettre √† jour la liste des sc√®nes chargeables
        populateSavedScenesSelect();
      }

      function loadScene() {
        const sceneName = document.getElementById("savedScenesSelect").value;
        if (!sceneName) {
          showSplashScreen("Veuillez s√©lectionner une sc√®ne √† charger.");
          return;
        }

        const savedScenes = JSON.parse(localStorage.getItem("savedScenes")) || [];
        const sceneData = savedScenes.find((s) => s.name === sceneName);

        if (!sceneData) {
          showSplashScreen("Erreur : Impossible de trouver les donn√©es de la sc√®ne.");
          return;
        }

        // 1. Nettoyer la sc√®ne actuelle
        geometryManager.clearAll();

        // 2. D√©s√©rialiser et reconstruire la g√©om√©trie
        sceneData.geometry.points.forEach((p) => {
          geometryManager.addPoint(new Point(p.name, p.position.x, p.position.y, p.position.z));
        });

        sceneData.geometry.vectors.forEach((v) => {
          const origin = new THREE.Vector3(v.origin.x, v.origin.y, v.origin.z);
          const components = new THREE.Vector3(v.components.x, v.components.y, v.components.z);
          // On doit recr√©er le vecteur avec son ID pour garder la coh√©rence
          const newVector = new Vector(v.name, origin, components);
          newVector.id = v.id;
          nextVectorId = Math.max(nextVectorId, v.id + 1); // Important pour ne pas avoir de conflits d'ID
          if (v.isLabelVisible === false) {
            newVector.setLabelVisibility(false);
          }

          geometryManager.addVector(newVector);
        });

        sceneData.geometry.lines.forEach((l) => {
          const startPoint = new THREE.Vector3(l.startPoint.x, l.startPoint.y, l.startPoint.z);
          const directorVector = new THREE.Vector3(l.directorVector.x, l.directorVector.y, l.directorVector.z);
          const newLine = new Line3D(l.name, startPoint, directorVector);
          newLine.id = l.id;
          nextStraightLineId = Math.max(nextStraightLineId, l.id + 1);
          geometryManager.addLine(newLine);
        });

        sceneData.geometry.planes.forEach((p) => {
          const pointOnPlane = new THREE.Vector3(p.pointOnPlane.x, p.pointOnPlane.y, p.pointOnPlane.z);
          const normal = new THREE.Vector3(p.displayNormal.x, p.displayNormal.y, p.displayNormal.z);
          const newPlane = new Plane(p.name, pointOnPlane, normal);
          newPlane.id = p.id;
          nextPlaneId = Math.max(nextPlaneId, p.id + 1);
          geometryManager.addPlane(newPlane);
        });
        showSplashScreen(`‚úÖ Sc√®ne "${sceneName}" charg√©e !`);
        // 3. Mettre √† jour l'ensemble de l'interface
        updateAllUI();
      }

      function deleteScene() {
        const sceneName = document.getElementById("savedScenesSelect").value;
        if (!sceneName) {
          showSplashScreen("Veuillez s√©lectionner une sc√®ne √† supprimer.");
          return;
        }

        if (confirm(`√ätes-vous s√ªr de vouloir supprimer la sc√®ne "${sceneName}" ? Cette action est irr√©versible.`)) {
          let savedScenes = JSON.parse(localStorage.getItem("savedScenes")) || [];
          const updatedScenes = savedScenes.filter((s) => s.name !== sceneName);
          localStorage.setItem("savedScenes", JSON.stringify(updatedScenes));
          populateSavedScenesSelect();
          showSplashScreen(`‚úÖ Sc√®ne "${sceneName}"supprim√©e !`);
        }
      }

      function populateSavedScenesSelect() {
        const select = document.getElementById("savedScenesSelect");
        select.innerHTML = ""; // Vider les anciennes options

        const savedScenes = JSON.parse(localStorage.getItem("savedScenes")) || [];

        if (savedScenes.length === 0) {
          select.add(new Option("Aucune sc√®ne enregistr√©e", ""));
        } else {
          savedScenes.forEach((scene) => {
            select.add(new Option(scene.name, scene.name));
          });
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        populateSavedScenesSelect(); // Ajoutez cette ligne !
      });

      function showSplashScreen(message, duration = 2000) {
        const splashElement = document.getElementById("splashScreen");
        const messageElement = document.getElementById("splashMessage");

        // Annule un timer pr√©c√©dent si une notification √©tait d√©j√† en cours de disparition
        if (splashTimer) {
          clearTimeout(splashTimer);
        }

        // 1. Mettre √† jour le message et afficher l'√©l√©ment
        messageElement.textContent = message;
        splashElement.classList.remove("splash-hidden");

        // 2. Programmer la disparition de l'√©l√©ment apr√®s la dur√©e sp√©cifi√©e
        splashTimer = setTimeout(() => {
          splashElement.classList.add("splash-hidden");
          splashTimer = null; // R√©initialiser le timer
        }, duration);
      }

      function hideContextMenu() {
        console.log("hideContextMenu");
        const menu = document.getElementById("contextMenu");
        if (menu) {
          menu.style.display = "none";
        }
      }
      // --- GESTIONNAIRE D'HISTORIQUE ---
      const historyStack = []; // Stocke les √©tats (snapshots)
      let historyIndex = -1;   // Position actuelle dans l'historique
      const MAX_HISTORY = 20;  // Limite pour ne pas saturer la m√©moire
      // --- Fonction saveState corrig√©e (anti-doublons) ---

      function saveState() {
        // 1. Si on est au milieu de l'historique (apr√®s des Undos), on coupe le futur
        if (historyIndex < historyStack.length - 1) {
          historyStack.splice(historyIndex + 1);
        }

        // 2. Cr√©ation de la "photo" de la sc√®ne actuelle
        const currentState = serializeSceneData();

        // ============================================================
        // 3. CORRECTION : V√âRIFICATION ANTI-DOUBLON
        // ============================================================
        // On v√©rifie si l'√©tat qu'on veut sauvegarder est identique au dernier √©tat connu.
        // Cela emp√™che d'avoir [A, B, B] dans l'historique.
        if (historyIndex >= 0 && historyStack[historyIndex] === currentState) {
          // Si c'est exactement pareil, on ne sauvegarde pas une 2√®me fois.
          // console.log("√âtat identique ignor√©");
          return;
        }

        // 4. Ajout √† la pile si c'est un nouvel √©tat
        historyStack.push(currentState);
        historyIndex++;

        // 5. Limite de m√©moire (on garde les 20 derniers √©tats)
        if (historyStack.length > MAX_HISTORY) {
          historyStack.shift(); // On supprime le plus vieux
          historyIndex--;
        }

        updateHistoryButtons();
      }

      function undo() {
        if (historyIndex > 0) {
          historyIndex--;
          const previousState = historyStack[historyIndex];
          restoreSceneData(previousState);
          showSplashScreen("Action annul√©e ‚Ü©Ô∏è");
        } else {
          showSplashScreen("Rien √† annuler.");
        }
        updateHistoryButtons();
      }

      // Optionnel : Redo
      function redo() {
        if (historyIndex < historyStack.length - 1) {
          historyIndex++;
          const nextState = historyStack[historyIndex];
          restoreSceneData(nextState);
          showSplashScreen("Action r√©tablie ‚Ü™Ô∏è");
        }
        updateHistoryButtons();
      }

      function serializeSceneData() {
        return JSON.stringify({
          points: geometryManager.points.map(p => ({
            name: p.name,
            position: { x: p.position.x, y: p.position.y, z: p.position.z }
          })),
          vectors: geometryManager.vectors.map(v => ({
            id: v.id,
            name: v.name,
            origin: { x: v.origin.x, y: v.origin.y, z: v.origin.z },
            components: { x: v.components.x, y: v.components.y, z: v.components.z },
            isLabelVisible: v.isLabelVisible,
            isVisible: v.isVisible,
            // Sauvegarde des props sp√©cifiques (normale de plan, etc)
            isNormalVector: v.isNormalVector || false,
            parentPlaneId: v.parentPlaneId || null
          })),
          lines: geometryManager.lines.map(l => ({
            id: l.id,
            name: l.name,
            startPoint: { x: l.startPoint.x, y: l.startPoint.y, z: l.startPoint.z },
            directorVector: { x: l.directorVector.x, y: l.directorVector.y, z: l.directorVector.z },
            isVisible: l.isVisible
          })),
          planes: geometryManager.planes.map(p => ({
            id: p.id,
            name: p.name,
            pointOnPlane: { x: p.pointOnPlane.x, y: p.pointOnPlane.y, z: p.pointOnPlane.z },
            displayNormal: { x: p.displayNormal.x, y: p.displayNormal.y, z: p.displayNormal.z },
            isVisible: p.isVisible
          }))
        });
      }

      function restoreSceneData(jsonString) {
        deselectCurrentObject();
        const data = JSON.parse(jsonString);

        // 1. Nettoyage complet
        geometryManager.clearAll();

        // 2. Reconstruction
        data.points.forEach(p => geometryManager.addPoint(new Point(p.name, p.position.x, p.position.y, p.position.z)));

        data.vectors.forEach(v => {
          const vec = new Vector(v.name, new THREE.Vector3(v.origin.x, v.origin.y, v.origin.z), new THREE.Vector3(v.components.x, v.components.y, v.components.z));
          vec.id = v.id;
          vec.isVisible = v.isVisible !== undefined ? v.isVisible : true;
          vec.isLabelVisible = v.isLabelVisible !== undefined ? v.isLabelVisible : true;
          vec.isNormalVector = v.isNormalVector;
          vec.parentPlaneId = v.parentPlaneId;
          nextVectorId = Math.max(nextVectorId, v.id + 1);
          geometryManager.addVector(vec);
        });

        data.lines.forEach(l => {
          const line = new Line3D(l.name, new THREE.Vector3(l.startPoint.x, l.startPoint.y, l.startPoint.z), new THREE.Vector3(l.directorVector.x, l.directorVector.y, l.directorVector.z));
          line.id = l.id;
          line.isVisible = l.isVisible !== undefined ? l.isVisible : true;
          nextStraightLineId = Math.max(nextStraightLineId, l.id + 1);
          geometryManager.addLine(line);
        });

        data.planes.forEach(p => {
          const plane = new Plane(p.name, new THREE.Vector3(p.pointOnPlane.x, p.pointOnPlane.y, p.pointOnPlane.z), new THREE.Vector3(p.displayNormal.x, p.displayNormal.y, p.displayNormal.z));
          plane.id = p.id;
          plane.isVisible = p.isVisible !== undefined ? p.isVisible : true;
          nextPlaneId = Math.max(nextPlaneId, p.id + 1);
          geometryManager.addPlane(plane);
        });

        updateAllUI();
      }

      function updateHistoryButtons() {
        const btnUndo = document.getElementById("btnUndo");
        const btnRedo = document.getElementById("btnRedo");

        // 1. Gestion du bouton UNDO (Annuler)
        if (btnUndo) {
          if (historyIndex > 0) {
            btnUndo.style.opacity = "1";
            btnUndo.style.pointerEvents = "auto";
            btnUndo.style.cursor = "pointer";
          } else {
            btnUndo.style.opacity = "0.5";
            btnUndo.style.pointerEvents = "none";
            btnUndo.style.cursor = "default";
          }
        }

        // 2. Gestion du bouton REDO (R√©tablir)
        if (btnRedo) {
          // On peut r√©tablir s'il y a des √©tats apr√®s l'index actuel dans la pile
          if (historyIndex < historyStack.length - 1) {
            btnRedo.style.opacity = "1";
            btnRedo.style.pointerEvents = "auto";
            btnRedo.style.cursor = "pointer";
          } else {
            btnRedo.style.opacity = "0.5";
            btnRedo.style.pointerEvents = "none";
            btnRedo.style.cursor = "default";
          }
        }
      }
      function handleHover(clientX, clientY) {
        const tooltip = document.getElementById("tooltip");

        // ============================================================
        // 1. PROTECTION UI : On v√©rifie ce qu'il y a sous la souris
        // ============================================================
        const elementUnderMouse = document.elementFromPoint(clientX, clientY);

        // Si on survole le panneau, le bouton burger ou les contr√¥les cam√©ra...
        if (elementUnderMouse && (
          elementUnderMouse.closest("#panel") ||
          elementUnderMouse.closest("#openBtn") ||
          elementUnderMouse.closest("#cameraControls")
        )) {
          // ... On cache l'info-bulle et on arr√™te tout.
          tooltip.style.display = "none";
          document.body.style.cursor = "default";
          return;
        }

        // ============================================================
        // 2. PROTECTION MOUVEMENT CAM√âRA
        // ============================================================
        // Si on bouge la cam√©ra, on cache tout pour ne pas g√™ner la vue
        if (isDragging || isPanning) {
          tooltip.style.display = "none";
          document.body.style.cursor = "default";
          return;
        }

        // ============================================================
        // 3. LOGIQUE D'AFFICHAGE NORMALE
        // ============================================================
        const intersection = getIntersectionResult(clientX, clientY);

        if (intersection && intersection.object.userData.instance) {
          const instance = intersection.object.userData.instance;
          let content = "";

          // Style CSS inline pour les d√©tails
          const detailStyle = 'style="color: #ddd; font-size: 0.9em; display: block; margin-top: 2px;"';

          // --- 1. POINT ---
          if (instance instanceof Point) {
            const x = formatNumber(instance.position.x);
            const y_ui = formatNumber(instance.position.z);
            const z_ui = formatNumber(instance.position.y);
            content = `üìç <strong>${instance.name}</strong><span ${detailStyle}>Coord : (${x}, ${y_ui}, ${z_ui})</span>`;

            // --- 2. VECTEUR ---
          } else if (instance instanceof Vector) {
            const v = instance.components;
            const x = formatNumber(v.x);
            const y_ui = formatNumber(v.z);
            const z_ui = formatNumber(v.y);
            const norm = formatNumber(v.length());
            content = `‚ÜóÔ∏è <strong>${instance.name}</strong><span ${detailStyle}>Coord : (${x}, ${y_ui}, ${z_ui})</span><span ${detailStyle}>Norme : ${norm}</span>`;

            // --- 3. DROITE ---
          } else if (instance instanceof Line3D) {
            const u = instance.directorVector;
            const x = formatNumber(u.x);
            const y_ui = formatNumber(u.z);
            const z_ui = formatNumber(u.y);
            content = `üìè <strong>${instance.name}</strong><span ${detailStyle}>Vect. dir. : (${x}, ${y_ui}, ${z_ui})</span>`;

            // --- 4. PLAN ---
          } else if (instance instanceof Plane) {
            const n = instance.displayNormal;
            const x = formatNumber(n.x);
            const y_ui = formatNumber(n.z);
            const z_ui = formatNumber(n.y);
            content = `üî∑ <strong>${instance.name}</strong><span ${detailStyle}>Normale : (${x}, ${y_ui}, ${z_ui})</span>`;

            // --- AUTRES ---
          } else {
            content = instance.name;
          }

          tooltip.innerHTML = content;

          // Positionnement
          positionTooltipSmartly(clientX, clientY);

          document.body.style.cursor = "pointer";
        } else {
          tooltip.style.display = "none";
          document.body.style.cursor = "default";
        }
      }

      function syncDataFromGizmo() {
        const inst = selectedObjectInstance;
        if (!inst) return;

        // 1. POINT (Inchang√©)
        if (inst instanceof Point) {
          inst.position.copy(inst.mesh.position);
          inst.updateLabelPosition();
          const editIndexInput = document.getElementById("editPointIndex");
          if (editIndexInput && editIndexInput.value != "" && parseInt(editIndexInput.value) === geometryManager.points.indexOf(inst)) {
            document.getElementById("pointX").value = formatNumber(inst.position.x);
            document.getElementById("pointY").value = formatNumber(inst.position.z);
            document.getElementById("pointZ").value = formatNumber(inst.position.y);
          }
        }

        // 2. VECTEUR (Inchang√© mais nettoy√©)
        else if (inst instanceof Vector) {
          const currentOrigin = inst.origin.clone().add(inst.arrowHelper.position);
          inst.updateLabelPosition();
          // Mise √† jour de la liste
          const originListSpan = document.getElementById(`vector-origin-list-${inst.id}`);
          if (originListSpan) {
            const ox = formatNumber(currentOrigin.x, 1);
            const oy = formatNumber(currentOrigin.z, 1);
            const oz = formatNumber(currentOrigin.y, 1);
            originListSpan.innerHTML = `Origine: <strong>(${ox}, ${oy}, ${oz})</strong>`;
          }
          // Formulaire d'√©dition
          if (document.getElementById("editVectorId").value == inst.id) {
            document.getElementById("vectorOriginX").value = formatNumber(currentOrigin.x);
            document.getElementById("vectorOriginY").value = formatNumber(currentOrigin.z);
            document.getElementById("vectorOriginZ").value = formatNumber(currentOrigin.y);
          }
        }

        // 3. DROITE (MODIFI√â)
        else if (inst instanceof Line3D) {
          // Calcul de la position actuelle (Point de d√©part initial + D√©placement du Mesh)
          const currentP = inst.startPoint.clone().add(inst.mesh.position);

          // A. Mise √† jour de la liste "Droites existantes"
          const pointSpan = document.getElementById(`line-point-${inst.id}`);
          if (pointSpan) {
            const px = formatNumber(currentP.x, 1);
            const py = formatNumber(currentP.z, 1); // Profondeur UI
            const pz = formatNumber(currentP.y, 1); // Hauteur UI
            pointSpan.innerHTML = `Passe par : <strong>(${px}, ${py}, ${pz})</strong>`;
          }

          // B. Mise √† jour de l'√©quation si affich√©e (TEMPS R√âEL)
          const eqSelect = document.getElementById("equationLineSelect");

          // On v√©rifie si la droite en cours de modification est celle affich√©e dans le panneau "Equations"
          if (eqSelect && parseInt(eqSelect.value) === inst.id) {
            // On cr√©e un objet l√©ger qui imite la structure d'une Line3D
            // avec la position recalcul√©e (currentP) et le vecteur directeur existant
            const tempLine = {
              startPoint: currentP,
              directorVector: inst.directorVector // Le vecteur directeur ne change pas lors d'une translation
            };

            // On force l'affichage avec ces donn√©es temporaires
            displayLineEquation(tempLine);
          }
        }


        // 4. PLAN (Inchang√©)
        else if (inst instanceof Plane) {
          // 1. Mise √† jour math√©matique
          inst.pointOnPlane.copy(inst.mesh.position);

          // Gestion de la rotation (si applicable)
          if (transformControl.mode === "rotate") {
            const rotationMatrix = new THREE.Matrix4().extractRotation(inst.mesh.matrix);
            // On recalcul le vecteur normal pour qu'il suive la rotation
            const initialNormal = new THREE.Vector3(0, 0, 1); // Normale de base d'un PlaneGeometry non tourn√©
            // Note : Si votre plan a √©t√© cr√©√© avec une orientation sp√©cifique,
            // il faudrait id√©alement stocker le quaternion initial, mais cette m√©thode fonctionne pour les manipulations visuelles.
            inst.normal.copy(initialNormal).applyMatrix4(rotationMatrix).normalize();
            inst.displayNormal.copy(inst.normal);
          }

          // 2. Mise √† jour de l'interface (Liste des plans) - NOUVEAU
          const pointSpan = document.getElementById(`plane-point-${inst.id}`);
          if (pointSpan) {
            const px = formatNumber(inst.pointOnPlane.x, 1);
            const py_ui = formatNumber(inst.pointOnPlane.z, 1); // Inversion standard Y/Z
            const pz_ui = formatNumber(inst.pointOnPlane.y, 1);
            pointSpan.innerHTML = `Passe par : <strong>(${px}, ${py_ui}, ${pz_ui})</strong>`;
          }

          // 3. Mise √† jour de l'affichage de l'√©quation si le panneau est ouvert
          const planeSelect = document.getElementById("equationPlaneSelect");
          if (planeSelect && parseInt(planeSelect.value) === inst.id) {
            displayPlaneEquation();
          }
        }
      }

      function updateTooltipFromGizmo() {
        const tooltip = document.getElementById("tooltip");
        const inst = selectedObjectInstance;

        if (!inst || (lastTooltipX === 0 && lastTooltipY === 0)) {
          tooltip.style.display = "none";
          return;
        }

        let content = "";
        const detailStyle = 'style="color: #ddd; font-size: 0.9em; display: block; margin-top: 2px;"';

        try {
          if (inst instanceof Point) {
            const x = formatNumber(inst.position.x);
            const y_ui = formatNumber(inst.position.z);
            const z_ui = formatNumber(inst.position.y);
            content = `üìç <strong>${inst.name}</strong><span ${detailStyle}>Coord : (${x}, ${y_ui}, ${z_ui})</span>`;
          }
          else if (inst instanceof Vector) {
            // Pour le vecteur, on calcule la position visuelle absolue
            const o = inst.origin.clone().add(inst.arrowHelper.position);
            const v = inst.components;

            const ox = formatNumber(o.x);
            const oy_ui = formatNumber(o.z);
            const oz_ui = formatNumber(o.y);
            const norm = formatNumber(v.length());

            content = `‚ÜóÔ∏è <strong>${inst.name}</strong>
           <span ${detailStyle}>Origine : (${ox}, ${oy_ui}, ${oz_ui})</span>
           <span ${detailStyle}>Norme : ${norm}</span>`;
          }
          // --- MODIFICATION POUR LA DROITE ---
          else if (inst instanceof Line3D) {
            // Position r√©elle = Point de d√©part initial + D√©placement du Gizmo
            const currentP = inst.startPoint.clone().add(inst.mesh.position);

            const px = formatNumber(currentP.x);
            const py_ui = formatNumber(currentP.z);
            const pz_ui = formatNumber(currentP.y);

            const u = inst.directorVector;
            const ux = formatNumber(u.x, 1);
            const uz_ui = formatNumber(u.z, 1);
            const uy_ui = formatNumber(u.y, 1);

            content = `üìè <strong>${inst.name}</strong>
                 <span ${detailStyle}>Passe par : (${px}, ${py_ui}, ${pz_ui})</span>
                 <span ${detailStyle}>Vect. dir. : (${ux}, ${uz_ui}, ${uy_ui})</span>`;
          }
          // -----------------------------------
          else if (inst instanceof Plane) {
            const currentP = inst.pointOnPlane.clone().add(inst.mesh.position);

            // Calcul de la normale (avec rotation si n√©cessaire)
            let n = inst.normal;
            if (transformControl.mode === "rotate") {
              const rotationMatrix = new THREE.Matrix4().extractRotation(inst.mesh.matrix);
              n = inst.normal.clone().applyMatrix4(rotationMatrix);
            }

            // Formatage pour l'affichage
            const nx = formatNumber(n.x, 1);
            const ny_ui = formatNumber(n.z, 1);
            const nz_ui = formatNumber(n.y, 1);

            // NOUVEAU : Formatage du point de passage
            // Note : inst.mesh.position est d√©j√† absolu pour les plans dans notre logique actuelle
            const px = formatNumber(inst.pointOnPlane.x);
            const py_ui = formatNumber(inst.pointOnPlane.z);
            const pz_ui = formatNumber(inst.pointOnPlane.y);

            content = `üî∑ <strong>${inst.name}</strong>
       <span ${detailStyle}>Passe par : (${px}, ${py_ui}, ${pz_ui})</span>
       <span ${detailStyle}>Normale : (${nx}, ${ny_ui}, ${nz_ui})</span>`;
          }

          tooltip.innerHTML = content;
          positionTooltipSmartly(lastTooltipX, lastTooltipY);

        } catch (err) {
          tooltip.style.display = "none";
        }
      }

      function finalizeGizmoMovement() {
        const inst = selectedObjectInstance;
        if (!inst) return;

        // --- CAS 1 : C'EST UN VECTEUR (Correction du bug de disparition) ---
        if (inst instanceof Vector) {
          // 1. IMPORTANT : On l√¢che l'objet AVANT de le modifier.
          // Sinon, Three.js essaie de mettre √† jour un objet qui va √™tre d√©truit.
          transformControl.detach();

          // 2. On capture la nouvelle position absolue
          // Le Gizmo a d√©plac√© l'ArrowHelper. Sa position est devenue la nouvelle origine.
          const newOrigin = inst.arrowHelper.position.clone();

          // 3. On utilise la m√©thode update() de la classe Vector
          // Elle s'occupe proprement de : supprimer l'ancien, cr√©er le nouveau, l'ajouter √† la sc√®ne.
          inst.update(inst.name, newOrigin, inst.components);

          // 4. On r√©attache le Gizmo sur le NOUVEAU vecteur
          // L'ancien inst.arrowHelper n'existe plus, update() en a cr√©√© un nouveau.
          transformControl.attach(inst.arrowHelper);

          // 5. On remet la couleur de s√©lection (Jaune)
          // Car update() a remis la couleur d'origine (orange/bleu/etc).
          if (inst.arrowHelper) {
            inst.arrowHelper.setColor(0xffff00);
          }
        }

        // --- CAS 2 : C'EST UNE DROITE ---
        else if (inst instanceof Line3D) {
          // 1. Appliquer le d√©placement du mesh au point de d√©part math√©matique
          inst.startPoint.add(inst.mesh.position);

          // 2. Remettre le mesh √† z√©ro (pour √©viter que √ßa s'accumule)
          inst.mesh.position.set(0, 0, 0);

          // 3. R√©g√©n√©rer la g√©om√©trie visuelle √† partir du nouveau point de d√©part
          const lineLength = 100;
          const dir = inst.directorVector.clone().normalize();
          const visualStart = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(-lineLength));
          const visualEnd = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(lineLength));

          inst.mesh.geometry.dispose();
          inst.mesh.geometry = new THREE.BufferGeometry().setFromPoints([visualStart, visualEnd]);

          // 4. Mise √† jour de l'√©quation (si affich√©e)
          const eqSelect = document.getElementById("equationLineSelect");
          if (eqSelect && parseInt(eqSelect.value) === inst.id) {
            displayLineEquation();
          }
        }

        // --- CAS 3 : C'EST UN POINT OU UN PLAN ---
        else if (inst instanceof Point) {
          // Pour un point, la position du mesh est la v√©rit√©. On met √† jour l'instance.
          inst.position.copy(inst.mesh.position);
          inst.updateLabelPosition();
        } else if (inst instanceof Plane) {
          // Pour un plan, on met √† jour le point d'ancrage
          inst.pointOnPlane.copy(inst.mesh.position);
        }

        // --- FINALISATION COMMUNE ---
        // Mettre √† jour les coordonn√©es dans le panneau HTML (listes)
        updateAllUI();
        // Sauvegarder dans l'historique (Undo/Redo)
        saveState();
      }

      function positionTooltipSmartly(x, y) {
        const tooltip = document.getElementById("tooltip");
        const offset = 15; // Marge par rapport au curseur

        // 1. On l'affiche d'abord pour pouvoir mesurer sa taille r√©elle
        tooltip.style.display = "block";
        const rect = tooltip.getBoundingClientRect();

        const winWidth = window.innerWidth;
        const winHeight = window.innerHeight;

        // 2. Gestion Horizontal (X)
        let finalX = x + offset;
        // Si le tooltip d√©passe le bord droit de l'√©cran...
        if (finalX + rect.width > winWidth) {
          // ... on le place √† gauche du curseur
          finalX = x - rect.width - offset;
        }
        // S√©curit√© : ne pas sortir √† gauche non plus (si l'√©cran est tr√®s petit)
        if (finalX < 0) finalX = offset;

        // 3. Gestion Vertical (Y)
        let finalY = y + offset;
        // Si le tooltip d√©passe le bord bas de l'√©cran...
        if (finalY + rect.height > winHeight) {
          // ... on le place au-dessus du curseur
          finalY = y - rect.height - offset;
        }
        // S√©curit√© : ne pas sortir en haut
        if (finalY < 0) finalY = offset;

        // 4. Application des coordonn√©es
        tooltip.style.left = finalX + "px";
        tooltip.style.top = finalY + "px";
      }

      function downloadDebugJSON() {
        // 1. Construction de l'objet de donn√©es
        const debugData = {
          meta: {
            appName: "√âditeur Points 3D",
            date: new Date().toLocaleString(),
            timestamp: Date.now(),
            totalObjects: geometryManager.points.length + geometryManager.vectors.length + geometryManager.lines.length + geometryManager.planes.length
          },
          // Points : on exporte la position brute Three.js
          points: geometryManager.points.map((p, index) => ({
            index: index,
            name: p.name,
            position_raw: { x: p.position.x, y: p.position.y, z: p.position.z },
            // On ajoute la position "Vue UI" pour faciliter la lecture humaine
            position_ui: { x: p.position.x, profondeur: p.position.z, hauteur: p.position.y },
            color: "#" + p.color.getHexString()
          })),
          vectors: geometryManager.vectors.map(v => ({
            id: v.id,
            name: v.name,
            origin: { x: v.origin.x, y: v.origin.y, z: v.origin.z },
            components: { x: v.components.x, y: v.components.y, z: v.components.z },
            norm: v.components.length(),
            isVisible: v.isVisible,
            isNormalVector: v.isNormalVector || false
          })),
          lines: geometryManager.lines.map(l => ({
            id: l.id,
            name: l.name,
            startPoint: { x: l.startPoint.x, y: l.startPoint.y, z: l.startPoint.z },
            directorVector: { x: l.directorVector.x, y: l.directorVector.y, z: l.directorVector.z },
            isVisible: l.isVisible
          })),
          planes: geometryManager.planes.map(p => ({
            id: p.id,
            name: p.name,
            pointOnPlane: { x: p.pointOnPlane.x, y: p.pointOnPlane.y, z: p.pointOnPlane.z },
            normal: { x: p.normal.x, y: p.normal.y, z: p.normal.z },
            equationConstant_D: -p.normal.dot(p.pointOnPlane), // d = -n.p
            isVisible: p.isVisible
          }))
        };

        // 2. Conversion en cha√Æne JSON format√©e (pretty print)
        const jsonStr = JSON.stringify(debugData, null, 2);

        // 3. Cr√©ation du lien de t√©l√©chargement invisible
        const blob = new Blob([jsonStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");

        // Nom du fichier avec timestamp
        const dateStr = new Date().toISOString().slice(0, 10);
        a.download = `debug_scene_3d_${dateStr}.json`;

        a.href = url;
        document.body.appendChild(a);
        a.click();

        // 4. Nettoyage
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showSplashScreen("üì• Donn√©es de d√©bogage t√©l√©charg√©es !");
      }
      // --- GESTION DU TH√àME ---
      let isDarkMode = false;
      let gridHelper = null; // R√©f√©rence globale pour pouvoir la supprimer/recr√©er
      let axesGroup = null;  // R√©f√©rence globale pour les axes

      function initTheme() {
        // V√©rifier si une pr√©f√©rence est sauvegard√©e
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
          isDarkMode = true;
        }
        applyTheme();
      }

      function toggleTheme() {
        isDarkMode = !isDarkMode;
        localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
        applyTheme();
      }

      function applyTheme() {
        // 1. Mise √† jour HTML/CSS
        document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');

        const btnIcon = document.querySelector('#themeToggleBtn i');
        if (btnIcon) {
          btnIcon.className = isDarkMode ? 'fas fa-sun' : 'fas fa-moon';
          btnIcon.style.color = isDarkMode ? '#ffeb3b' : '#333'; // Jaune pour soleil, Gris pour lune
        }

        // 2. Mise √† jour de la Sc√®ne 3D
        if (scene) {
          // A. Couleur de fond
          scene.background = new THREE.Color(isDarkMode ? 0x1a1a1a : 0xf0f0f0);

          // B. Mise √† jour de la Grille (GridHelper)
          if (gridHelper) scene.remove(gridHelper);

          // Couleurs : (couleur ligne centrale, couleur lignes grille)
          const colorCenter = isDarkMode ? 0x555555 : 0xcccccc;
          const colorGrid = isDarkMode ? 0x333333 : 0xe0e0e0;

          gridHelper = new THREE.GridHelper(20, 20, colorCenter, colorGrid);
          gridHelper.position.y = 0;
          gridHelper.renderOrder = -1;
          gridHelper.material.depthTest = false;
          scene.add(gridHelper);

          // C. Recr√©er les axes (pour changer la couleur du texte X, Y, Z)
          createAxes();

          // D. Recr√©er les labels de tous les points et vecteurs existants
          refreshAllLabels();
        }
      }

      function refreshAllLabels() {
        // Points
        geometryManager.points.forEach(p => {
          scene.remove(p.label);
          p.label = createGenericTextLabel(p.name);
          p.updateLabelPosition();
          scene.add(p.label);
        });

        // Vecteurs
        geometryManager.vectors.forEach(v => {
          if (v.label) scene.remove(v.label);
          v.label = createGenericTextLabel(v.name);
          v.updateLabelPosition();
          if (v.isVisible && v.isLabelVisible) scene.add(v.label);
        });
      }

      // =====================================================================================
      // SECTION : CALCULS G√âOM√âTRIQUES AVANC√âS
      // =====================================================================================

      /**
       * Calcule le segment le plus court entre deux droites (distance et points d'ancrage).
       * G√®re les droites non coplanaires et parall√®les.
       * @param {Line3D} line1
       * @param {Line3D} line2
       * @returns {Object} { distance: Number, p1: THREE.Vector3, p2: THREE.Vector3, type: "skew"|"parallel" }
       */
      function getShortestSegmentBetweenLines(line1, line2) {
        const P1 = line1.startPoint;
        const u = line1.directorVector.clone().normalize();
        const P2 = line2.startPoint;
        const v = line2.directorVector.clone().normalize();

        const w0 = new THREE.Vector3().subVectors(P1, P2);
        const a = u.dot(u); // Toujours 1 si normalis√©
        const b = u.dot(v);
        const c = v.dot(v); // Toujours 1 si normalis√©
        const d = u.dot(w0);
        const e = v.dot(w0);

        const det = a * c - b * b;
        let sc, tc;

        // Si le d√©terminant est proche de 0, les droites sont parall√®les
        if (Math.abs(det) < 1e-8) {
          // Droites parall√®les
          sc = 0;
          tc = (b > c ? d / b : e / c); // On projette P1 sur la droite 2

          // Point sur la droite 1 (fixe)
          const p1_res = P1.clone();
          // Point projet√© sur la droite 2
          const p2_res = new THREE.Vector3().addVectors(P2, v.multiplyScalar(tc));

          return {
            distance: p1_res.distanceTo(p2_res),
            p1: p1_res,
            p2: p2_res,
            type: "parallel"
          };
        } else {
          // Droites non coplanaires (gauches)
          sc = (b * e - c * d) / det;
          tc = (a * e - b * d) / det;

          const p1_res = new THREE.Vector3().addVectors(P1, u.multiplyScalar(sc));
          const p2_res = new THREE.Vector3().addVectors(P2, v.multiplyScalar(tc));

          return {
            distance: p1_res.distanceTo(p2_res),
            p1: p1_res,
            p2: p2_res,
            type: "skew"
          };
        }
      }

      /**
       * Calcule l'angle entre un vecteur et un plan.
       * @param {Vector} vectorInstance Votre instance de classe Vector
       * @param {Plane} planeInstance Votre instance de classe Plane
       * @returns {Number} Angle en degr√©s
       */
      function getVectorPlaneAngle(vectorInstance, planeInstance) {
        // Math√©matiquement : arcsin( |u . n| / (||u|| * ||n||) )
        // Ou 90¬∞ - angle(vecteur, normale)

        const u = vectorInstance.components.clone().normalize();
        const n = planeInstance.normal.clone().normalize();

        // Produit scalaire
        const dot = u.dot(n);

        // On prend la valeur absolue car l'angle g√©om√©trique est entre la droite port√©e par le vecteur et le plan
        // Math.asin renvoie des radians
        const angleRad = Math.asin(Math.abs(dot));
        const angleDeg = THREE.MathUtils.radToDeg(angleRad);

        return angleDeg;
      }

      /**
       * Projette un point sur une droite.
       * @param {Point} pointInstance
       * @param {Line3D} lineInstance
       * @returns {Object} { projectedPoint: THREE.Vector3, distance: Number }
       */
      function projectPointOnLine(pointInstance, lineInstance) {
        const P = pointInstance.position;
        const A = lineInstance.startPoint;
        const u = lineInstance.directorVector.clone().normalize();

        // Vecteur AP
        const AP = new THREE.Vector3().subVectors(P, A);

        // Projection scalaire t = AP . u
        const t = AP.dot(u);

        // Point H = A + t*u
        const H = new THREE.Vector3().copy(A).add(u.multiplyScalar(t));

        return {
          projectedPoint: H,
          distance: P.distanceTo(H)
        };
      }

      /**
       * Calcule le barycentre de N points avec pond√©ration.
       * @param {Array<Point>} pointsArray Tableau d'instances de Point
       * @param {Array<Number>} weightsArray Tableau de poids (optionnel, d√©faut 1)
       * @returns {THREE.Vector3} Position du barycentre
       */
      function computeBarycenter(pointsArray, weightsArray = null) {
        if (!pointsArray || pointsArray.length === 0) return new THREE.Vector3(0, 0, 0);

        let sumX = 0, sumY = 0, sumZ = 0;
        let totalWeight = 0;

        for (let i = 0; i < pointsArray.length; i++) {
          const p = pointsArray[i].position;
          // Si pas de poids fourni, on utilise 1 (isobarycentre)
          const w = (weightsArray && weightsArray[i] !== undefined) ? parseFloat(weightsArray[i]) : 1;

          sumX += p.x * w;
          sumY += p.y * w;
          sumZ += p.z * w;
          totalWeight += w;
        }

        if (totalWeight === 0) {
          console.warn("Somme des poids nulle, calcul impossible.");
          return new THREE.Vector3(0, 0, 0);
        }

        return new THREE.Vector3(sumX / totalWeight, sumY / totalWeight, sumZ / totalWeight);
      }

      function calculateCommonPerpendicular() {
        const l1Id = parseInt(document.getElementById("perpLine1").value);
        const l2Id = parseInt(document.getElementById("perpLine2").value);
        const r = document.getElementById("perpResult");

        const line1 = geometryManager.findLineById(l1Id);
        const line2 = geometryManager.findLineById(l2Id);

        if (!line1 || !line2) {
          r.textContent = "S√©lectionnez deux droites.";
          return;
        }

        // Appel de la fonction math√©matique
        const result = getShortestSegmentBetweenLines(line1, line2);

        if (result.type === "parallel") {
          r.innerHTML = `Droites parall√®les.<br>Distance = <strong>${formatNumber(result.distance)}</strong>`;
        } else {
          // Cr√©ation visuelle du segment (Vecteur)
          const baseName = `Perp(${line1.name},${line2.name})`;
          const uniqueName = geometryManager.generateUniqueName(baseName, "vector");

          // Cr√©ation du vecteur repr√©sentant le segment le plus court
          const segmentVector = new THREE.Vector3().subVectors(result.p2, result.p1);
          const newVector = new Vector(uniqueName, result.p1, segmentVector, 0xff00ff); // Magenta
          geometryManager.addVector(newVector);

          // Cr√©ation des points d'intersection H1 et H2
          geometryManager.addPoint(new Point(uniqueName + "_H1", result.p1.x, result.p1.y, result.p1.z)); // Attention inversion Y/Z selon votre logique UI
          geometryManager.addPoint(new Point(uniqueName + "_H2", result.p2.x, result.p2.y, result.p2.z));

          r.innerHTML = `Distance min = <strong>${formatNumber(result.distance)}</strong><br>Segment trac√©.`;

          updateAllUI();
          saveState();
        }
      }
      function addLineFromPointVector() {
        // 1. R√©cup√©ration des valeurs
        const nameInput = document.getElementById("lineNamePV");
        const pSelect = document.getElementById("linePointPVSelect");
        const vSelect = document.getElementById("lineVectorPVSelect");

        const pId = pSelect.value;
        const vId = vSelect.value;

        // 2. Validation
        if (pId === "" || vId === "") {
          showSplashScreen("Veuillez s√©lectionner un Point ET un Vecteur.");
          return;
        }

        // 3. R√©cup√©ration des objets g√©om√©triques
        const pointObj = geometryManager.points[parseInt(pId)];
        const vectorObj = geometryManager.findVectorById(parseInt(vId));

        if (!pointObj || !vectorObj) return;

        // 4. Gestion du nom (automatique si vide)
        let lineName = nameInput.value.trim();
        if (!lineName) {
          lineName = `D(${pointObj.name}, u_${vectorObj.name})`;
        }

        // 5. Cr√©ation de la droite
        // On clone les vecteurs pour √©viter que modifier le point plus tard ne casse la droite
        const uniqueName = geometryManager.generateUniqueName(lineName, "line");
        const newLine = new Line3D(
          uniqueName,
          pointObj.position,          // Point de passage
          vectorObj.components        // Vecteur directeur
        );

        // 6. Ajout et Sauvegarde
        geometryManager.addLine(newLine);

        updateAllUI();
        saveState();

        // 7. Nettoyage des champs
        nameInput.value = "";
        pSelect.value = "";
        vSelect.value = "";

        showSplashScreen(`‚úÖ Droite "${uniqueName}" cr√©√©e !`);
      }

    </script>
</body>

</html>
