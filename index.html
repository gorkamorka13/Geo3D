<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>√âditeur de Points 3D</title>
    <link rel="icon" type="image/png" href="/geo3d.png" />
    <!-- IMPORTANT: La biblioth√®que Three.js et OrbitControls seront charg√©es ici par votre JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- Ajout de Font Awesome pour les ic√¥nes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
    <style>
      /* =========================================
       1. VARIABLES & TH√àME (Clair / Sombre)
       ========================================= */
      :root {
        /* --- TH√àME CLAIR (D√©faut) --- */
        --bg-color: #f0f0f0;
        --panel-bg: #ffffff;
        --text-color: #333333;
        --text-secondary: #666666;
        --input-bg: #ffffff;
        --input-border: #cccccc;
        --input-focus: #4caf50;
        --item-bg: #ffffff;
        --item-border: #eeeeee;
        --hover-bg: #f9f9f9;
        --button-text: #ffffff;
        --shadow-color: rgba(0, 0, 0, 0.15);
        --burger-color: #333333;
        --camera-btn-bg: #f0f0f0;
        --camera-btn-hover: #e0e0e0;
        --section-border: #ddd;
      }

      [data-theme="dark"] {
        /* --- TH√àME SOMBRE --- */
        --bg-color: #121212;
        --panel-bg: #2c2c2c;
        --text-color: #e0e0e0;
        --text-secondary: #aaaaaa;
        --input-bg: #383838;
        --input-border: #555555;
        --input-focus: #81c784;
        --item-bg: #333333;
        --item-border: #444444;
        --hover-bg: #404040;
        --button-text: #ffffff;
        --shadow-color: rgba(0, 0, 0, 0.5);
        --burger-color: #ffffff;
        --camera-btn-bg: #333333;
        --camera-btn-hover: #444444;
        --section-border: #444;
      }

      /* =========================================
       2. CONFIGURATION G√âN√âRALE
       ========================================= */
      body {
        margin: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      #container {
        width: 100vw;
        height: 100vh;
        position: relative;
        touch-action: none;
      }

      /* =========================================
       3. PANNEAU LAT√âRAL
       ========================================= */
      #panel {
        position: absolute;
        top: 20px;
        left: 20px;
        background: var(--panel-bg);
        padding: 0 20px 20px 20px;
        /* Padding haut pour les boutons */
        border-radius: 8px;
        box-shadow: 0 2px 10px var(--shadow-color);
        max-height: 90vh;
        overflow-y: auto;
        width: 320px;
        transition: transform 0.3s ease, background-color 0.3s ease;
        z-index: 999;
        scrollbar-width: thin;
        scrollbar-color: var(--text-secondary) var(--panel-bg);
      }

      #panel.hidden {
        transform: translateX(calc(-100% - 20px));
      }

      /* Scrollbar Webkit */
      #panel::-webkit-scrollbar {
        width: 8px;
      }

      #panel::-webkit-scrollbar-track {
        background: var(--panel-bg);
      }

      #panel::-webkit-scrollbar-thumb {
        background-color: var(--text-secondary);
        border-radius: 4px;
        border: 2px solid var(--panel-bg);
      }

      /* =========================================
       4. BOUTONS DE NAVIGATION (Burger & Th√®me)
       ========================================= */

      /* NOUVEAU : Header collant pour les boutons */
      #panelHeader {
        position: sticky;
        top: 0;
        background-color: var(--panel-bg);
        z-index: 1002;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 0;
        margin: 0 -20px 10px -20px;
        /* D√©borde pour couvrir le padding du parent */
        padding-left: 20px;
        padding-right: 20px;
        border-bottom: 1px solid var(--section-border);
        /* Optionnel : s√©paration visuelle */
      }

      /* Bouton Burger (Fermer) dans le panneau */
      #toggleBtn {
        position: relative;
        /* Plus absolute */
        background: transparent;
        z-index: 1003;
      }

      /* Bouton Th√®me (Lune/Soleil) dans le panneau */
      #themeToggleBtn {
        position: relative;
        /* Plus absolute */
        background: transparent;
        border: none;
        cursor: pointer;
        font-size: 18px;
        color: var(--text-color);
        padding: 8px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: background-color 0.2s;
      }

      #themeToggleBtn:hover {
        background-color: var(--hover-bg);
      }

      /* Bouton Burger (Ouvrir) flottant */
      #openBtn {
        position: fixed;
        top: 20px;
        left: 20px;
        background: var(--panel-bg);
        box-shadow: 0 2px 10px var(--shadow-color);
        z-index: 998;
        display: none;
      }

      #openBtn.show {
        display: flex;
      }

      /* Lignes du Burger */
      .burger-btn {
        width: 40px;
        height: 40px;
        padding: 8px;
        border-radius: 6px;
        cursor: pointer;
        border: none;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 4px;
        background-color: transparent;
      }

      .burger-btn:hover {
        background-color: var(--hover-bg) !important;
      }

      .burger-line {
        width: 20px;
        height: 2px;
        background-color: var(--burger-color);
        transition: all 0.3s ease;
      }

      /* =========================================
       5. TYPOGRAPHIE & SECTIONS
       ========================================= */
      h3 {
        margin: 0;
        font-size: 18px;
        color: var(--text-color);
      }

      .section-header {
        display: flex;
        align-items: center;
        gap: 12px;
        cursor: pointer;
        position: relative;
      }

      .section-header h3 {
        font-size: 16px;
        font-weight: bold;
        flex-grow: 1;
      }

      .header-icon {
        font-size: 20px;
        width: 24px;
        text-align: center;
        flex-shrink: 0;
        color: var(--text-color);
      }

      .section {
        margin-bottom: 10px;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--section-border);
      }

      .section:last-of-type {
        border-bottom: none;
        margin-bottom: 0;
      }

      /* Fl√®che d√©pliante */
      .section.collapsible .section-header::after {
        content: "‚ñ≤";
        font-size: 12px;
        color: var(--text-secondary);
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        transition: transform 0.3s ease;
      }

      .section.collapsible.collapsed .section-header::after {
        transform: translateY(-50%) rotate(180deg);
      }

      .section.collapsible.collapsed .section-content {
        display: none;
      }

      .sub-section-title {
        font-size: 13px;
        margin-top: 10px;
        margin-bottom: 10px;
        color: var(--text-color);
        opacity: 0.9;
      }

      /* =========================================
       6. FORMULAIRES & INPUTS
       ========================================= */
      .input-group {
        margin-bottom: 10px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        font-size: 13px;
        font-weight: bold;
        color: var(--text-secondary);
      }

      input,
      select,
      textarea {
        width: 100%;
        padding: 8px;
        border: 1px solid var(--input-border);
        background-color: var(--input-bg);
        color: var(--text-color);
        border-radius: 4px;
        font-size: 13px;
        box-sizing: border-box;
      }

      input:focus,
      select:focus,
      textarea:focus {
        outline: none;
        border-color: var(--input-focus);
      }

      .coord-inputs {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 8px;
      }

      .checkbox-group {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 8px 0;
      }

      .checkbox-group input {
        width: auto;
      }

      .checkbox-group label {
        margin: 0;
        cursor: pointer;
      }

      .equation-display {
        background: var(--hover-bg);
        padding: 10px;
        border-radius: 4px;
        font-family: "Courier New", monospace;
        font-size: 13px;
        color: var(--text-color);
        min-height: 20px;
        display: block;
        text-align: left;
        word-break: break-all;
        border: 1px solid var(--item-border);
      }

      /* =========================================
       7. BOUTONS D'ACTION
       ========================================= */
      button {
        width: 100%;
        margin: 8px 0;
        padding: 10px;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        transition: background-color 0.2s;
      }

      /* Bouton Principal (Vert) */
      button:not([class]) {
        background: #4caf50;
      }

      button:not([class]):hover {
        background: #45a049;
      }

      #addPointBtn {
        background: #4caf50;
      }

      #addPointBtn:hover {
        background: #45a049;
      }

      /* Classes sp√©cifiques */
      .btn-secondary {
        background: #2196f3;
      }

      .btn-secondary:hover {
        background: #0b7dda;
      }

      .btn-danger {
        background: #f44336;
      }

      .btn-danger:hover {
        background: #da190b;
      }

      .btn-warning {
        background: #ff9800;
      }

      .btn-warning:hover {
        background: #e68900;
      }

      .btn-violet {
        background: #8a2be2;
      }

      .btn-violet:hover {
        background: #7a25c4;
      }

      .btn-violet-light {
        background: #9370db;
      }

      .btn-violet-light:hover {
        background: #825fbc;
      }

      .edit-actions-container {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-top: 10px;
      }

      .edit-actions-container button {
        font-size: 12px;
        margin: 0;
        padding: 10px 5px;
      }

      /* =========================================
       8. LISTES (Items G√©om√©triques)
       ========================================= */
      .point-list,
      .geometry-list {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid var(--input-border);
        border-radius: 4px;
        padding: 5px;
        background: var(--hover-bg);
        /* Fond l√©g√®rement diff√©rent du panel */
      }

      .point-item,
      .geometry-item {
        padding: 8px;
        margin: 5px 0;
        background: var(--item-bg);
        border-radius: 4px;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        font-size: 13px;
        border: 1px solid var(--item-border);
        color: var(--text-color);
      }

      .geometry-item-main {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        width: 100%;
        gap: 10px;
      }

      .geometry-info {
        flex-grow: 1;
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      .point-name,
      .geometry-name {
        font-weight: bold;
        color: var(--text-color);
        font-size: 13px;
        word-break: break-word;
      }

      .geometry-coords,
      .geometry-details {
        font-size: 12px;
        color: var(--text-secondary);
        word-break: break-word;
      }

      .geometry-details-secondary {
        font-size: 11px;
        color: var(--text-secondary);
        margin-top: 4px;
        padding-left: 2px;
      }

      /* Force la couleur des spans g√©n√©r√©s dynamiquement si n√©cessaire */
      .geometry-details-secondary span {
        color: var(--text-secondary) !important;
      }

      .geometry-actions {
        display: flex;
        gap: 5px;
        flex-shrink: 0;
      }

      .geometry-actions button {
        width: auto;
        padding: 5px 8px;
        font-size: 11px;
        margin: 0;
      }

      /* =========================================
       9. CONTR√îLES CAM√âRA
       ========================================= */
      #cameraControls {
        position: absolute;
        top: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 990;
        pointer-events: auto;
      }

      .camera-btn {
        width: 40px;
        height: 40px;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: var(--camera-btn-bg);
        border: 1px solid var(--input-border);
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s, border-color 0.2s;
        color: var(--text-color);
        font-size: 18px;
        box-shadow: 0 2px 4px var(--shadow-color);
      }

      .camera-btn:hover {
        background-color: var(--camera-btn-hover);
      }

      .camera-btn.active {
        background-color: #2196f3;
        color: white;
        border-color: #2196f3;
      }

      /* Adaptation des SVG cam√©ra pour le mode sombre (optionnel,
       les polygones ont des fills hardcod√©s mais le cadre changera) */

      /* =========================================
       10. MENU CONTEXTUEL & TOOLS
       ========================================= */
      .context-menu {
        position: fixed;
        z-index: 2147483647;
        background-color: var(--panel-bg);
        border: 1px solid var(--input-border);
        box-shadow: 2px 2px 10px var(--shadow-color);
        border-radius: 4px;
        padding: 5px 0;
        min-width: 160px;
        display: none;
      }

      .context-menu-items {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      .context-menu-items li {
        padding: 8px 15px;
        font-size: 14px;
        color: var(--text-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        border-bottom: 1px solid var(--item-border);
      }

      .context-menu-items li:last-child {
        border-bottom: none;
      }

      .context-menu-items li:hover {
        background-color: var(--hover-bg);
      }

      #splashScreen {
        position: fixed;
        top: 50px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(40, 40, 40, 0.95);
        /* Toujours sombre pour contraste */
        color: white;
        padding: 12px 25px;
        border-radius: 25px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        z-index: 10001;
        font-size: 14px;
        font-weight: bold;
        transition: opacity 0.5s ease-in-out, top 0.5s ease-in-out;
      }

      #splashScreen.splash-hidden {
        opacity: 0;
        top: -100px;
        pointer-events: none;
      }

      #tooltip {
        position: fixed;
        background-color: rgba(0, 0, 0, 0.85);
        /* Toujours sombre */
        color: #fff;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        display: none;
        z-index: 500;
        white-space: nowrap;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        transform: translate(15px, 15px);
      }

      /* =========================================
       11. RESPONSIVE (MOBILE)
       ========================================= */
      @media (max-width: 768px) {
        #panel {
          background: var(--panel-bg);
          width: fit-content;
          min-width: 280px;
          opacity: 0.98;
          /* L√©g√®rement plus opaque sur mobile */
        }

        #openBtn {
          top: 15px;
          left: 15px;
        }

        .camera-btn svg {
          pointer-events: none;
        }
      }

      #panel.no-transition {
        transition: none !important;
      }

      /* =========================================
   STYLE DU TABLEUR (SPREADSHEET)
   ========================================= */
      #openSpreadsheetBtn {
        position: fixed;
        bottom: 10px;
        left: 20px;
        /* Align√© avec le menu gauche */
        width: auto;
        padding: 8px 15px;
        background-color: var(--panel-bg);
        color: var(--text-color);
        border: 1px solid var(--input-border);
        border-radius: 4px;
        box-shadow: 0 2px 5px var(--shadow-color);
        z-index: 995;
        cursor: pointer;
        font-weight: bold;
        font-size: 13px;
      }

      #spreadsheetContainer {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 300px;
        /* Hauteur du panneau */
        background-color: var(--panel-bg);
        border-top: 1px solid var(--section-border);
        box-shadow: 0 -2px 10px var(--shadow-color);
        z-index: 10000;
        /* Au-dessus de tout sauf context menu */
        display: flex;
        flex-direction: column;
        transition: transform 0.3s ease;
      }

      #spreadsheetContainer.spreadsheet-hidden {
        transform: translateY(100%);
        /* Cach√© en bas */
      }

      .spreadsheet-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 5px 10px;
        background-color: var(--hover-bg);
        border-bottom: 1px solid var(--section-border);
      }

      .spreadsheet-tabs {
        display: flex;
        gap: 5px;
      }

      .tab-btn {
        background: transparent;
        border: none;
        color: var(--text-secondary);
        padding: 6px 12px;
        cursor: pointer;
        border-radius: 4px 4px 0 0;
        font-weight: bold;
        font-size: 13px;
        width: auto;
        /* Override du style global button */
        margin: 0;
      }

      .tab-btn:hover {
        background-color: var(--item-bg);
        color: var(--text-color);
      }

      .tab-btn.active {
        background-color: var(--panel-bg);
        color: var(--input-focus);
        border-bottom: 2px solid var(--input-focus);
      }

      .close-spreadsheet-btn {
        background: transparent;
        color: var(--text-secondary);
        border: none;
        font-size: 12px;
        cursor: pointer;
        width: auto;
        margin: 0;
      }

      .spreadsheet-body {
        flex-grow: 1;
        overflow: auto;
        padding: 0;
      }

      #spreadsheetTable {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
        color: var(--text-color);
      }

      #spreadsheetTable th,
      #spreadsheetTable td {
        border: 1px solid var(--item-border);
        padding: 4px 8px;
        text-align: center;
      }

      #spreadsheetTable th {
        background-color: var(--hover-bg);
        position: sticky;
        top: 0;
        z-index: 1;
        font-weight: bold;
      }

      /* Inputs dans le tableau */
      #spreadsheetTable input {
        width: 100%;
        border: none;
        background: transparent;
        text-align: center;
        color: var(--text-color);
        padding: 4px;
        font-family: monospace;
      }

      #spreadsheetTable input:focus {
        background-color: var(--input-bg);
        outline: 1px solid var(--input-focus);
      }

      /* Couleurs sp√©cifiques pour X, Y, Z */
      .col-x input {
        color: #ff5252;
        font-weight: bold;
      }

      .col-y input {
        color: #448aff;
        font-weight: bold;
      }

      /* Z ThreeJS = Y UI (Bleu) */
      .col-z input {
        color: #69f0ae;
        font-weight: bold;
      }

      /* Y ThreeJS = Z UI (Vert) */

      /* Mode sombre ajustement */
      [data-theme="dark"] .col-x input {
        color: #ff8a80;
      }

      [data-theme="dark"] .col-y input {
        color: #82b1ff;
      }

      [data-theme="dark"] .col-z input {
        color: #b9f6ca;
      }

      /* Style pour l'ic√¥ne de l'aimant */
      #snapIcon {
        display: inline-block;
        position: relative;
        transition: all 0.3s ease;
        font-size: 16px;
        margin-right: 5px;
      }

      /* Quand l'aimant est d√©sactiv√© (barr√©) */
      #snapIcon.icon-disabled {
        opacity: 0.6;
        /* Rend l'ic√¥ne un peu transparente */
        filter: grayscale(100%);
        /* (Optionnel) Rend l'ic√¥ne grise */
      }

      /* La ligne rouge qui barre l'ic√¥ne */
      #snapIcon.icon-disabled::after {
        content: "";
        position: absolute;
        top: 50%;
        left: 0;
        width: 100%;
        height: 2px;
        /* √âpaisseur de la barre */
        background-color: #ff4444;
        /* Couleur rouge */
        transform: translateY(-50%) rotate(-45deg);
        /* Rotation diagonale */
        pointer-events: none;
        /* Ne g√™ne pas le clic */
      }

      /* --- CORRECTION LISTE D√âROULANTE AIMANT --- */
      #snapSizeSelect {
        color: var(--text-color) !important;
        background-color: var(--panel-bg);
        /* On force la couleur de fond du panneau */
      }

      /* Cible sp√©cifiquement les options quand la liste est ouverte */
      #snapSizeSelect option {
        background-color: var(--panel-bg);
        color: var(--text-color);
      }

      /* Renforcement sp√©cifique pour le mode sombre */
      [data-theme="dark"] #snapSizeSelect {
        color: #ffffff !important;
        /* Force le blanc pur */
        background-color: #2c2c2c;
        /* Force le fond gris fonc√© */
      }
    </style>
  </head>

  <body>
    <div id="splashScreen" class="splash-hidden">
      <span id="splashMessage"></span>
    </div>

    <div id="tooltip"></div>

    <button id="openBtn" class="burger-btn show" onclick="togglePanel()">
      <span class="burger-line"></span>
      <span class="burger-line"></span>
      <span class="burger-line"></span>
    </button>
    <div id="container">
      <div id="cameraControls">
        <div
          id="snapControl"
          style="
            position: absolute;
            top: 20px;
            right: 70px;
            z-index: 990;
            background: var(--panel-bg);
            padding: 5px 5px 5px 10px;
            border-radius: 4px;
            border: 1px solid var(--input-border);
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 5px var(--shadow-color);
          "
        >
          <!-- Checkbox cach√©e pour le toggle ON/OFF -->
          <input type="checkbox" id="snapToggle" onchange="toggleSnapping()" style="display: none" />

          <!-- Label cliquable pour activer/d√©sactiver -->
          <label
            for="snapToggle"
            style="
              font-size: 13px;
              margin: 0;
              cursor: pointer;
              color: var(--text-color);
              display: flex;
              align-items: center;
            "
            title="Activer/D√©sactiver l'aimant"
          >
            <span id="snapIcon" class="icon-disabled">üß≤</span>
            <span style="margin-left: 5px; font-weight: bold">Aimant</span>
          </label>

          <!-- S√©parateur visuel -->
          <div style="width: 1px; height: 20px; background-color: var(--input-border)"></div>

          <!-- Liste d√©roulante pour la taille -->
          <select
            id="snapSizeSelect"
            onchange="updateSnapSize()"
            style="
              width: auto;
              padding: 2px 5px;
              margin: 0;
              height: 26px;
              border: none;
              background: transparent;
              color: var(--text-color);
              font-size: 13px;
              cursor: pointer;
              outline: none;
              font-weight: bold;
            "
          >
            <option value="1">1.0</option>
            <option value="0.5">0.5</option>
            <option value="0.1">0.1</option>
          </select>
        </div>

        <!-- Vue de dessus (XY) : La face sup√©rieure du cube est noire -->
        <div class="camera-btn" id="btnTop" onclick="setCameraView('top', this)" title="Vue de dessus (XY)">
          <svg width="40" height="40" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
            <!-- Face du dessus (noire) -->
            <polygon points="5,15 25,5 45,15 25,25" fill="#222222" />
            <!-- Face de droite (claire) -->
            <polygon points="45,15 45,35 25,45 25,25" fill="#e6e6e6" />
            <!-- Face de gauche (moyenne) -->
            <polygon points="5,15 5,35 25,45 25,25" fill="#cacaca" />
          </svg>
        </div>

        <!-- Vue de face (XZ) : La face de "gauche" (qui repr√©sente l'avant) est noire -->
        <div class="camera-btn" id="btnFront" onclick="setCameraView('front', this)" title="Vue de face (XZ)">
          <svg width="40" height="40" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
            <!-- Face du dessus (moyenne) -->
            <polygon points="5,15 25,5 45,15 25,25" fill="#cacaca" />
            <!-- Face de droite (claire) -->
            <polygon points="45,15 45,35 25,45 25,25" fill="#e6e6e6" />
            <!-- Face de gauche/avant (noire) -->
            <polygon points="5,15 5,35 25,45 25,25" fill="#222222" />
          </svg>
        </div>

        <!-- Vue de c√¥t√© (YZ) : La face de "droite" (qui repr√©sente le c√¥t√©) est noire -->
        <div class="camera-btn" id="btnSide" onclick="setCameraView('side', this)" title="Vue de c√¥t√© (YZ)">
          <svg width="40" height="40" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
            <!-- Face du dessus (moyenne) -->
            <polygon points="5,15 25,5 45,15 25,25" fill="#cacaca" />
            <!-- Face de droite/c√¥t√© (noire) -->
            <polygon points="45,15 45,35 25,45 25,25" fill="#222222" />
            <!-- Face de gauche (claire) -->
            <polygon points="5,15 5,35 25,45 25,25" fill="#e6e6e6" />
          </svg>
        </div>

        <div class="camera-btn" id="btnReset" onclick="resetCamera(this)" title="R√©initialiser la vue (Isom√©trique)">
          <i class="fas fa-sync-alt"></i>
        </div>
        <div
          class="camera-btn"
          id="btnUndo"
          onclick="undo()"
          title="Annuler (Ctrl+Z)"
          style="opacity: 0.5; pointer-events: none"
        >
          <i class="fas fa-undo"></i>
        </div>
        <div
          class="camera-btn"
          id="btnRedo"
          onclick="redo()"
          title="R√©tablir (Ctrl+Y)"
          style="opacity: 0.5; pointer-events: none"
        >
          <i class="fas fa-redo"></i>
        </div>
      </div>
      <div id="panel" class="hidden">
        <div id="panelHeader">
          <button id="toggleBtn" class="burger-btn" onclick="togglePanel()">
            <span class="burger-line"></span>
            <span class="burger-line"></span>
            <span class="burger-line"></span>
          </button>
          <button id="themeToggleBtn" onclick="toggleTheme()" title="Changer le th√®me">
            <i class="fas fa-moon"></i>
          </button>
        </div>
        <div class="section collapsible collapsed">
          <div class="section-header">
            <h3 style="font-size: 16px">üíæ Gestion des Sc√®nes</h3>
          </div>
          <div class="section-content">
            <label>Nom de la sc√®ne :</label>
            <input type="text" id="sceneNameInput" placeholder="Ex: Ma Sc√®ne 1" />
            <button class="btn-secondary" onclick="saveScene()">üíæ Enregistrer la sc√®ne</button>

            <h4 class="sub-section-title" style="margin-top: 20px">Charger une sc√®ne :</h4>
            <label>Sc√®nes sauvegard√©es :</label>
            <select id="savedScenesSelect" style="margin-bottom: 8px"></select>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px">
              <button class="btn-violet" onclick="loadScene()">üîÑ Charger</button>
              <button class="btn-danger" onclick="deleteScene()">üóëÔ∏è Supprimer</button>
            </div>
            <button
              class="btn-warning"
              style="margin-top: 15px; background-color: #607d8b"
              onclick="downloadDebugJSON()"
            >
              üêû Exporter JSON (Debug)
            </button>
            <div style="margin-top: 15px; border-top: 1px solid #ddd; padding-top: 10px">
              <h4 class="sub-section-title">Fichiers de sauvegarde (.json) :</h4>
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px">
                <!-- Bouton Exporter -->
                <button class="btn-secondary" style="background-color: #009688" onclick="exportSceneToJSON()">
                  üì§ Exporter
                </button>

                <!-- Bouton Importer (d√©clenche l'input cach√©) -->
                <button class="btn-violet" onclick="document.getElementById('importFileInput').click()">
                  üì• Importer
                </button>
              </div>

              <!-- Input fichier cach√© pour l'import -->
              <input
                type="file"
                id="importFileInput"
                accept=".json"
                style="display: none"
                onchange="importSceneFromJSON(this)"
              />
            </div>
          </div>
        </div>

        <div class="section collapsible collapsed">
          <div class="section-header">
            <h3 style="font-size: 16px">üìç Tracer des points</h3>
          </div>
          <div class="section-content">
            <label>Nom du point :</label>
            <input type="text" id="pointName" placeholder="Ex: A, Point1..." />

            <label style="margin-top: 10px">Coordonn√©es (X, Y, Z) :</label>
            <div class="coord-inputs">
              <input type="number" id="pointX" placeholder="X" step="1" />
              <input type="number" id="pointY" placeholder="Y (Profondeur)" step="1" />
              <input type="number" id="pointZ" placeholder="Z (Hauteur)" step="1" />
            </div>

            <!-- Bouton d'ajout de point, visible par d√©faut -->
            <button id="addPointBtn" onclick="addPoint()">‚ûï Ajouter le point</button>

            <!-- NOUVEAU : Conteneur pour les boutons d'action d'√©dition des points -->
            <input type="hidden" id="editPointIndex" />
            <div id="pointEditActions" class="edit-actions-container" style="display: none">
              <button id="updatePointBtn" class="btn-secondary" onclick="updatePoint()">üíæ Mettre √† jour</button>
              <button id="deleteEditingPointBtn" class="btn-danger" onclick="deleteEditingPoint()">üóëÔ∏è Supprimer</button>
              <button id="cancelEditBtn" class="btn-warning" onclick="cancelEdit()">‚ùå Annuler</button>
            </div>
          </div>
          <div class="section-content">
            <div id="pointList" class="point-list"></div>
            <button class="btn-danger" onclick="clearAllPoints()">üóëÔ∏è Effacer tous les points</button>
          </div>
          <div class="section-content">
            <div class="checkbox-group">
              <input type="checkbox" id="autoLoadTestPointsCheckbox" onchange="toggleAutoLoadTestPoints()" />
              <label for="autoLoadTestPointsCheckbox">Charger A, B, C au d√©marrage</label>
            </div>
            <button class="btn-secondary" onclick="loadTestPointsOnce()">‚ûï Charger points A, B, C maintenant</button>
            <p style="font-size: 11px; color: #666; margin-top: 5px"></p>
          </div>
        </div>

        <div class="section collapsible collapsed">
          <div class="section-header">
            <h3 style="font-size: 16px">‚ÜóÔ∏è Tracer des vecteurs</h3>
          </div>
          <div class="section-content">
            <h4 class="sub-section-title">Vecteur entre deux points :</h4>
            <label>Point de d√©part :</label>
            <select id="vectorStartPoint"></select>

            <label style="margin-top: 10px">Point d'arriv√©e :</label>
            <select id="vectorEndPoint"></select>

            <button id="addVectorFromPointsBtn" class="btn-secondary" onclick="addVectorFromPoints()">
              ‚ûï Tracer le vecteur
            </button>

            <h4 class="sub-section-title">Vecteur par coordonn√©es :</h4>
            <label>Nom du vecteur :</label>
            <input type="text" id="vectorNameCoords" placeholder="Ex: V1, Direction..." />
            <label style="margin-top: 10px; color: #2196f3">Origine du vecteur (Ox, Oy, Oz) :</label>
            <div class="coord-inputs">
              <input type="number" id="vectorOriginX" placeholder="Ox" step="1" />
              <input type="number" id="vectorOriginY" placeholder="Oy (Prof.)" step="1" />
              <input type="number" id="vectorOriginZ" placeholder="Oz (Haut.)" step="1" />
            </div>
            <label style="margin-top: 10px">Coordonn√©es (Vx, Vy, Vz) :</label>
            <div class="coord-inputs">
              <input type="number" id="vectorCoordX" placeholder="Vx" step="1" />
              <input type="number" id="vectorCoordY" placeholder="Vy" step="1" />
              <input type="number" id="vectorCoordZ" placeholder="Vz" step="1" />
            </div>

            <label style="margin-top: 10px">Origine du vecteur :</label>
            <select id="vectorOriginPoint"></select>
            <button id="addVectorFromCoordsBtn" class="btn-secondary" onclick="addVectorFromCoords()">
              ‚ûï Tracer le vecteur
            </button>

            <input type="hidden" id="editVectorId" />

            <!-- NOUVEAU : Conteneur pour les boutons d'action d'√©dition -->
            <div id="vectorEditActions" class="edit-actions-container" style="display: none">
              <button id="updateVectorBtn" class="btn-secondary" onclick="updateVector()">üíæ Mettre √† jour</button>
              <button id="deleteEditingVectorBtn" class="btn-danger" onclick="deleteEditingVector()">
                üóëÔ∏è Supprimer
              </button>
              <button id="cancelVectorEditBtn" class="btn-warning" onclick="cancelVectorEdit()">‚ùå Annuler</button>
            </div>

            <h4 class="sub-section-title">Vecteurs existants :</h4>
            <div id="vectorList" class="geometry-list"></div>
            <button class="btn-danger" onclick="clearAllVectors()">üóëÔ∏è Effacer tous les vecteurs</button>
          </div>
        </div>

        <div class="section collapsible collapsed">
          <div class="section-header">
            <h3 style="font-size: 16px">üìè Tracer des droites</h3>
          </div>
          <div class="section-content">
            <h4 class="sub-section-title">Droite par deux points :</h4>
            <label>Premier point :</label>
            <select id="lineStart"></select>
            <label style="margin-top: 10px">Deuxi√®me point :</label>
            <select id="lineEnd"></select>
            <button class="btn-secondary" onclick="addStraightLine()">‚ûï Tracer la droite</button>

            <h4 class="sub-section-title">Droite par Point et Vecteur :</h4>
            <label>Nom de la droite :</label>
            <input type="text" id="lineNamePV" placeholder="Ex: D1, Delta..." />

            <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; gap: 8px">
              <div>
                <label style="font-size: 11px">Point de passage :</label>
                <select id="linePointPVSelect"></select>
              </div>
              <div>
                <label style="font-size: 11px">Vecteur directeur :</label>
                <select id="lineVectorPVSelect"></select>
              </div>
            </div>

            <button class="btn-secondary" onclick="addLineFromPointVector()">
              ‚ûï Tracer la droite (Point + Vecteur)
            </button>

            <!-- D√âBUT MODIFICATION √âTAPE 1 : UI pour Droite par √©quation -->
            <h4 class="sub-section-title">Droite par √©quation param√©trique :</h4>
            <label>Nom de la droite :</label>
            <input type="text" id="lineNameFromEquation" placeholder="Ex: D1, MaDroite..." />

            <label style="margin-top: 10px; color: #2196f3">Point de passage (Optionnel) :</label>
            <select id="lineEquationPointSelect" onchange="onLineEquationPointChange()">
              <!-- Sera rempli par JS -->
            </select>

            <label style="font-size: 11px; color: #666">Ou coordonn√©es manuelles du point ($P_0$) :</label>
            <div class="coord-inputs">
              <input type="number" id="lineEqPointX" placeholder="Px" step="1" />
              <input type="number" id="lineEqPointY" placeholder="Py (Prof.)" step="1" />
              <input type="number" id="lineEqPointZ" placeholder="Pz (Haut.)" step="1" />
            </div>

            <label style="margin-top: 10px">√âquations (pour le vecteur directeur) :</label>
            <textarea
              id="lineEquationInput"
              rows="3"
              placeholder="x = 2t&#10;y = t&#10;z = -5t"
              style="font-family: monospace"
            ></textarea>

            <input type="hidden" id="editLineId" />

            <!-- Bouton d'ajout existant (ajoutez-lui une ID pour pouvoir le cacher) -->
            <button id="addLineFromEquationBtn" class="btn-secondary" onclick="addLineFromEquation()">
              ‚ûï Cr√©er la droite
            </button>

            <!-- Nouveaux boutons pour l'√©dition (cach√©s par d√©faut) -->
            <div id="lineEquationActions" class="edit-actions-container" style="display: none">
              <button id="updateLineBtn" class="btn-secondary" onclick="updateLine()">üíæ Mettre √† jour</button>
              <button id="deleteEditingLineBtn" class="btn-danger" onclick="deleteEditingLine()">üóëÔ∏è Supprimer</button>
              <button id="cancelLineEditBtn" class="btn-warning" onclick="cancelLineEdit()">‚ùå Annuler</button>
            </div>

            <h4 class="sub-section-title">Droites existantes :</h4>
            <div id="lineList" class="geometry-list"></div>
            <button class="btn-danger" onclick="clearStraightLines()">üóëÔ∏è Effacer les droites</button>
          </div>
        </div>

        <div class="section collapsible collapsed">
          <div class="section-header">
            <h3 style="font-size: 16px">üî∑ Tracer des plans</h3>
          </div>
          <div class="section-content">
            <h4 class="sub-section-title">Plan par 3 points :</h4>
            <label>Nom du plan :</label>
            <input type="text" id="planeName" placeholder="Ex: P1, MonPlan..." />

            <label style="margin-top: 10px">Premier point :</label>
            <select id="planeSelectP1"></select>

            <label style="margin-top: 10px">Deuxi√®me point :</label>
            <select id="planeSelectP2"></select>

            <label style="margin-top: 10px">Troisi√®me point :</label>
            <select id="planeSelectP3"></select>

            <button class="btn-warning" onclick="addPlane()">‚ûï Ajouter ce plan</button>

            <h4 class="sub-section-title">Plan par vecteur normal (√©quation) :</h4>

            <label style="color: #2196f3">Point de passage (Optionnel) :</label>
            <select id="planeEquationPointSelect" onchange="onPlaneEquationPointChange()">
              <!-- Sera rempli par JS -->
            </select>

            <label style="font-size: 11px; color: #666">Ou coordonn√©es manuelles ($P_0$) :</label>
            <div class="coord-inputs">
              <input type="number" id="planeEqPointX" placeholder="Px" step="1" />
              <input type="number" id="planeEqPointY" placeholder="Py (Prof.)" step="1" />
              <input type="number" id="planeEqPointZ" placeholder="Pz (Haut.)" step="1" />
            </div>

            <!-- <label style="margin-top: 10px">√âquation (pour le vecteur normal a,b,c) :</label>
          <input type="text" id="planeEquationInput" placeholder="Ex: 2x - y + 3z = 0" />
          <button class="btn-warning" onclick="addPlaneFromEquation()">‚ûï Cr√©er le plan</button> -->

            <h4 class="sub-section-title">Plan par √©quation :</h4>
            <label>√âquation cart√©sienne (ax+by+cz+d=0) :</label>
            <input type="text" id="planeEquationInput" placeholder="Ex: 2x - y + 3z - 6 = 0" />
            <button id="addPlaneFromEquationBtn" class="btn-warning" onclick="addPlaneFromEquation()">
              ‚ûï Cr√©er le plan depuis l'√©quation
            </button>

            <input type="hidden" id="editPlaneId" />
            <div id="planeEquationActions" class="edit-actions-container" style="display: none">
              <button id="updatePlaneBtn" class="btn-secondary" onclick="updatePlane()">üíæ Mettre √† jour</button>
              <button id="deleteEditingPlaneBtn" class="btn-danger" onclick="deleteEditingPlane()">üóëÔ∏è Supprimer</button>
              <button id="cancelPlaneEditBtn" class="btn-warning" onclick="cancelPlaneEdit()">‚ùå Annuler</button>
            </div>
            <h4 class="sub-section-title">Plans existants :</h4>
            <div id="planeList" class="geometry-list"></div>
            <button class="btn-danger" onclick="clearAllPlanes()">üóëÔ∏è Effacer tous les plans</button>
          </div>
        </div>

        <div class="section collapsible collapsed">
          <div class="section-header">
            <h3 style="font-size: 16px">üìà √âquations g√©om√©triques</h3>
          </div>
          <div class="section-content">
            <h4 class="sub-section-title">√âquation de plan :</h4>
            <label>S√©lectionner un plan pour voir son √©quation :</label>
            <select id="equationPlaneSelect" onchange="displayPlaneEquation()"></select>
            <div id="planeEquationDisplay" class="equation-display"></div>

            <h4 class="sub-section-title" style="margin-top: 20px">√âquation param√©trique de droite :</h4>
            <label>S√©lectionner une droite pour voir son √©quation :</label>
            <select id="equationLineSelect" onchange="displayLineEquation()"></select>

            <div id="lineEquationDisplay" class="equation-display"></div>
          </div>
        </div>

        <div class="section collapsible collapsed">
          <div class="section-header">
            <h3 style="font-size: 16px">üßÆ Calculs</h3>
          </div>
          <div class="section-content">
            <!-- Outils de Mesure -->
            <h4 class="sub-section-title" style="margin-top: 20px">Op√©rations sur les Vecteurs</h4>

            <!-- Somme de vecteurs -->
            <label>Somme de deux vecteurs \(\vec{u} + \vec{v}\) :</label>
            <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
              <select id="sumVectorSelect1"></select>
              <select id="sumVectorSelect2"></select>
            </div>

            <label>Point de d√©part (pour la construction ou le vecteur libre) :</label>
            <select id="sumVectorOrigin" style="margin-bottom: 8px"></select>

            <!-- MODIFICATION: Boutons pour des actions distinctes -->
            <button class="btn-violet" onclick="calculateVectorSumFree()">üñ© Cr√©er le vecteur somme (libre)</button>
            <button class="btn-warning" onclick="constructChaslesSum()">üìê Construire la somme (Chasles)</button>

            <!-- NOUVEAU: Bouton pour nettoyer la construction, cach√© par d√©faut -->
            <button
              class="btn-danger"
              onclick="clearChaslesConstruction()"
              style="display: none; margin-top: 5px"
              id="clearChaslesBtn"
            >
              üóëÔ∏è Effacer la construction
            </button>

            <div id="vectorSumResult" class="equation-display"></div>

            <!-- Produit Scalaire -->
            <label style="margin-top: 15px">Produit scalaire de deux vecteurs \( \vec{u} \cdot \vec{v} \) :</label>
            <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
              <select id="dotVectorSelect1"></select>
              <select id="dotVectorSelect2"></select>
            </div>
            <button class="btn-warning" onclick="calculateScalarProduct()">üñ© Calculer</button>
            <div id="scalarProductResult" class="equation-display"></div>

            <!-- Produit Vectoriel -->
            <label style="margin-top: 15px">Produit vectoriel de deux vecteurs \( \vec{u} \wedge \vec{v} \) :</label>
            <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
              <select id="crossVectorSelect1"></select>
              <select id="crossVectorSelect2"></select>
            </div>
            <label>Origine du vecteur produit :</label>
            <select id="crossVectorOrigin" style="margin-bottom: 8px"></select>
            <button class="btn-warning" onclick="calculateVectorProduct()">üñ© Cr√©er le vecteur produit</button>
            <div id="vectorProductResult" class="equation-display"></div>
            <h4 class="sub-section-title" style="margin-top: 20px">Projection Orthogonale</h4>
            <label>Projeter le point :</label>
            <select id="projPointSelect"></select>
            <label>Sur le plan :</label>
            <select id="projPlaneSelect"></select>
            <button class="btn-violet" onclick="projectPointOnPlane()">üìê Projeter</button>
          </div>
        </div>

        <div class="section collapsible collapsed">
          <div class="section-header">
            <h3 style="font-size: 16px">üìê Mesures et Intersections</h3>
          </div>
          <div class="section-content">
            <!-- Outils de Mesure -->
            <h4 class="sub-section-title">Mesure de Distances</h4>

            <!-- Distance Point-Point -->
            <label>Distance entre deux points :</label>
            <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
              <select id="distPointSelect1"></select>
              <select id="distPointSelect2"></select>
            </div>
            <button class="btn-warning" onclick="calculatePointPointDistance()">üñ© Mesurer</button>
            <div id="distResult1" class="equation-display"></div>

            <!-- Distance Point-Droite -->
            <label style="margin-top: 15px">Distance d'un point √† une droite :</label>
            <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
              <select id="distPointSelect3"></select>
              <select id="distLineSelect1"></select>
            </div>
            <button class="btn-warning" onclick="calculatePointLineDistance()">üñ© Mesurer</button>
            <div id="distResult2" class="equation-display"></div>

            <!-- Distance Point-Plan -->
            <label style="margin-top: 15px">Distance d'un point √† un plan :</label>
            <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
              <select id="calcPointSelect"></select>
              <select id="calcPlaneSelect1"></select>
            </div>
            <button class="btn-warning" onclick="calculatePointPlaneDistance()">üñ© Mesurer et projeter</button>
            <div id="calcResultDisplay1" class="equation-display" style="min-height: 50px"></div>

            <!-- Outils d'Angle -->
            <h4 class="sub-section-title" style="margin-top: 20px">Mesure d'Angles</h4>

            <!-- Angle Droite-Droite -->
            <label>Angle entre deux droites :</label>
            <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
              <select id="angleLineSelect1"></select>
              <select id="angleLineSelect2"></select>
            </div>
            <button class="btn-warning" onclick="calculateLineLineAngle()">üñ© Mesurer</button>
            <div id="angleResult1" class="equation-display"></div>

            <!-- Angle Plan-Plan -->
            <label style="margin-top: 15px">Angle entre deux plans :</label>
            <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
              <select id="anglePlaneSelect1"></select>
              <select id="anglePlaneSelect2"></select>
            </div>
            <button class="btn-warning" onclick="calculatePlanePlaneAngle()">üñ© Mesurer</button>
            <div id="angleResult2" class="equation-display"></div>

            <!-- Angle Droite-Plan -->
            <label style="margin-top: 15px">Angle entre une droite et un plan :</label>
            <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
              <select id="angleLineSelect3"></select>
              <select id="anglePlaneSelect3"></select>
            </div>
            <button class="btn-warning" onclick="calculateLinePlaneAngle()">üñ© Mesurer</button>
            <div id="angleResult3" class="equation-display"></div>

            <!-- Intersections -->
            <h4 class="sub-section-title" style="margin-top: 20px">Calcul d'Intersections</h4>

            <!-- Intersection Droite-Plan -->
            <label>Intersection d'une droite et d'un plan :</label>
            <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
              <select id="calcLineSelect"></select>
              <select id="calcPlaneSelect2"></select>
            </div>
            <button class="btn-warning" onclick="calculateLinePlaneIntersection()">üñ© Calculer l'intersection</button>
            <div id="calcResultDisplay2" class="equation-display"></div>

            <!-- Intersection Plan-Plan -->
            <label style="margin-top: 15px">Intersection de deux plans :</label>
            <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
              <select id="calcPlaneSelect3"></select>
              <select id="calcPlaneSelect4"></select>
            </div>
            <button class="btn-warning" onclick="calculatePlanePlaneIntersection()">üñ© Calculer l'intersection</button>
            <div id="calcResultDisplay3" class="equation-display" style="min-height: 60px"></div>

            <!-- Intersection Droite-Droite -->
            <h4 class="sub-section-title" style="margin-top: 20px">Intersection de deux droites :</h4>
            <label>S√©lectionner les deux droites :</label>
            <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
              <select id="calcLineSelect1"></select>
              <select id="calcLineSelect2"></select>
            </div>
            <button class="btn-warning" onclick="calculateLineLineIntersection()">üñ© Analyser l'intersection</button>
            <div id="calcResultDisplay4" class="equation-display" style="margin-top: 10px; min-height: 50px"></div>

            <h4 class="sub-section-title" style="margin-top: 20px">Perpendiculaire commune (Droites)</h4>
            <div class="coord-inputs" style="grid-template-columns: 1fr 1fr; margin-bottom: 8px">
              <select id="perpLine1"></select>
              <select id="perpLine2"></select>
            </div>
            <button class="btn-warning" onclick="calculateCommonPerpendicular()">üñ© Tracer la perpendiculaire</button>
            <div id="perpResult" class="equation-display"></div>
          </div>
        </div>

        <div class="section collapsible collapsed">
          <div class="section-header">
            <h3 style="font-size: 16px">üîÑ Transformations</h3>
          </div>
          <div class="section-content">
            <p id="transformations-hint" style="font-size: 12px; color: #888; text-align: center">
              S√©lectionnez un objet dans la sc√®ne 3D pour activer les transformations.
            </p>

            <!-- Sous-section Translation -->
            <div id="transformations-container" style="display: none">
              <h4 class="sub-section-title">Translation</h4>
              <label>Vecteur de translation (dX, dY, dZ) :</label>
              <div class="coord-inputs">
                <input type="number" id="transX" placeholder="dX" value="0" step="1" />
                <input type="number" id="transY" placeholder="dY" value="0" step="1" />
                <input type="number" id="transZ" placeholder="dZ" value="0" step="1" />
              </div>
              <button class="btn-secondary" onclick="applyTranslation()">‚û°Ô∏è Appliquer la Translation</button>

              <!-- Sous-section Rotation -->
              <h4 class="sub-section-title" style="margin-top: 20px">Rotation</h4>
              <label>Centre de rotation :</label>
              <select id="rotationCenterSelect">
                <option value="origin">Origine du rep√®re (0,0,0)</option>
                <!-- Les points seront ajout√©s dynamiquement ici -->
              </select>
              <label style="margin-top: 10px">Axe de rotation :</label>
              <select id="rotationAxisSelect">
                <option value="x">Axe X</option>
                <option value="y">Axe Y</option>
                <option value="z">Axe Z</option>
              </select>
              <label style="margin-top: 10px">Angle de rotation (en degr√©s) :</label>
              <input type="number" id="rotationAngle" value="90" step="1" />
              <button class="btn-secondary" onclick="applyRotation()">üîÑ Appliquer la Rotation</button>

              <!-- Sous-section Sym√©trie -->
              <h4 class="sub-section-title" style="margin-top: 20px">Sym√©trie</h4>
              <label>Sym√©trie par rapport √† :</label>

              <select id="symmetryTypeSelect" onchange="updateSymmetryUI()">
                <option value="origin">Origine (0,0,0)</option>

                <option value="axis_x">Axe X</option>
                <option value="axis_y">Axe Y (Profondeur)</option>
                <option value="axis_z">Axe Z (Hauteur)</option>

                <option value="plane_xy">Plan XY (Sol)</option>
                <option value="plane_xz">Plan XZ (Face)</option>
                <option value="plane_yz">Plan YZ (C√¥t√©)</option>
                <option value="">-- Choisir un type --</option>
                <option value="point">Un Point</option>
                <option value="line">Une Droite</option>
                <option value="plane">Un Plan</option>
              </select>
              <div id="symmetryOptionsContainer" style="margin-top: 10px">
                <!-- Les options (s√©lecteurs de point, droite, plan) appara√Ætront ici -->
              </div>
              <button class="btn-secondary" id="applySymmetryBtn" style="display: none" onclick="applySymmetry()">
                üîπ Appliquer la Sym√©trie
              </button>
            </div>
          </div>
        </div>
        <div style="text-align: center; font-size: 10px; color: #888; margin-top: 20px; padding-top: 5px">
          Copyright Michel ESPARSA 26/11/2025
        </div>

        <div id="contextMenu" class="context-menu" style="display: none">
          <ul id="contextMenuItems" class="context-menu-items">
            <!-- Les options du menu seront inject√©es ici par JavaScript -->
          </ul>
        </div>
      </div>

      <!-- =========================================
     NOUVEAU : PANNEAU TABLEUR (BAS)
     ========================================= -->
      <div id="spreadsheetContainer" class="spreadsheet-hidden">
        <div class="spreadsheet-header">
          <div class="spreadsheet-tabs">
            <button class="tab-btn active" onclick="switchSpreadsheetTab('points')">Points</button>
            <button class="tab-btn" onclick="switchSpreadsheetTab('vectors')">Vecteurs</button>
            <button class="tab-btn" onclick="switchSpreadsheetTab('lines')">Droites</button>
            <button class="tab-btn" onclick="switchSpreadsheetTab('planes')">Plans</button>
          </div>
          <div class="spreadsheet-controls">
            <button class="close-spreadsheet-btn" onclick="toggleSpreadsheet()">‚ñº Fermer</button>
          </div>
        </div>
        <div class="spreadsheet-body">
          <table id="spreadsheetTable">
            <thead>
              <!-- Les en-t√™tes seront g√©n√©r√©s par JS -->
            </thead>
            <tbody>
              <!-- Le contenu sera g√©n√©r√© par JS -->
            </tbody>
          </table>
        </div>
      </div>
    </div>
    <!-- Bouton flottant pour ouvrir le tableur (en bas √† gauche) -->
    <button id="openSpreadsheetBtn" onclick="toggleSpreadsheet()">üìÖ Tableur de donn√©es</button>

    <div
      id="credits"
      style="
        position: fixed;
        bottom: 10px;
        right: 10px;
        color: var(--text-color);
        font-size: 12px;
        z-index: 1000;
        padding: 5px 10px;
      "
    >
      ¬© 2025 Michel ESPARSA
    </div>

    <script>
      // =====================================================================================
      // SECTION 1 : CLASSES DES OBJETS G√âOM√âTRIQUES
      // =====================================================================================

      /**
       * Classe repr√©sentant un point 3D.
       */
      class Point {
        constructor(name, x, y, z, color = 0xff6b35, derivedFrom = null) {
          this.name = name;
          this.position = new THREE.Vector3(x, y, z);
          this.color = new THREE.Color(color);
          this.derivedFrom = derivedFrom;
          const sphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
          const sphereMaterial = new THREE.MeshPhongMaterial({
            color: this.color,
          });
          this.mesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
          this.mesh.position.copy(this.position);
          this.mesh.userData = { type: "point", instance: this };
          this.label = createGenericTextLabel(name);
          this.updateLabelPosition();
        }
        // Dans la classe Point
        createTextLabel(text) {
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          canvas.width = 512;
          canvas.height = 256;

          // Vider le canvas pour un fond transparent
          context.clearRect(0, 0, canvas.width, canvas.height);

          context.font = "Bold 96px Arial";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.strokeStyle = "white";
          context.lineWidth = 12;
          context.strokeText(text, canvas.width / 2, canvas.height / 2);
          context.fillStyle = "black";
          context.fillText(text, canvas.width / 2, canvas.height / 2);

          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;

          // La correction est ici
          const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false, // Garantit que le label est toujours visible
          });

          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.scale.set(2, 1, 1);
          sprite.center.set(0.5, 0);
          return sprite;
        }

        updateLabelPosition() {
          this.label.position.set(this.position.x, this.position.y + 0.35, this.position.z);
        }
        update(name, x, y, z) {
          this.name = name;
          this.position.set(x, y, z);
          this.mesh.position.copy(this.position);
          scene.remove(this.label);
          this.label = createGenericTextLabel(name);
          this.updateLabelPosition();
          scene.add(this.label);
        }
        addToScene(scene) {
          // On s'assure que les points ont un renderOrder plus √©lev√© que les axes
          this.mesh.renderOrder = 10;
          this.label.renderOrder = 11; // Les labels doivent √™tre au-dessus des points

          scene.add(this.mesh);
          scene.add(this.label);
        }
        removeFromScene(scene) {
          scene.remove(this.mesh);
          scene.remove(this.label);
          if (this.mesh.geometry) this.mesh.geometry.dispose();
          if (this.mesh.material) this.mesh.material.dispose();
          if (this.label.material) {
            if (this.label.material.map) this.label.material.map.dispose(); // Texture du texte
            this.label.material.dispose();
          }
        }
      }

      /**
       * Classe repr√©sentant une droite 3D.
       */
      class Line3D {
        constructor(name, startPoint, directorVector, color = 0x00ced1, derivedFrom = null) {
          this.id = nextStraightLineId++;
          this.name = name;
          this.startPoint = startPoint.clone();
          this.directorVector = directorVector.clone();
          this.color = new THREE.Color(color);
          this.derivedFrom = derivedFrom;
          this.isVisible = true;
          const lineLength = 100;
          const dir = this.directorVector.clone().normalize();
          const visualStart = new THREE.Vector3().addVectors(this.startPoint, dir.clone().multiplyScalar(-lineLength));
          const visualEnd = new THREE.Vector3().addVectors(this.startPoint, dir.clone().multiplyScalar(lineLength));
          const geometry = new THREE.BufferGeometry().setFromPoints([visualStart, visualEnd]);
          const material = new THREE.LineBasicMaterial({ color: this.color });
          this.mesh = new THREE.Line(geometry, material);
          this.mesh.userData = { type: "line", instance: this };
        }

        // --- NOUVELLE M√âTHODE √Ä AJOUTER ---
        setVisibility(visible) {
          this.isVisible = visible;
          this.mesh.visible = visible;
        }
        // --- FIN DE L'AJOUT ---

        addToScene(scene) {
          scene.add(this.mesh);
        }
        removeFromScene(scene) {
          scene.remove(this.mesh);
          if (this.mesh.geometry) this.mesh.geometry.dispose();
          if (this.mesh.material) this.mesh.material.dispose();
        }
      }
      /**
       * Classe repr√©sentant un plan 3D.
       */
      class Plane {
        constructor(
          name,
          pointOnPlane,
          normal, // C'est le vecteur AVANT normalisation
          color = 0xffeb3b,
          derivedFrom = null
        ) {
          this.id = nextPlaneId++;
          this.name = name;
          this.pointOnPlane = pointOnPlane.clone();

          // --- MODIFICATION ---
          // On stocke le vecteur original pour l'affichage des √©quations
          this.displayNormal = normal.clone();
          // On utilise le vecteur normalis√© pour le rendu 3D
          this.normal = normal.clone().normalize();
          // --- FIN DE LA MODIFICATION ---

          this.color = new THREE.Color(color);
          this.derivedFrom = derivedFrom;
          this.isVisible = true;
          const planeGeometry = new THREE.PlaneGeometry(15, 15);
          const planeMaterial = new THREE.MeshPhongMaterial({
            color: this.color,
            transparent: true,
            opacity: 0.4, // Opacit√© r√©duite pour une meilleure visibilit√© des axes
            side: THREE.DoubleSide,
            depthWrite: false, // Important pour la visibilit√© des axes
            polygonOffset: true, // √âvite les probl√®mes de z-fighting
            polygonOffsetFactor: 1, // Ajuste la profondeur du plan
            polygonOffsetUnits: 1,
          });
          this.mesh = new THREE.Mesh(planeGeometry, planeMaterial);
          this.mesh.position.copy(this.pointOnPlane);
          // La normalisation est importante pour la ligne suivante
          this.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), this.normal);
          this.mesh.userData = { type: "plane", instance: this };
        }
        // ... le reste de la classe (setVisibility, addToScene, etc.) ne change pas
        setVisibility(visible) {
          this.isVisible = visible;
          this.mesh.visible = visible;
        }
        addToScene(scene) {
          scene.add(this.mesh);
        }
        removeFromScene(scene) {
          scene.remove(this.mesh);
          if (this.mesh.geometry) this.mesh.geometry.dispose();
          if (this.mesh.material) this.mesh.material.dispose();
        }
      }
      /**
       * Classe repr√©sentant un vecteur 3D.
       */

      class Vector {
        constructor(name, origin, components, color = 0xffa500, derivedFrom = null) {
          this.id = nextVectorId++;
          this.name = name;
          this.origin = origin.clone();
          this.components = components.clone();
          this.color = new THREE.Color(color);
          this.derivedFrom = derivedFrom;
          this.isVisible = true;
          this.arrowHelper = null;

          // --- AJOUTS POUR L'√âTIQUETTE ---
          this.isLabelVisible = true; // Par d√©faut, l'√©tiquette est visible
          this.label = createGenericTextLabel(name);
          this.updateLabelPosition();
          // --- FIN DES AJOUTS ---

          this.createArrowHelper();
        }

        // --- NOUVELLE M√âTHODE (copi√©e de la classe Point) ---
        createTextLabel(text) {
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          canvas.width = 512;
          canvas.height = 256;

          context.clearRect(0, 0, canvas.width, canvas.height);

          context.font = "Bold 96px Arial";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.strokeStyle = "white";
          context.lineWidth = 12;
          context.strokeText(text, canvas.width / 2, canvas.height / 2);
          context.fillStyle = "black";
          context.fillText(text, canvas.width / 2, canvas.height / 2);

          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;

          const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false,
          });

          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.scale.set(2, 1, 1);
          sprite.center.set(0.5, 0);
          return sprite;
        }

        // --- NOUVELLE M√âTHODE ---
        updateLabelPosition() {
          if (!this.label) return;
          // Positionne l'√©tiquette au milieu du vecteur
          const midPoint = new THREE.Vector3().addVectors(this.origin, this.components.clone().multiplyScalar(0.5));
          this.label.position.copy(midPoint);
          // On peut ajouter un petit d√©calage pour √©viter que ce soit directement sur la fl√®che
          this.label.position.y += 0.2;
        }

        // --- NOUVELLE M√âTHODE ---
        setLabelVisibility(visible) {
          this.isLabelVisible = visible;
          if (this.label) {
            this.label.visible = visible;
          }
        }

        createArrowHelper() {
          if (this.arrowHelper) this.removeFromScene(scene);
          const length = this.components.length();
          if (length > 1e-6) {
            this.arrowHelper = new THREE.ArrowHelper(
              this.components.clone().normalize(),
              this.origin,
              length,
              this.color,
              0.4,
              0.2
            );
            this.arrowHelper.line.userData = { type: "vector", instance: this };
            this.arrowHelper.cone.userData = { type: "vector", instance: this };
          } else {
            this.arrowHelper = null;
          }
        }

        update(name, origin, components) {
          this.name = name;
          this.origin.copy(origin);
          this.components.copy(components);

          // --- MISE √Ä JOUR DE L'√âTIQUETTE ---
          if (this.label) scene.remove(this.label);
          this.label = createGenericTextLabel(name);
          this.updateLabelPosition();
          if (this.isVisible) scene.add(this.label);
          this.setLabelVisibility(this.isLabelVisible); // Applique la visibilit√© actuelle
          // --- FIN DE LA MISE √Ä JOUR ---

          this.createArrowHelper();
          this.addToScene(scene);
          this.setVisibility(this.isVisible);
        }

        setVisibility(visible) {
          this.isVisible = visible;
          if (this.arrowHelper) this.arrowHelper.visible = visible;
          // --- AJOUT ---
          // La visibilit√© globale du vecteur affecte aussi son √©tiquette
          if (this.label) this.label.visible = visible && this.isLabelVisible;
        }

        addToScene(scene) {
          if (this.arrowHelper) scene.add(this.arrowHelper);
          // --- AJOUT ---
          if (this.label) {
            this.label.renderOrder = 11; // Pour √™tre au-dessus des autres objets
            scene.add(this.label);
          }
        }

        removeFromScene(scene) {
          if (this.arrowHelper) scene.remove(this.arrowHelper);
          // --- AJOUT ---
          if (this.label) scene.remove(this.label);
        }
      }
      // =====================================================================================
      // SECTION 2 : GESTIONNAIRE CENTRAL DE LA G√âOM√âTRIE
      // =====================================================================================

      class GeometryManager {
        constructor(scene) {
          this.scene = scene;
          this.points = [];
          this.lines = [];
          this.planes = [];
          this.vectors = [];
        }
        /**
         * G√©n√®re un nom unique pour un type d'objet donn√© en ajoutant un suffixe si n√©cessaire.
         * @param {string} baseName Le nom de base souhait√©.
         * @param {string} objectType Le type d'objet : 'point', 'line', 'plane', ou 'vector'.
         * @returns {string} Un nom garanti unique.
         */
        generateUniqueName(baseName, objectType) {
          let nameList;
          // 1. S√©lectionner la bonne liste d'objets en fonction du type
          switch (objectType) {
            case "point":
              nameList = this.points.map((p) => p.name);
              break;
            case "line":
              nameList = this.lines.map((l) => l.name);
              break;
            case "plane":
              nameList = this.planes.map((p) => p.name);
              break;
            case "vector":
              nameList = this.vectors.map((v) => v.name);
              break;
            default:
              // Si le type est inconnu, on ne peut pas v√©rifier, on retourne le nom de base
              return baseName;
          }

          // 2. V√©rifier si le nom de base est d√©j√† pris
          if (!nameList.includes(baseName)) {
            return baseName; // Le nom est d√©j√† unique, on le retourne
          }

          // 3. Si le nom est pris, on cherche un suffixe
          let uniqueName = baseName;
          let counter = 1;
          do {
            uniqueName = `${baseName}_${counter}`;
            counter++;
          } while (nameList.includes(uniqueName));

          return uniqueName;
        }

        addPoint(point) {
          this.points.push(point);
          point.addToScene(this.scene);
        }
        addLine(line) {
          this.lines.push(line);
          line.addToScene(this.scene);
        }
        addPlane(plane) {
          this.planes.push(plane);
          plane.addToScene(this.scene);
        }
        addVector(vector) {
          this.vectors.push(vector);
          vector.addToScene(this.scene);
        }
        _removeInstance(array, instance) {
          const index = array.indexOf(instance);
          if (index > -1) {
            instance.removeFromScene(this.scene);
            array.splice(index, 1);
            return true;
          }
          return false;
        }
        removePoint(instance) {
          return this._removeInstance(this.points, instance);
        }
        removeLine(instance) {
          return this._removeInstance(this.lines, instance);
        }
        removePlane(instance) {
          return this._removeInstance(this.planes, instance);
        }
        removeVector(instance) {
          return this._removeInstance(this.vectors, instance);
        }
        findLineById(id) {
          return this.lines.find((l) => l.id === id);
        }
        findPlaneById(id) {
          return this.planes.find((p) => p.id === id);
        }
        findVectorById(id) {
          return this.vectors.find((v) => v.id === id);
        }

        findPointAt(position) {
          const tolerance = 0.01;
          for (const point of this.points) {
            if (point.position.distanceTo(position) < tolerance) {
              return point;
            }
          }
          return null;
        }
        findObjectByName(name) {
          const allObjects = [...this.points, ...this.lines, ...this.planes];
          return allObjects.find((obj) => obj.name === name);
        }

        clearAll() {
          [...this.points, ...this.lines, ...this.planes, ...this.vectors].forEach((obj) =>
            obj.removeFromScene(this.scene)
          );
          this.points = [];
          this.lines = [];
          this.planes = [];
          this.vectors = [];
          nextStraightLineId = 0;
          nextPlaneId = 0;
          nextVectorId = 0;
        }
      }

      // =====================================================================================
      // SECTION 3 : VARIABLES GLOBALES ET INITIALISATION
      // =====================================================================================

      let scene, camera, renderer, geometryManager;
      let isDragging = false,
        isPanning = false,
        wasDragged = false;
      let previousMousePosition = { x: 0, y: 0 };
      let cameraRotation = { x: 0.5, y: 0.5 };
      let cameraDistance = 15;
      let cameraTarget = new THREE.Vector3(0, 0, 0);
      let initialPinchDistance = 0;
      let panelOpen = false;
      let nextStraightLineId = 0;
      let nextPlaneId = 0;
      let nextVectorId = 0;
      let raycaster,
        mouse,
        selectedObjectInstance = null;
      // let wasPanningOrZooming = false; // Pour distinguer un geste cam√©ra d'un tap
      let currentConstructionObjects = [];
      let splashTimer = null;
      let blockNextClick = false; // Variable pour bloquer le "clic fant√¥me" sur mobile
      const HIGHLIGHT_COLOR = 0xffcc00; // Jaune vif pour la surbrillance
      const LONG_PRESS_DURATION = 500;
      let touchStartPosition = { x: 0, y: 0 };
      let lastTap = 0;
      let transformControl;
      let isGizmoDragging = false;
      let lastTooltipX = 0;
      let lastTooltipY = 0;

      const swipeState = {
        isSwiping: false,
        lock: null,
        startX: 0,
        startY: 0,
        currentX: 0, // NOUVEAU : stocke la position actuelle
        startTime: 0, // NOUVEAU : pour calculer la vitesse
        panelWidth: 0, // NOUVEAU : pour √©viter de recalculer
      };
      const SWIPE_EDGE_ZONE = 50; // Augment√© √† 50px pour faciliter la prise en main
      const SWIPE_THRESHOLD_VELOCITY = 0.3; // Vitesse minimale pour un "flick"

      function gcd(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        return b === 0 ? a : gcd(b, a % b);
      }

      function gcdOfThree(a, b, c) {
        return gcd(gcd(a, b), c);
      }

      function init() {
        // 1. Initialisation de base (Sc√®ne, Cam√©ra, Rendu)
        scene = new THREE.Scene();
        geometryManager = new GeometryManager(scene);
        scene.background = new THREE.Color(0xf0f0f0);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("container").appendChild(renderer.domElement);

        // 2. Lumi√®res
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 15, 10);
        scene.add(directionalLight);

        // 3. Aides visuelles (Axes et Grille)
        // createAxes();
        // const gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xe0e0e0);
        // On place le quadrillage en arri√®re-plan
        // gridHelper.renderOrder = -1;
        // gridHelper.material.depthTest = false;
        // scene.add(gridHelper);
        initTheme(); // Cela va cr√©er la grille, les axes et d√©finir la couleur de fond
        // ============================================================
        // 4. CORRECTION GIZMO (TransformControls)
        // ============================================================
        transformControl = new THREE.TransformControls(camera, renderer.domElement);

        // A. √âcouteur : Quand on commence ou finit de bouger le Gizmo
        transformControl.addEventListener("dragging-changed", function (event) {
          isGizmoDragging = event.value;

          if (isGizmoDragging) {
            // D√âBUT du d√©placement
            isDragging = false;
            isPanning = false;
          } else {
            // FIN du d√©placement (rel√¢chement de la souris)

            // --- AJOUT STEP 3 : On valide math√©matiquement le mouvement ---
            finalizeGizmoMovement();
            // -------------------------------------------------------------

            // NOTE : finalizeGizmoMovement appelle d√©j√† updateAllUI() et saveState()
            // donc pas besoin de le refaire ici.

            blockNextClick = true;
            setTimeout(() => {
              blockNextClick = false;
            }, 100);
          }
        });

        // B. √âcouteur : Pendant que l'objet bouge (Mise √† jour temps r√©el)
        transformControl.addEventListener("change", function () {
          // On ne fait rien si aucun objet n'est s√©lectionn√©
          if (!selectedObjectInstance) return;

          // Cette fonction met √† jour les coordonn√©es JS et les inputs du formulaire
          syncDataFromGizmo();
          //Met √† jour l'info-bulle en temps r√©el
          updateTooltipFromGizmo();
        });

        scene.add(transformControl);
        // ============================================================

        // 5. Reste de l'initialisation
        setupEventListeners();
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Gestion de la case √† cocher "Chargement auto"
        const autoLoadCheckbox = document.getElementById("autoLoadTestPointsCheckbox");
        if (localStorage.getItem("autoLoadTestPoints") === "true") {
          autoLoadCheckbox.checked = true;
          addFixedTestPoints();
        }

        // Valeurs par d√©faut pour les √©quations
        document.getElementById("lineEquationInput").value = "x = 1 + 2t\ny = -3 + 3t\nz = 4 - 5t";
        document.getElementById("planeEquationInput").value = "2x - y + 3z - 4 = 0";

        document.getElementById("vectorOriginPoint").addEventListener("change", function () {
          const selectedValue = this.value;

          // 1. Si on choisit l'Origine (0,0,0)
          if (selectedValue === "origin") {
            document.getElementById("vectorOriginX").value = "0";
            document.getElementById("vectorOriginY").value = "0";
            document.getElementById("vectorOriginZ").value = "0";
          }
          // 2. Si on choisit un Point existant (A, B, C...)
          else if (selectedValue !== "") {
            const pointIndex = parseInt(selectedValue);
            const p = geometryManager.points[pointIndex];

            if (p) {
              // Remplissage automatique des champs (Attention √† l'inversion Y/Z pour l'UI)
              document.getElementById("vectorOriginX").value = formatNumber(p.position.x);
              document.getElementById("vectorOriginY").value = formatNumber(p.position.z); // Profondeur (UI Y)
              document.getElementById("vectorOriginZ").value = formatNumber(p.position.y); // Hauteur (UI Z)
            }
          }
        });
        // Lancement
        updateCameraPosition();
        animate();
        updateAllUI();
        saveState();
        document.getElementById("lineEqPointX").value = "";
        document.getElementById("lineEqPointY").value = "";
        document.getElementById("lineEqPointZ").value = "";
        document.getElementById("lineEquationPointSelect").value = "";
      }

      function formatNumber(value, decimalPlaces = 2) {
        if (typeof value !== "number" || isNaN(value)) {
          return value; // Retourne la valeur telle quelle si ce n'est pas un nombre
        }
        // V√©rifie si la valeur est "proche" d'un entier
        if (Math.abs(value - Math.round(value)) < 1e-6) {
          return Math.round(value).toString();
        }
        return value.toFixed(decimalPlaces);
      }

      function createGenericTextLabel(text) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = 512;
        canvas.height = 256;

        context.clearRect(0, 0, canvas.width, canvas.height);

        context.font = "Bold 96px Arial";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.lineWidth = 12;

        if (isDarkMode) {
          // Mode Sombre : Texte Blanc avec contour Noir (pour contraste sur fond sombre)
          context.strokeStyle = "black";
          context.strokeText(text, canvas.width / 2, canvas.height / 2);
          context.fillStyle = "white";
          context.fillText(text, canvas.width / 2, canvas.height / 2);
        } else {
          // Mode Clair : Texte Noir avec contour Blanc (standard)
          context.strokeStyle = "white";
          context.strokeText(text, canvas.width / 2, canvas.height / 2);
          context.fillStyle = "black";
          context.fillText(text, canvas.width / 2, canvas.height / 2);
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;

        const spriteMaterial = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          depthTest: false,
        });

        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(2, 1, 1);
        sprite.center.set(0.5, 0);
        return sprite;
      }

      function setupEventListeners() {
        const canvas = renderer.domElement;
        const panel = document.getElementById("panel");

        canvas.addEventListener("contextmenu", onRightClick);
        canvas.addEventListener("click", onObjectClick);
        canvas.addEventListener("mousedown", onMouseDown);
        canvas.addEventListener("mousemove", onMouseMove);
        canvas.addEventListener("mouseup", onMouseUp);
        canvas.addEventListener("wheel", onWheel);

        document.addEventListener("touchstart", handleTouchStart, { passive: false });
        document.addEventListener("touchmove", handleTouchMove, { passive: false });
        document.addEventListener("touchend", handleTouchEnd);

        window.addEventListener("resize", onWindowResize);

        window.addEventListener("keydown", (event) => {
          // 1. Raccourcis existants (T, R, Echap, Ctrl+Z)
          if (event.key.toLowerCase() === "t") transformControl.setMode("translate");
          if (event.key.toLowerCase() === "r") transformControl.setMode("rotate");

          if (event.key === "Escape") {
            hideContextMenu();
            if (panelOpen) togglePanel();
            if (selectedObjectInstance) {
              deselectCurrentObject();
              cancelEdit();
              cancelVectorEdit();
            }
          }

          if ((event.ctrlKey || event.metaKey) && event.key === "z") {
            event.preventDefault();
            undo();
          }
          if ((event.ctrlKey || event.metaKey) && event.key === "y") {
            event.preventDefault();
            redo();
          }

          // 2. NOUVEAU : Gestion de la touche SUPPR (Delete)
          // --- DANS setupEventListeners, partie window.addEventListener("keydown"...) ---

          // Remplacez le bloc "if (event.key === "Delete" || event.key === "Del")" par ceci :

          if (event.key === "Delete" || event.key === "Del") {
            // AJOUT DE LA S√âCURIT√â ICI :
            const tag = document.activeElement.tagName.toUpperCase();
            if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT") {
              return; // On ne fait rien si l'utilisateur √©crit
            }

            // Le reste reste identique :
            if (selectedObjectInstance) {
              const inst = selectedObjectInstance;
              if (inst instanceof Point) {
                const index = geometryManager.points.indexOf(inst);
                if (index > -1) removePoint(index);
              } else if (inst instanceof Vector) {
                removeVectorById(inst.id);
              } else if (inst instanceof Line3D) {
                removeStraightLineById(inst.id);
              } else if (inst instanceof Plane) {
                removePlaneById(inst.id);
              }
            }
          }
        });

        document.addEventListener("mousedown", (e) => {
          const menu = document.getElementById("contextMenu");
          if (menu.style.display === "block" && !menu.contains(e.target)) {
            hideContextMenu();
          }
        });

        document.getElementById("contextMenu").addEventListener("mousedown", (e) => e.stopPropagation());

        const stopPropagation = (e) => e.stopPropagation();
        panel.addEventListener("mousedown", stopPropagation);
        panel.addEventListener("wheel", stopPropagation);
        panel.addEventListener("contextmenu", stopPropagation);

        const snapCtrl = document.getElementById("snapControl");
        if (snapCtrl) {
          snapCtrl.addEventListener("mousedown", stopPropagation);
          snapCtrl.addEventListener("touchstart", stopPropagation); // Important pour le tactile
          snapCtrl.addEventListener("contextmenu", stopPropagation); // Bloque le menu contextuel
          snapCtrl.addEventListener("wheel", stopPropagation);
        }
      }

      function onRightClick(event) {
        event.preventDefault();
        console.log("üëâ 1. Clic droit d√©tect√© √† :", event.clientX, event.clientY);
        findObjectAndShowMenu(event.clientX, event.clientY);
      }

      function onObjectClick(event) {
        if (blockNextClick) {
          blockNextClick = false;
          return;
        }
        if (wasDragged) return;
        performRaycastSelection(event.clientX, event.clientY);
      }

      function handleTouchStart(e) {
        wasDragged = false;
        const touch = e.touches[0];

        // 1. PROTECTION UI
        if (
          e.target.closest("#openBtn") ||
          e.target.closest("#cameraControls") ||
          e.target.closest("#spreadsheetContainer") ||
          e.target.closest("#openSpreadsheetBtn")
        ) {
          return;
        }

        // 2. INITIALISATION SWIPE
        // On d√©tecte si on touche le bord gauche (si ferm√©) ou le panneau (si ouvert)
        // Zone de d√©tection √©largie √† 40px
        const canStartOpening = !panelOpen && touch.clientX < 40;
        const canStartClosing = panelOpen && e.target.closest("#panel");

        if (canStartOpening || canStartClosing) {
          swipeState.isSwiping = true;
          swipeState.lock = null;
          swipeState.startX = touch.clientX;
          swipeState.startY = touch.clientY;

          const panel = document.getElementById("panel");

          // CORRECTION MAJEURE : On calcule la largeur totale r√©elle (Largeur + Marge CSS 20px)
          const totalWidth = panel.offsetWidth + 20;

          // Si cach√©, on part de -totalWidth. Si ouvert, on part de 0.
          swipeState.panelStartTranslateX = panel.classList.contains("hidden") ? -totalWidth : 0;

          // On coupe l'animation tout de suite pour √©viter la latence
          panel.classList.add("no-transition");
          return;
        }

        swipeState.isSwiping = false;

        // 3. Protection Gizmo
        if (typeof transformControl !== "undefined" && transformControl && selectedObjectInstance) {
          mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
          raycaster.setFromCamera(mouse, camera);
          const gizmoIntersects = raycaster.intersectObjects(transformControl.children, true);
          if (gizmoIntersects.length > 0) return;
        }

        // 4. Init Cam√©ra
        if (e.touches.length === 1) {
          isDragging = true;
          isPanning = false;
          previousMousePosition = { x: touch.clientX, y: touch.clientY };
          touchStartPosition = { x: touch.clientX, y: touch.clientY };
        } else if (e.touches.length >= 2) {
          isPanning = true;
          isDragging = false;
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
          previousMousePosition = {
            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
            y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
          };
        }
      }

      function handleTouchMove(e) {
        // 1. S√©curit√© Gizmo
        if (typeof isGizmoDragging !== "undefined" && isGizmoDragging) return;

        // 2. Gestion Swipe Panneau
        if (swipeState.isSwiping) {
          const touch = e.touches[0];
          const deltaX = touch.clientX - swipeState.startX;
          const deltaY = touch.clientY - swipeState.startY;

          if (!swipeState.lock) {
            swipeState.lock = Math.abs(deltaX) > Math.abs(deltaY) ? "horizontal" : "vertical";
          }

          if (swipeState.lock === "horizontal") {
            e.preventDefault();
            const panel = document.getElementById("panel");

            // Calcul de la nouvelle position
            let newX = swipeState.panelStartTranslateX + deltaX;

            // CORRECTION MAJEURE : Bornes correctes (-LargeurTotale √† 0)
            const totalWidth = panel.offsetWidth + 20;
            newX = Math.max(-totalWidth, Math.min(0, newX));

            panel.style.transform = `translateX(${newX}px)`;
          }
          return;
        }

        // Suite logique cam√©ra (inchang√©e)
        const touch = e.touches[0];
        const moveX = Math.abs(touch.clientX - touchStartPosition.x);
        const moveY = Math.abs(touch.clientY - touchStartPosition.y);

        if (moveX > 5 || moveY > 5) {
          wasDragged = true;
        }

        if (isDragging && e.touches.length === 1) {
          e.preventDefault();
          if (wasDragged) {
            const dX = touch.clientX - previousMousePosition.x;
            const dY = touch.clientY - previousMousePosition.y;
            cameraRotation.y += dX * 0.005;
            cameraRotation.x += dY * 0.005;
            cameraRotation.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraRotation.x));
            updateCameraPosition();
            previousMousePosition = { x: touch.clientX, y: touch.clientY };
          }
        } else if (isPanning && e.touches.length >= 2) {
          e.preventDefault();
          wasDragged = true;
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentMidX = (touch1.clientX + touch2.clientX) / 2;
          const currentMidY = (touch1.clientY + touch2.clientY) / 2;
          const panDX = currentMidX - previousMousePosition.x;
          const panDY = currentMidY - previousMousePosition.y;
          if (Math.abs(panDX) > 0.5 || Math.abs(panDY) > 0.5) {
            panCamera(panDX, panDY);
          }
          const dx = touch1.clientX - touch2.clientX;
          const dy = touch1.clientY - touch2.clientY;
          const currentPinchDistance = Math.sqrt(dx * dx + dy * dy);
          const diff = initialPinchDistance - currentPinchDistance;
          if (Math.abs(diff) > 1) {
            zoomCamera(diff * 0.05);
            initialPinchDistance = currentPinchDistance;
          }
          previousMousePosition = { x: currentMidX, y: currentMidY };
        }
      }

      function handleTouchEnd(e) {
        // 1. PROTECTION UI
        if (
          e.target.closest("#openBtn") ||
          e.target.closest("#cameraControls") ||
          e.target.closest("#spreadsheetContainer") ||
          e.target.closest("#openSpreadsheetBtn") ||
          e.target.closest("#contextMenu")
        ) {
          isDragging = false;
          isPanning = false;
          swipeState.isSwiping = false;
          swipeState.lock = null;
          return;
        }

        // 2. GESTION SWIPE DU PANNEAU (Corrig√©e)
        if (swipeState.isSwiping) {
          if (swipeState.lock === "horizontal") {
            const panel = document.getElementById("panel");
            const openBtn = document.getElementById("openBtn");

            // R√©activer la transition
            panel.classList.remove("no-transition");

            // CORRECTION MAJEURE : Lire la position AVANT de nettoyer le style
            // On r√©cup√®re la valeur X actuelle directement depuis le style transform
            const currentTransform = panel.style.transform;
            let currentX = swipeState.panelStartTranslateX; // Valeur par d√©faut

            if (currentTransform && currentTransform.includes("translateX")) {
              const match = currentTransform.match(/translateX\(([-\d.]+)px\)/);
              if (match) currentX = parseFloat(match[1]);
            }

            // On nettoie le style inline pour laisser les classes CSS g√©rer la suite
            panel.style.transform = "";

            // Seuil de bascule (moiti√© de la largeur)
            const totalWidth = panel.offsetWidth + 20;
            const threshold = -totalWidth / 2;

            if (currentX > threshold) {
              // OUVRIR
              panelOpen = true;
              panel.classList.remove("hidden");
              openBtn.classList.remove("show"); // Cache le bouton burger
            } else {
              // FERMER
              panelOpen = false;
              panel.classList.add("hidden");
              openBtn.classList.add("show"); // Affiche le bouton burger
            }
          }

          // Reset complet
          swipeState.isSwiping = false;
          swipeState.lock = null;
          return; // On arr√™te l√† pour ne pas d√©clencher de clic 3D
        }

        // 3. Clic 3D normal
        if (!wasDragged) {
          e.preventDefault();
          performRaycastSelection(touchStartPosition.x, touchStartPosition.y);
        }

        isDragging = false;
        isPanning = false;
      }

      const raycastCandidates = [];

      function getIntersectionResult(x, y) {
        // 1. Transformation des coordonn√©es (inchang√©)
        mouse.x = (x / window.innerWidth) * 2 - 1;
        mouse.y = -(y / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        // 2. Optimisation : Remplissage du tableau sans cr√©er de sous-tableaux interm√©diaires
        raycastCandidates.length = 0; // Vider le tableau sans le d√©truire

        // A. Points
        const points = geometryManager.points;
        for (let i = 0; i < points.length; i++) {
          if (points[i].mesh.visible) raycastCandidates.push(points[i].mesh);
        }

        // B. Droites
        const lines = geometryManager.lines;
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].isVisible) raycastCandidates.push(lines[i].mesh);
        }

        // C. Plans
        const planes = geometryManager.planes;
        for (let i = 0; i < planes.length; i++) {
          if (planes[i].isVisible) raycastCandidates.push(planes[i].mesh);
        }

        // D. Vecteurs (Ligne et C√¥ne)
        const vectors = geometryManager.vectors;
        for (let i = 0; i < vectors.length; i++) {
          const v = vectors[i];
          if (v.isVisible && v.arrowHelper) {
            raycastCandidates.push(v.arrowHelper.line);
            raycastCandidates.push(v.arrowHelper.cone);
          }
        }

        // 3. Lancement du rayon sur la liste consolid√©e
        const intersects = raycaster.intersectObjects(raycastCandidates);

        return intersects.length > 0 ? intersects[0] : null;
      }

      function findObjectAndShowMenu(x, y) {
        // On v√©rifie que la fonction existe bien avant de l'appeler
        if (typeof hideContextMenu === "function") {
          hideContextMenu();
        } else {
          console.error("‚ùå Erreur : hideContextMenu n'est pas d√©finie !");
          return;
        }

        const intersection = getIntersectionResult(x, y);

        if (intersection) {
          console.log("‚úÖ 2. Objet touch√© !", intersection.object);

          if (intersection.object.userData && intersection.object.userData.instance) {
            console.log("‚úÖ 3. Instance trouv√©e, lancement du menu...");
            populateAndShowContextMenu(x, y, intersection.object.userData.instance);
          } else {
            console.warn("‚ö†Ô∏è Objet touch√© mais pas de donn√©es 'instance' (userData vide ?)");
          }
        } else {
          console.log("‚ùå 2. Aucun objet trouv√© sous la souris.");
        }
      }

      function populateAndShowContextMenu(x, y, instance) {
        console.log("üõ†Ô∏è Construction du menu pour :", instance.constructor.name);

        const menu = document.getElementById("contextMenu");
        const menuItemsContainer = document.getElementById("contextMenuItems");

        // 1. Vider le menu pr√©c√©dent
        menuItemsContainer.innerHTML = "";

        // Helper pour cr√©er les lignes (li)
        const createAction = (action, text) => `<li onclick="${action}; hideContextMenu();">${text}</li>`;

        let htmlContent = "";

        // 2. G√©n√©rer le contenu selon le type
        if (instance instanceof Point) {
          const index = geometryManager.points.indexOf(instance);
          htmlContent += createAction(`editPoint(${index})`, "‚úèÔ∏è Modifier le point");
          // --- AJOUT ---
          htmlContent += createAction(`openTransformationPanel('point', ${index})`, "üîÑ Transformations");
          // -------------
          htmlContent += createAction(`removePoint(${index})`, "üóëÔ∏è Supprimer le point");
        } else if (instance instanceof Vector) {
          htmlContent += createAction(`editVector(${instance.id})`, "‚úèÔ∏è Modifier le vecteur");
          // --- AJOUT ---
          htmlContent += createAction(`openTransformationPanel('vector', ${instance.id})`, "üîÑ Transformations");
          // -------------
          htmlContent += createAction(
            `toggleVectorVisibility(${instance.id})`,
            instance.isVisible ? "üôà Cacher" : "üëÅÔ∏è Afficher"
          );
          htmlContent += createAction(`removeVectorById(${instance.id})`, "üóëÔ∏è Supprimer");
        } else if (instance instanceof Line3D) {
          htmlContent += createAction(`editLine(${instance.id})`, "‚úèÔ∏è Modifier la droite");
          // --- AJOUT ---
          htmlContent += createAction(`openTransformationPanel('line', ${instance.id})`, "üîÑ Transformations");
          // -------------
          htmlContent += createAction(
            `toggleStraightLineVisibility(${instance.id})`,
            instance.isVisible ? "üôà Cacher" : "üëÅÔ∏è Afficher"
          );
          htmlContent += createAction(`removeStraightLineById(${instance.id})`, "üóëÔ∏è Supprimer");
        } else if (instance instanceof Plane) {
          htmlContent += createAction(`editPlane(${instance.id})`, "‚úèÔ∏è Modifier le plan");
          // --- AJOUT ---
          htmlContent += createAction(`openTransformationPanel('plane', ${instance.id})`, "üîÑ Transformations");
          // -------------
          htmlContent += createAction(
            `togglePlaneVisibility(${instance.id})`,
            instance.isVisible ? "üôà Cacher" : "üëÅÔ∏è Afficher"
          );
          htmlContent += createAction(`toggleNormalVector(${instance.id})`, "üìè Vecteur Normal (Vn)");
          htmlContent += createAction(`removePlaneById(${instance.id})`, "üóëÔ∏è Supprimer");
        }

        // 3. V√©rifier si du contenu a √©t√© g√©n√©r√©
        if (htmlContent === "") {
          console.warn("‚ö†Ô∏è Menu vide : type d'objet non reconnu", instance);
          return;
        }

        menuItemsContainer.innerHTML = htmlContent;

        // 4. Affichage et Positionnement
        menu.style.display = "block";

        const menuWidth = menu.offsetWidth || 160;
        const menuHeight = menu.offsetHeight || 100;

        let finalX = x;
        let finalY = y;

        if (x + menuWidth > window.innerWidth) {
          finalX = window.innerWidth - menuWidth - 10;
        }
        if (y + menuHeight > window.innerHeight) {
          finalY = window.innerHeight - menuHeight - 10;
        }

        menu.style.left = finalX + "px";
        menu.style.top = finalY + "px";
      }

      // =====================================================================================
      // END: GESTION DES √âV√âNEMENTS
      // =====================================================================================
      function createAxes() {
        // 1. Nettoyage si les axes existent d√©j√†
        if (axesGroup) {
          scene.remove(axesGroup);
          // Nettoyage m√©moire basique
          axesGroup.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
              if (child.material.map) child.material.map.dispose();
              child.material.dispose();
            }
          });
          axesGroup = null;
        }

        axesGroup = new THREE.Group(); // Cr√©er un conteneur global

        const axisLength = 10;
        const axisRadius = 0.04;
        const headLength = 0.4;
        const headRadius = 0.12;

        // --- Helper pour cr√©er le texte (Label) ---
        const createAxisLabel = (text, colorHex) => {
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          canvas.width = 256;
          canvas.height = 256;

          context.clearRect(0, 0, canvas.width, canvas.height);
          context.font = "bold 60px Arial"; // Un peu plus gras
          context.textAlign = "center";
          context.textBaseline = "middle";

          // LOGIQUE DE COULEUR DES AXES
          // En dark mode, on veut que le texte soit blanc ou de la couleur de l'axe mais plus clair
          // Ici on garde la couleur de l'axe, mais on ajoute un contour (stroke) pour la lisibilit√©

          context.lineWidth = 8;
          context.strokeStyle = isDarkMode ? "black" : "white"; // Contour selon le th√®me
          context.strokeText(text, canvas.width / 2, canvas.height / 2);

          context.fillStyle = "#" + new THREE.Color(colorHex).getHexString();
          context.fillText(text, canvas.width / 2, canvas.height / 2);

          const texture = new THREE.CanvasTexture(canvas);
          const material = new THREE.SpriteMaterial({
            map: texture,
            depthTest: false,
            transparent: true,
          });

          const sprite = new THREE.Sprite(material);
          sprite.scale.set(2.5, 2.5, 1);
          return sprite;
        };

        const createAxisArrow = (color, direction, labelText) => {
          // ... (garder le code existant de cr√©ation de fl√®che) ...
          // SAUF : au lieu de 'group.add(shaft)', faire 'localGroup.add(shaft)'
          // et retourner localGroup

          // POUR SIMPLIFIER : Copiez-collez votre logique existante mais ajoutez tout √† axesGroup

          const material = new THREE.MeshBasicMaterial({ color: color, depthTest: false });
          // ... g√©om√©trie cylindre + cone ...

          // Je r√©√©cris la version courte compatible avec votre code existant :
          const localGroup = new THREE.Group();

          const shaftGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 12);
          const shaft = new THREE.Mesh(shaftGeometry, material);
          shaft.position.copy(direction).multiplyScalar(axisLength / 2);
          shaft.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
          localGroup.add(shaft);

          const headGeometry = new THREE.ConeGeometry(headRadius, headLength, 12);
          const head = new THREE.Mesh(headGeometry, material);
          head.position.copy(direction).multiplyScalar(axisLength);
          head.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
          localGroup.add(head);

          const label = createAxisLabel(labelText, color);
          const labelPos = direction.clone().multiplyScalar(axisLength + 1.5);
          label.position.copy(labelPos);
          localGroup.add(label);

          return localGroup;
        };

        // Cr√©ation
        const xAxis = createAxisArrow(0xff0000, new THREE.Vector3(1, 0, 0), "X");
        const yAxis = createAxisArrow(0x00ff00, new THREE.Vector3(0, 1, 0), "Z");
        const zAxis = createAxisArrow(0x0000ff, new THREE.Vector3(0, 0, 1), "Y");

        axesGroup.add(xAxis);
        axesGroup.add(yAxis);
        axesGroup.add(zAxis);

        // Configuration rendu
        axesGroup.traverse((child) => {
          if (child.material) {
            child.material.depthTest = true;
            child.material.transparent = true;
            child.material.opacity = 1.0;
            child.renderOrder = 1;
          }
        });

        scene.add(axesGroup);
      }

      let lastCameraHash = ""; // Pour suivre les changements de cam√©ra

      function animate() {
        requestAnimationFrame(animate);

        // G√©n√©rer une signature simple de la position/rotation cam√©ra
        const currentCameraHash = `${camera.position.x.toFixed(3)},${camera.position.y.toFixed(
          3
        )},${camera.position.z.toFixed(3)},${camera.rotation.x.toFixed(3)},${camera.rotation.y.toFixed(3)}`;

        // Optimisation : On ne met √† jour les labels que si la cam√©ra a boug√©
        // OU si un gizmo est en cours d'utilisation (car les objets bougent)
        if (currentCameraHash !== lastCameraHash || isGizmoDragging) {
          const scaleFactor = 0.12;

          // Mise √† jour labels Points
          for (let i = 0, l = geometryManager.points.length; i < l; i++) {
            const p = geometryManager.points[i];
            if (p.label) {
              const dist = camera.position.distanceTo(p.label.position);
              const desiredScale = dist * scaleFactor;
              p.label.scale.set(desiredScale, desiredScale * 0.5, 1);
            }
          }

          // Mise √† jour labels Vecteurs
          for (let i = 0, l = geometryManager.vectors.length; i < l; i++) {
            const v = geometryManager.vectors[i];
            if (v.label && v.label.visible) {
              // V√©rif visibilit√© pour √©conomiser calculs
              const dist = camera.position.distanceTo(v.label.position);
              const desiredScale = dist * scaleFactor;
              v.label.scale.set(desiredScale, desiredScale * 0.5, 1);
            }
          }

          lastCameraHash = currentCameraHash;
        }

        renderer.render(scene, camera);
      }
      // =====================================================================================
      // SECTION 4 : MISE √Ä JOUR DE L'INTERFACE UTILISATEUR (UI)
      // =====================================================================================

      function updateAllUI() {
        updatePointList();
        updateStraightLineList();
        updatePlaneList();
        updateVectorList();
        updateSelects();
        updateSpreadsheet();
      }

      function updatePointList() {
        const list = document.getElementById("pointList");
        list.innerHTML = "";
        geometryManager.points.forEach((p, i) => {
          const item = document.createElement("div");
          item.className = "point-item";
          const coordsText = `(${formatNumber(p.position.x, 1)}, ${formatNumber(p.position.z, 1)}, ${formatNumber(
            p.position.y,
            1
          )})`;

          item.innerHTML = `
      <div class="geometry-item-main">
          <div class="geometry-info">
              <span class="point-name">${p.name}</span>
              <span class="geometry-coords">${coordsText}</span>
          </div>
          <div class="geometry-actions">
              <button class="btn-secondary" onclick="editPoint(${i})" title="Modifier">‚úèÔ∏è</button>
              <button class="btn-danger" onclick="removePoint(${i})" title="Supprimer">üóëÔ∏è</button>
          </div>
      </div>`;
          list.appendChild(item);
        });
      }

      function updateStraightLineList() {
        const list = document.getElementById("lineList");
        list.innerHTML =
          geometryManager.lines.length === 0 ? '<div class="point-item">Aucune droite trac√©e.</div>' : "";

        geometryManager.lines.forEach((line) => {
          const item = document.createElement("div");
          item.className = "geometry-item";
          item.id = `line-item-${line.id}`;

          // 1. Pr√©paration des textes (Formatage)
          const v = line.directorVector;
          const vText = `u(${formatNumber(v.x, 1)}, ${formatNumber(v.z, 1)}, ${formatNumber(v.y, 1)})`; // UI Y=Z, Z=Y

          const p = line.startPoint;
          const pText = `(${formatNumber(p.x, 1)}, ${formatNumber(p.z, 1)}, ${formatNumber(p.y, 1)})`;

          // 2. Construction du HTML
          item.innerHTML = `
    <div class="geometry-item-main">
        <!-- AJOUT : onclick="editLine(...)" sur la zone de texte pour acc√®s rapide -->
        <div class="geometry-info" onclick="editLine(${
          line.id
        })" style="cursor: pointer;" title="Cliquer pour modifier">
            <span class="geometry-name">${line.name}</span>
            <span class="geometry-details" id="line-vector-${line.id}">Vect: ${vText}</span>
        </div>

        <div class="geometry-actions">
            <!-- AJOUT : Bouton Crayon pour √©diter -->
            <button class="btn-secondary" onclick="editLine(${line.id})" title="Modifier">‚úèÔ∏è</button>

            <!-- Boutons existants -->

            <button class="btn-secondary" onclick="toggleStraightLineVisibility(${line.id})" title="${
            line.isVisible ? "Masquer" : "Afficher"
          }">${line.isVisible ? "üëÅÔ∏è" : "üôà"}</button>
            <button class="btn-danger" onclick="removeStraightLineById(${line.id})" title="Supprimer">üóëÔ∏è</button>
        </div>
    </div>

    <div class="geometry-details-secondary">
        <span id="line-point-${line.id}" style="color: #666;">
            Passe par : <strong>${pText}</strong>
        </span>
    </div>`;

          list.appendChild(item);
        });
      }

      function updatePlaneList() {
        const list = document.getElementById("planeList");
        list.innerHTML = geometryManager.planes.length === 0 ? '<div class="point-item">Aucun plan cr√©√©.</div>' : "";

        geometryManager.planes.forEach((plane) => {
          const item = document.createElement("div");
          item.className = "geometry-item";
          item.id = `plane-item-${plane.id}`;

          // 1. Formatage donn√©es
          const n = plane.displayNormal;
          const normalText = `Vn : n(${formatNumber(n.x, 1)}, ${formatNumber(n.z, 1)}, ${formatNumber(n.y, 1)})`; // UI Y=Z, Z=Y

          const p = plane.pointOnPlane;
          const pointText = `(${formatNumber(p.x, 1)}, ${formatNumber(p.z, 1)}, ${formatNumber(p.y, 1)})`;

          // 2. Gestion bouton Vn
          const existingNormalVector = geometryManager.vectors.find(
            (v) => v.parentPlaneId === plane.id && v.isNormalVector
          );
          const normalBtnHtml = existingNormalVector
            ? `<button class="btn-violet-light" onclick="toggleNormalVector(${plane.id})" title="Masquer Vn">Vn ‚ûñ</button>`
            : `<button class="btn-violet" onclick="toggleNormalVector(${plane.id})" title="Afficher Vn">Vn ‚ûï</button>`;

          // 3. Calcul de l'√©quation cart√©sienne : Ax + By + Cz + D = 0
          // Mapping UI -> ThreeJS : A=n.x, B=n.z, C=n.y
          const A = n.x;
          const B = n.z;
          const C = n.y;
          const D = -(A * p.x + B * p.z + C * p.y);

          const formatTerm = (coef, varName, isFirst) => {
            if (Math.abs(coef) < 1e-5) return "";
            let res = "";
            if (!isFirst) res += coef > 0 ? " + " : " - ";
            else if (coef < 0) res += "-";

            const absCoef = Math.abs(coef);
            // Si le coeff est ~1 et qu'il y a une variable, on affiche juste la variable (ex: "x" pas "1x")
            if (Math.abs(absCoef - 1) < 1e-5 && varName) res += varName;
            else res += formatNumber(absCoef, 1) + varName;
            return res;
          };

          let eq = formatTerm(A, "x", true);
          eq += formatTerm(B, "y", eq === "");
          eq += formatTerm(C, "z", eq === "");

          // Constante D
          if (Math.abs(D) > 1e-5) {
            eq += formatTerm(D, "", eq === "");
          }

          if (eq === "") eq = "0";
          eq += " = 0";

          // 4. HTML (Avec onclick sur le texte et bouton Crayon)
          item.innerHTML = `
  <div class="geometry-item-main">
      <div class="geometry-info" onclick="editPlane(${
        plane.id
      })" style="cursor: pointer;" title="Cliquer pour modifier">
          <span class="geometry-name">${plane.name}</span>
          <span class="geometry-details" id="plane-normal-${plane.id}">${normalText}</span>
      </div>
      <div class="geometry-actions">
          <!-- AJOUT : Bouton Crayon -->
          <button class="btn-secondary" onclick="editPlane(${plane.id})" title="Modifier">‚úèÔ∏è</button>

          ${normalBtnHtml}

          <button class="btn-secondary" onclick="togglePlaneVisibility(${plane.id})" title="${
            plane.isVisible ? "Masquer" : "Afficher"
          }">${plane.isVisible ? "üëÅÔ∏è" : "üôà"}</button>
          <button class="btn-danger" onclick="removePlaneById(${plane.id})" title="Supprimer">üóëÔ∏è</button>
      </div>
  </div>
  <div class="geometry-details-secondary">
      <span id="plane-point-${plane.id}" style="color: #666; display:block;">
          Passe par : <strong>${pointText}</strong>
      </span>
      <span style="color: #666; display:block; margin-top:2px;">
          Eq : <strong>${eq}</strong>
      </span>
  </div>`;

          list.appendChild(item);
        });
      }

      function updateVectorList() {
        const list = document.getElementById("vectorList");
        list.innerHTML =
          geometryManager.vectors.length === 0 ? '<div class="point-item">Aucun vecteur trac√©.</div>' : "";

        geometryManager.vectors.forEach((vector) => {
          const item = document.createElement("div");
          item.className = "geometry-item";

          // R√©cup√©ration des valeurs
          const v = vector.components;
          const o = vector.origin;

          // Formatage Composantes (Vx, Vy, Vz)
          const coordsText = `(${formatNumber(v.x, 1)}, ${formatNumber(v.z, 1)}, ${formatNumber(v.y, 1)})`;

          // Formatage Origine (Ox, Oy, Oz) - Attention inversion Y/Z pour l'UI
          const originText = `(${formatNumber(o.x, 1)}, ${formatNumber(o.z, 1)}, ${formatNumber(o.y, 1)})`;

          const normText = formatNumber(vector.components.length(), 2);

          item.innerHTML = `
    <div class="geometry-item-main">
        <div class="geometry-info">
            <span class="geometry-name">${vector.name}</span>
            <!-- On donne des ID uniques aux spans pour pouvoir les mettre √† jour en temps r√©el -->
            <span class="geometry-coords" id="vector-comps-list-${vector.id}">Coord: ${coordsText}</span>
        </div>
        <div class="geometry-actions">
            <button class="btn-secondary" onclick="editVector(${vector.id})" title="Modifier">‚úèÔ∏è</button>
            <button class="btn-violet-light" onclick="toggleVectorLabelVisibility(${vector.id})" title="${
            vector.isLabelVisible ? "Masquer le nom" : "Afficher le nom"
          }">${vector.isLabelVisible ? "üëÅÔ∏è" : "üôà"}</button>
            <button class="btn-secondary" onclick="toggleVectorVisibility(${vector.id})" title="${
            vector.isVisible ? "Masquer" : "Afficher"
          }">${vector.isVisible ? "üëÅÔ∏è" : "üôà"}</button>
            <button class="btn-danger" onclick="removeVectorById(${vector.id})" title="Supprimer">üóëÔ∏è</button>
        </div>
    </div>
    <div class="geometry-details-secondary">
        <!-- C'est ici qu'on ajoute le champ Origine avec un ID unique -->
        <span id="vector-origin-list-${vector.id}" style="display:block; margin-bottom:2px; color:#555;">
            Origine: <strong>${originText}</strong>
        </span>
        Norme: <strong>${normText}</strong>
    </div>`;

          list.appendChild(item);
        });
      }

      function toggleVectorLabelVisibility(id) {
        const vector = geometryManager.findVectorById(id);
        if (vector) {
          // Appelle la nouvelle m√©thode de la classe Vector
          vector.setLabelVisibility(!vector.isLabelVisible);
          // Met √† jour la liste pour que le texte du bouton change
          updateVectorList();
        }
      }

      function toggleNormalVector(planeId) {
        const plane = geometryManager.findPlaneById(planeId);
        if (!plane) return;

        // Chercher si un vecteur normal existe d√©j√† pour ce plan
        const existingVector = geometryManager.vectors.find((v) => v.parentPlaneId === planeId && v.isNormalVector);

        if (existingVector) {
          // Le vecteur existe, on le supprime
          geometryManager.removeVector(existingVector);
        } else {
          // Le vecteur n'existe pas, on le cr√©e
          const normalVectorName = `Vn(${plane.name})`;
          const normalVectorLength = 2.5;
          const normalVectorComponents = plane.normal.clone().normalize().multiplyScalar(normalVectorLength);

          const normalVector = new Vector(
            normalVectorName,
            plane.mesh.position, // Origine du vecteur
            normalVectorComponents,
            0x800080 // Couleur violette
          );

          // On stocke des informations pour le retrouver
          normalVector.isNormalVector = true;
          normalVector.parentPlaneId = plane.id;
          geometryManager.addVector(normalVector);
        }

        // Mettre √† jour l'UI pour refl√©ter le changement de bouton et la liste des vecteurs
        updateAllUI();
        saveState();
      }

      function updateSelects() {
        const allSelects = document.querySelectorAll("select");

        // Ces menus doivent proposer l'option "Origine (0,0,0)" en plus des points
        const menusWithOrigin = [
          "vectorOriginPoint",
          "sumVectorOrigin",
          "crossVectorOrigin",
          "rotationCenterSelect",
          "planeEquationPointSelect",
          "lineEquationPointSelect",
        ];

        // CORRECTION : Liste des menus qui contiennent le mot "Vector" dans leur ID
        // mais qui doivent afficher des POINTS (et non des vecteurs)
        const pointInputIds = [
          "sumVectorOrigin", // Point de d√©part (Somme)
          "crossVectorOrigin", // Origine (Produit vectoriel)
          "vectorOriginPoint", // Origine (Tracer vecteur)
          "vectorStartPoint", // Point de d√©part (Tracer vecteur par 2 points)
          "vectorEndPoint", // Point d'arriv√©e (Tracer vecteur par 2 points)
        ];

        allSelects.forEach((select) => {
          const id = select.id;
          const currentValue = select.value;

          // On ignore les menus sp√©ciaux g√©r√©s ailleurs
          if (
            [
              "rotationAxisSelect",
              "symmetryTypeSelect",
              "savedScenesSelect",
              "symmetryRefSelect",
              "snapSizeSelect",
            ].includes(id)
          ) {
            return;
          }

          // On vide le menu pour le reconstruire
          select.innerHTML = "";

          // --- CAS SP√âCIAUX (Plans / Droites par √©quation) ---
          if (id === "planeEquationPointSelect" || id === "lineEquationPointSelect") {
            select.add(
              new Option(
                id === "planeEquationPointSelect"
                  ? "-- Par d√©faut (selon constante d) --"
                  : "-- Point de passage (d√©faut: √©quation) --",
                ""
              )
            );
            select.add(new Option("Origine (0,0,0)", "origin"));
            geometryManager.points.forEach((p, i) => select.add(new Option(p.name, i)));
            select.value = currentValue;
            return;
          }

          // --- LOGIQUE G√âN√âRALE CORRIG√âE ---

          // 1. Est-ce un menu qui doit afficher des POINTS ?
          // (Soit il est dans la liste d'exceptions, soit il ne contient ni Vector/Line/Plane dans son nom)
          const isPointMenu =
            pointInputIds.includes(id) || (!id.includes("Vector") && !id.includes("Line") && !id.includes("Plane"));

          if (isPointMenu) {
            select.add(new Option("-- Point --", ""));
            geometryManager.points.forEach((p, i) => select.add(new Option(p.name, i)));
          }
          // 2. Les Vecteurs (excluant les exceptions ci-dessus)
          else if (id.includes("Vector")) {
            select.add(new Option("-- Vecteur --", ""));
            geometryManager.vectors.forEach((v) => select.add(new Option(v.name, v.id)));
          }
          // 3. Les Droites
          else if (id.includes("Line")) {
            select.add(new Option("-- Droite --", ""));
            geometryManager.lines.forEach((l) => select.add(new Option(l.name, l.id)));
          }
          // 4. Les Plans
          else if (id.includes("Plane")) {
            select.add(new Option("-- Plan --", ""));
            geometryManager.planes.forEach((p) => select.add(new Option(p.name, p.id)));
          }

          // --- OPTIONS SUPPL√âMENTAIRES (Origine) ---
          if (menusWithOrigin.includes(id)) {
            const originOpt = new Option("Origine (0,0,0)", "origin");
            // On ins√®re apr√®s le titre ("-- Point --")
            if (select.options.length > 0) {
              select.add(originOpt, select.options[1]);
            } else {
              select.add(originOpt);
            }
          }

          // Restauration de la valeur s√©lectionn√©e
          select.value = currentValue;
        });

        // Mise √† jour des affichages d'√©quations et sym√©trie
        displayPlaneEquation();
        displayLineEquation();
        if (document.getElementById("symmetryTypeSelect")) {
          updateSymmetryUI();
        }
      }
      // =====================================================================================
      // SECTION 5 : CR√âATION / MODIFICATION / SUPPRESSION D'OBJETS
      // =====================================================================================
      function editPoint(index, forceOpen = true) {
        // 1. UI
        if (forceOpen) {
          ensurePanelVisible();
          const input = document.getElementById("pointName");
          if (input) {
            const section = input.closest(".section.collapsible");
            if (section && section.classList.contains("collapsed")) section.classList.remove("collapsed");
          }
        }

        const p = geometryManager.points[index];
        if (!p) return;

        // 2. Remplissage
        document.getElementById("pointName").value = p.name;
        document.getElementById("pointX").value = formatNumber(p.position.x);
        document.getElementById("pointY").value = formatNumber(p.position.z); // Z 3D -> Y UI
        document.getElementById("pointZ").value = formatNumber(p.position.y); // Y 3D -> Z UI
        document.getElementById("editPointIndex").value = index;

        // 3. Boutons
        const btnAdd = document.getElementById("addPointBtn");
        if (btnAdd) btnAdd.style.display = "none";
        const actions = document.getElementById("pointEditActions");
        if (actions) actions.style.display = "grid";

        // 4. ACTIVATION GIZMO S√âCURIS√âE
        // Si l'objet n'est pas encore s√©lectionn√© (ex: clic bouton crayon), on le s√©lectionne.
        if (selectedObjectInstance !== p && p.mesh) {
          handleSelection(p.mesh);
        }
      }

      function editVector(id, forceOpen = true) {
        // 1. UI
        if (forceOpen) {
          ensurePanelVisible();
          const input = document.getElementById("vectorNameCoords");
          if (input) {
            const section = input.closest(".section.collapsible");
            if (section && section.classList.contains("collapsed")) section.classList.remove("collapsed");
          }
        }

        const v = geometryManager.findVectorById(id);
        if (!v) return;

        // 2. Remplissage
        document.getElementById("vectorNameCoords").value = v.name;
        document.getElementById("vectorCoordX").value = formatNumber(v.components.x);
        document.getElementById("vectorCoordY").value = formatNumber(v.components.z);
        document.getElementById("vectorCoordZ").value = formatNumber(v.components.y);

        const ox = v.origin.x,
          oy = v.origin.z,
          oz = v.origin.y;
        document.getElementById("vectorOriginX").value = formatNumber(ox);
        document.getElementById("vectorOriginY").value = formatNumber(oy);
        document.getElementById("vectorOriginZ").value = formatNumber(oz);
        document.getElementById("editVectorId").value = id;

        // 3. Boutons
        const btnAdd = document.getElementById("addVectorFromCoordsBtn");
        if (btnAdd) btnAdd.style.display = "none";
        const actions = document.getElementById("vectorEditActions");
        if (actions) actions.style.display = "grid";

        // 4. ACTIVATION GIZMO S√âCURIS√âE
        if (selectedObjectInstance !== v && v.arrowHelper) {
          // Pour un vecteur, on passe le helper √† handleSelection
          // (Attention: handleSelection attend un objet avec userData.instance, ce que arrowHelper.line poss√®de)
          handleSelection(v.arrowHelper.line);
        }
      }

      function editLine(id, forceOpen = true) {
        // 1. UI
        if (forceOpen) {
          ensurePanelVisible();
          const input = document.getElementById("lineEquationInput");
          if (input) {
            const section = input.closest(".section.collapsible");
            if (section && section.classList.contains("collapsed")) section.classList.remove("collapsed");
            input.scrollIntoView({ behavior: "smooth", block: "center" });
          }
        }

        const line = geometryManager.findLineById(id);
        if (!line) return;

        // 2. Remplissage
        const idField = document.getElementById("editLineId");
        if (idField) idField.value = id;

        const nameField = document.getElementById("lineNameFromEquation");
        if (nameField) nameField.value = line.name;

        document.getElementById("lineEqPointX").value = formatNumber(line.startPoint.x);
        document.getElementById("lineEqPointY").value = formatNumber(line.startPoint.z);
        document.getElementById("lineEqPointZ").value = formatNumber(line.startPoint.y);
        document.getElementById("lineEquationPointSelect").value = "";

        // G√©n√©ration √©quation
        const p = line.startPoint;
        const v = line.directorVector;
        const fmt = (start, dir) => {
          let s = "";
          if (Math.abs(start) > 1e-4) s += formatNumber(start);
          if (Math.abs(dir) > 1e-4) {
            const sign = dir > 0 ? (s ? " + " : "") : " - ";
            const val = Math.abs(Math.abs(dir) - 1) < 1e-4 ? "t" : formatNumber(Math.abs(dir)) + "t";
            s += sign + val;
          }
          return s || "0";
        };
        const txtX = `x = ${fmt(p.x, v.x)}`;
        const txtY = `y = ${fmt(p.z, v.z)}`;
        const txtZ = `z = ${fmt(p.y, v.y)}`;
        document.getElementById("lineEquationInput").value = `${txtX}\n${txtY}\n${txtZ}`;

        // 3. Boutons
        const btnAdd = document.getElementById("addLineFromEquationBtn");
        if (btnAdd) btnAdd.style.display = "none";
        const actions = document.getElementById("lineEquationActions");
        if (actions) actions.style.display = "grid";

        // 4. ACTIVATION GIZMO S√âCURIS√âE
        if (selectedObjectInstance !== line && line.mesh) {
          handleSelection(line.mesh);
        }
      }
      function editPlane(id, forceOpen = true) {
        // 1. UI
        if (forceOpen) {
          ensurePanelVisible();
          const input = document.getElementById("planeEquationInput");
          if (input) {
            const section = input.closest(".section.collapsible");
            if (section && section.classList.contains("collapsed")) section.classList.remove("collapsed");
            input.scrollIntoView({ behavior: "smooth", block: "center" });
          }
        }

        const plane = geometryManager.findPlaneById(id);
        if (!plane) return;

        // 2. Remplissage
        const idField = document.getElementById("editPlaneId");
        if (idField) idField.value = id;

        document.getElementById("planeEqPointX").value = formatNumber(plane.pointOnPlane.x);
        document.getElementById("planeEqPointY").value = formatNumber(plane.pointOnPlane.z);
        document.getElementById("planeEqPointZ").value = formatNumber(plane.pointOnPlane.y);
        document.getElementById("planeEquationPointSelect").value = "";

        // G√©n√©ration √©quation
        const n = plane.displayNormal;
        const p = plane.pointOnPlane;
        const a = n.x,
          b = n.z,
          c = n.y;
        const d = -(a * p.x + b * p.z + c * p.y);

        const fmtCoef = (val, axisName) => {
          if (Math.abs(val) < 1e-4) return "";
          const sign = val > 0 ? "+" : "-";
          const absVal = Math.abs(val);
          const valStr = Math.abs(absVal - 1) < 1e-4 ? "" : formatNumber(absVal);
          return `${sign} ${valStr}${axisName} `;
        };

        let eqStr = "";
        if (Math.abs(a) > 1e-4) eqStr += `${formatNumber(a)}x `;
        eqStr += fmtCoef(b, "y");
        eqStr += fmtCoef(c, "z");
        if (Math.abs(d) > 1e-4) eqStr += d > 0 ? `+ ${formatNumber(d)}` : `- ${formatNumber(Math.abs(d))}`;
        eqStr = eqStr.trim().replace(/^\+\s/, "") + " = 0";

        document.getElementById("planeEquationInput").value = eqStr;

        // 3. Boutons
        const btnAdd = document.getElementById("addPlaneFromEquationBtn");
        if (btnAdd) btnAdd.style.display = "none";
        const actions = document.getElementById("planeEquationActions");
        if (actions) actions.style.display = "grid";

        // 4. ACTIVATION GIZMO S√âCURIS√âE
        if (selectedObjectInstance !== plane && plane.mesh) {
          handleSelection(plane.mesh);
        }
      }

      function openTransformationPanel(type, id) {
        ensurePanelVisible(); // Ouvre le panneau lat√©ral s'il est ferm√©

        // 1. Retrouver l'instance de l'objet
        let instance = null;
        if (type === "point") {
          instance = geometryManager.points[id];
        } else if (type === "line") {
          instance = geometryManager.findLineById(id);
        } else if (type === "plane") {
          instance = geometryManager.findPlaneById(id);
        } else if (type === "vector") {
          instance = geometryManager.findVectorById(id);
        }

        if (instance) {
          // 2. Forcer la s√©lection de cet objet (indispensable pour que les boutons fonctionnent)
          // On d√©s√©lectionne l'ancien d'abord pour nettoyer
          if (selectedObjectInstance && selectedObjectInstance !== instance) {
            deselectCurrentObject();
          }
          selectedObjectInstance = instance;

          // 3. Mettre l'objet en surbrillance (jaune)
          const HIGHLIGHT_COLOR = 0xffff00;
          if (instance instanceof Vector) {
            if (instance.arrowHelper) instance.arrowHelper.setColor(HIGHLIGHT_COLOR);
          } else if (instance.mesh) {
            instance.mesh.material.color.set(HIGHLIGHT_COLOR);
            if (instance instanceof Plane) instance.mesh.material.opacity = 0.75;
          }

          // 4. Afficher l'interface de transformation
          document.getElementById("transformations-hint").style.display = "none";
          document.getElementById("transformations-container").style.display = "block";

          // 5. D√©plier la section "Transformations"
          const transContainer = document.getElementById("transformations-container");
          const section = transContainer.closest(".section");
          if (section && section.classList.contains("collapsed")) {
            section.classList.remove("collapsed");
          }

          // 6. Faire d√©filer jusqu'aux options
          setTimeout(() => {
            transContainer.scrollIntoView({ behavior: "smooth", block: "start" });
          }, 100); // Petit d√©lai pour laisser le temps au d√©pliage
        }
      }

      function addPoint() {
        const n = document.getElementById("pointName").value.trim();
        const x = parseFloat(document.getElementById("pointX").value);
        const y_from_ui = parseFloat(document.getElementById("pointY").value); // Profondeur
        const z_from_ui = parseFloat(document.getElementById("pointZ").value); // Hauteur
        if (!n || isNaN(x) || isNaN(y_from_ui) || isNaN(z_from_ui)) {
          showSplashScreen("Donn√©es invalides.");
          return;
        }
        // Le constructeur Point attend un nom et un Vector3, pas des coordonn√©es s√©par√©es
        geometryManager.addPoint(new Point(n, x, z_from_ui, y_from_ui));

        cancelEdit();

        updateAllUI();
        saveState();
      }

      function updatePoint() {
        const i = document.getElementById("editPointIndex").value;
        const p = geometryManager.points[i];
        if (!p) return;

        const n = document.getElementById("pointName").value.trim();

        // --- D√âBUT DE LA CORRECTION ---
        // On utilise les bons IDs pour lire les coordonn√©es depuis le formulaire
        const x = parseFloat(document.getElementById("pointX").value);
        const y_from_ui = parseFloat(document.getElementById("pointY").value); // Profondeur
        const z_from_ui = parseFloat(document.getElementById("pointZ").value); // Hauteur
        // --- FIN DE LA CORRECTION ---

        if (!n || isNaN(x) || isNaN(y_from_ui) || isNaN(z_from_ui)) {
          showSplashScreen("Donn√©es invalides.");
          return;
        }

        // --- AJOUT DE LA V√âRIFICATION ---
        // On v√©rifie si le nouveau nom est d√©j√† pris par un AUTRE objet
        const existingObject = geometryManager.findObjectByName(n);
        if (existingObject && existingObject.id !== p.id) {
          showSplashScreen(`Le nom "${n}" est d√©j√† utilis√©. Veuillez en choisir un autre.`);
          return;
        }
        // --- FIN DE L'AJOUT ---

        // On garde votre logique de mise √† jour, elle est parfaite
        p.update(n, x, z_from_ui, y_from_ui);

        updateAllUI();
        cancelEdit();
        saveState();
      }

      function cancelEdit() {
        // Vider les champs
        document.getElementById("pointName").value = "";
        document.getElementById("pointX").value = "";
        document.getElementById("pointY").value = "";
        document.getElementById("pointZ").value = "";
        document.getElementById("editPointIndex").value = "";

        // --- PARTIE CORRIG√âE ---
        // Afficher le bouton "Ajouter"
        document.getElementById("addPointBtn").style.display = "block";
        // Cacher le CONTENEUR des boutons d'√©dition
        document.getElementById("pointEditActions").style.display = "none";
      }

      function deleteEditingPoint() {
        // R√©cup√®re l'index du point depuis le champ cach√©
        const index = parseInt(document.getElementById("editPointIndex").value);
        if (isNaN(index)) return; // S√©curit√©

        // Appelle la fonction de suppression existante qui g√®re d√©j√† la confirmation
        removePoint(index);

        // R√©initialise le formulaire pour quitter le mode √©dition
        cancelEdit();
      }

      function removePoint(index) {
        const p = geometryManager.points[index];
        if (p && confirm(`Supprimer "${p.name}" ?`)) {
          if (selectedObjectInstance === p) {
            deselectCurrentObject();
          }
          geometryManager.removePoint(p);
          updateAllUI();
          saveState();
        }
      }

      function clearAllPoints() {
        // 1. Modifier le message de confirmation pour qu'il soit pr√©cis.
        if (
          confirm(
            "√ätes-vous s√ªr de vouloir effacer tous les points ? (Les droites, plans et vecteurs existants seront conserv√©s)"
          )
        ) {
          deselectCurrentObject();
          // 2. Parcourir chaque point pour le retirer de la sc√®ne 3D.
          geometryManager.points.forEach((point) => {
            point.removeFromScene(scene);
          });

          // 3. Vider le tableau des points dans le gestionnaire.
          geometryManager.points = [];

          // 4. Mettre √† jour l'interface utilisateur pour refl√©ter la suppression.
          updateAllUI();
          saveState();
        }
      }

      // --- Droites ---

      // Dans la SECTION 5
      function addStraightLine() {
        const [i1, i2] = [document.getElementById("lineStart").value, document.getElementById("lineEnd").value];
        if (i1 === "" || i2 === "" || i1 === i2) {
          showSplashScreen("S√©lectionnez deux points diff√©rents.");
          return;
        }
        const p1 = geometryManager.points[i1],
          p2 = geometryManager.points[i2];
        const d = new THREE.Vector3().subVectors(p2.position, p1.position);

        const baseName = `Droite(${p1.name},${p2.name})`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "line"); // On passe 'line'
        geometryManager.addLine(new Line3D(uniqueName, p1.position, d));
        updateAllUI();
        saveState();
      }

      function removeStraightLineById(id) {
        const l = geometryManager.findLineById(id);
        if (l && confirm(`Supprimer "${l.name}" ?`)) {
          if (selectedObjectInstance === l) {
            deselectCurrentObject();
          }
          geometryManager.removeLine(l);
          updateAllUI();
          saveState();
        }
      }

      function onLineEquationPointChange() {
        const val = document.getElementById("lineEquationPointSelect").value;

        // On r√©cup√®re les √©l√©ments DOM directement
        const xInput = document.getElementById("lineEqPointX");
        const yInput = document.getElementById("lineEqPointY");
        const zInput = document.getElementById("lineEqPointZ");

        if (val === "origin") {
          xInput.value = 0;
          yInput.value = 0;
          zInput.value = 0;
        } else if (val !== "") {
          const p = geometryManager.points[parseInt(val)];
          if (p) {
            xInput.value = formatNumber(p.position.x);
            // Inversion UI Y/Z pour l'affichage
            yInput.value = formatNumber(p.position.z);
            zInput.value = formatNumber(p.position.y);
          }
        } else {
          // CAS CRUCIAL : Si on revient sur "D√©faut", on VIDE les champs
          // C'est ce qui permet ensuite √† la fonction de cr√©ation de savoir
          // qu'elle doit utiliser les constantes de l'√©quation.
          xInput.value = "";
          yInput.value = "";
          zInput.value = "";
        }
      }

      function addLineFromEquation() {
        const name = document.getElementById("lineNameFromEquation").value.trim() || "Droite (Eq)";
        const equationsText = document.getElementById("lineEquationInput").value;
        const lines = equationsText.split("\n").filter((line) => line.trim() !== "");

        if (lines.length < 3) {
          showSplashScreen("Veuillez entrer les 3 √©quations param√©triques (x, y, et z).");
          return;
        }

        // --- 1. Analyse du texte (Vecteur ET Point du texte) ---
        let textPoint = { x: 0, y: 0, z: 0 };
        let vector = { x: 0, y: 0, z: 0 };
        const axesFound = { x: false, y: false, z: false };

        for (const line of lines) {
          const axisChar = line.trim().charAt(0).toLowerCase();
          if (!["x", "y", "z"].includes(axisChar)) continue;

          const cleanLine = line.substring(line.indexOf("=") + 1);

          // Extraction vecteur (t)
          let tMatch = cleanLine.match(/[+-]?\s*[\d.]*t/);
          let vectorComp = 0;
          let lineWithoutT = cleanLine;

          if (tMatch) {
            let tPart = tMatch[0].replace(/\s/g, "").replace("t", "");
            if (tPart === "+" || tPart === "") vectorComp = 1;
            else if (tPart === "-") vectorComp = -1;
            else vectorComp = parseFloat(tPart);
            lineWithoutT = cleanLine.replace(tMatch[0], "");
          }

          // Extraction point (constante)
          let pointCoord = parseFloat(lineWithoutT.trim() || "0"); // Par d√©faut 0 si pas de constante

          if (isNaN(pointCoord) || isNaN(vectorComp)) {
            showSplashScreen(`Erreur de syntaxe axe '${axisChar}'.`);
            return;
          }

          textPoint[axisChar] = pointCoord;
          vector[axisChar] = vectorComp;
          axesFound[axisChar] = true;
        }

        if (!axesFound.x || !axesFound.y || !axesFound.z) {
          showSplashScreen("Equations incompl√®tes (besoin de x, y, z).");
          return;
        }

        // --- 2. D√âCISION DU POINT DE D√âPART (HI√âRARCHIE STRICTE) ---

        // R√©cup√©ration des valeurs BRUTES (chaines de caract√®res)
        const xStr = document.getElementById("lineEqPointX").value.trim();
        const yStr = document.getElementById("lineEqPointY").value.trim();
        const zStr = document.getElementById("lineEqPointZ").value.trim();
        const selectVal = document.getElementById("lineEquationPointSelect").value;

        let finalStartPoint;

        // PRIORIT√â 1 : Les champs manuels (seulement si au moins un est rempli par l'utilisateur)
        if (xStr !== "" || yStr !== "" || zStr !== "") {
          // Si l'utilisateur a tap√© quelque chose, on prend ses valeurs.
          // Si un champ est vide mais qu'un autre est rempli, on consid√®re le vide comme 0.
          finalStartPoint = new THREE.Vector3(
            parseFloat(xStr) || 0,
            parseFloat(zStr) || 0, // UI Z (Haut) -> 3JS Y
            parseFloat(yStr) || 0 // UI Y (Prof) -> 3JS Z
          );
        }
        // PRIORIT√â 2 : Le menu d√©roulant (si une option est choisie)
        else if (selectVal !== "") {
          if (selectVal === "origin") {
            finalStartPoint = new THREE.Vector3(0, 0, 0);
          } else {
            const p = geometryManager.points[parseInt(selectVal)];
            if (p) finalStartPoint = p.position.clone();
            else finalStartPoint = new THREE.Vector3(0, 0, 0); // S√©curit√©
          }
        }
        // PRIORIT√â 3 : Le texte de l'√©quation (fallback par d√©faut)
        else {
          // C'est ici qu'on utilise les constantes extraites (ex: 1, 0, 4 pour x=1+2t...)
          finalStartPoint = new THREE.Vector3(textPoint.x, textPoint.y, textPoint.z);
        }

        // --- 3. Cr√©ation ---
        const directorVector = new THREE.Vector3(vector.x, vector.y, vector.z);

        if (directorVector.lengthSq() < 1e-8) {
          showSplashScreen("Vecteur directeur nul.");
          return;
        }

        const uniqueName = geometryManager.generateUniqueName(name, "line");
        geometryManager.addLine(new Line3D(uniqueName, finalStartPoint, directorVector));

        updateAllUI();
        saveState();

        // --- CORRECTION : NETTOYAGE COMPLET ---
        // 1. On vide le nom pour la prochaine
        document.getElementById("lineNameFromEquation").value = "";

        // 2. IMPORTANT : On remet le selecteur sur "D√©faut"
        const select = document.getElementById("lineEquationPointSelect");
        if (select) select.value = "";

        // 3. CRUCIAL : On vide les champs manuels pour que la prochaine √©quation soit prioritaire
        document.getElementById("lineEqPointX").value = "";
        document.getElementById("lineEqPointY").value = "";
        document.getElementById("lineEqPointZ").value = "";
      }

      function toggleStraightLineVisibility(lineId) {
        const line = geometryManager.findLineById(lineId);
        if (line) {
          line.setVisibility(!line.isVisible);
          // Met √† jour la liste pour changer le texte du bouton
          updateStraightLineList();
        }
      }

      function clearStraightLines() {
        if (confirm("Effacer toutes les droites ?")) {
          deselectCurrentObject();
          geometryManager.lines.forEach((line) => line.removeFromScene(scene));
          geometryManager.lines = [];
          updateAllUI();
          saveState();
        }
      }

      // --- Plans ---
      function addPlane() {
        const n = document.getElementById("planeName").value.trim() || "Plan";

        // --- V√©rification du nom unique ---
        if (geometryManager.planes.some((p) => p.name === n)) {
          showSplashScreen(`Le nom de plan "${n}" est d√©j√† utilis√©. Veuillez en choisir un autre.`);
          return;
        }
        // --- Fin de la v√©rification ---

        const [i1, i2, i3] = ["planeSelectP1", "planeSelectP2", "planeSelectP3"].map(
          (id) => document.getElementById(id).value
        );
        if (i1 === "" || i2 === "" || i3 === "" || i1 === i2 || i1 === i3 || i2 === i3) {
          showSplashScreen("S√©lectionnez trois points distincts.");
          return;
        }
        const [p1, p2, p3] = [i1, i2, i3].map((i) => geometryManager.points[i].position);
        const norm = new THREE.Vector3().crossVectors(
          new THREE.Vector3().subVectors(p2, p1),
          new THREE.Vector3().subVectors(p3, p1)
        );
        if (norm.lengthSq() < 1e-6) {
          showSplashScreen("Points colin√©aires.");
          return;
        }

        const areIntegers = Number.isInteger(norm.x) && Number.isInteger(norm.y) && Number.isInteger(norm.z);

        if (areIntegers) {
          const commonDivisor = gcdOfThree(norm.x, norm.y, norm.z);
          if (commonDivisor > 1) {
            norm.divideScalar(commonDivisor);
          }
        }

        const newPlane = new Plane(n, p1, norm);
        geometryManager.addPlane(newPlane);
        saveState();
        updateAllUI();
        document.getElementById("planeName").value = "";
      }

      function onPlaneEquationPointChange() {
        const val = document.getElementById("planeEquationPointSelect").value;
        const xInput = document.getElementById("planeEqPointX");
        const yInput = document.getElementById("planeEqPointY");
        const zInput = document.getElementById("planeEqPointZ");

        if (val === "origin") {
          xInput.value = 0;
          yInput.value = 0;
          zInput.value = 0;
        } else if (val !== "") {
          const p = geometryManager.points[parseInt(val)];
          if (p) {
            xInput.value = formatNumber(p.position.x);
            // Attention : Inversion UI Y/Z standard dans votre code
            yInput.value = formatNumber(p.position.z); // Profondeur (UI Y) -> ThreeJS Z
            zInput.value = formatNumber(p.position.y); // Hauteur (UI Z) -> ThreeJS Y
          }
        } else {
          // Si on revient sur "D√©faut", on vide pour laisser la priorit√© √† la constante 'd' de l'√©quation
          xInput.value = "";
          yInput.value = "";
          zInput.value = "";
        }
      }

      function addPlaneFromEquation() {
        let equationStr = document.getElementById("planeEquationInput").value.trim();

        // ========================================
        // 1. VALIDATION DE L'ENTR√âE
        // ========================================
        if (!equationStr) {
          showSplashScreen("‚ö†Ô∏è Veuillez entrer une √©quation (ex: 2x + y + z = 6).");
          return;
        }

        // ========================================
        // 2. NORMALISATION DE L'√âQUATION
        // ========================================
        // Convertir "2x - y + 3z = 6" en "2x - y + 3z - 6"
        if (equationStr.includes("=")) {
          const parts = equationStr.split("=");
          equationStr = `${parts[0]} - (${parts[1]})`;
        }

        // ========================================
        // 3. EXTRACTION DES COEFFICIENTS (a, b, c)
        // ========================================
        const getCoefficient = (variable) => {
          const regex = new RegExp(`([+-]?[\\d\\.]*)\\s*\\*?\\s*${variable}`, "gi");
          let totalCoeff = 0;
          let match;

          while ((match = regex.exec(equationStr)) !== null) {
            let coeffStr = match[1].replace(/\s/g, "");
            if (coeffStr === "" || coeffStr === "+") totalCoeff += 1;
            else if (coeffStr === "-") totalCoeff += -1;
            else totalCoeff += parseFloat(coeffStr);
          }
          return totalCoeff;
        };

        const a = getCoefficient("x");
        const b = getCoefficient("y"); // UI Y (Profondeur) ‚Üí ThreeJS Z
        const c = getCoefficient("z"); // UI Z (Hauteur) ‚Üí ThreeJS Y

        // Construction du vecteur normal Three.js
        // RAPPEL : a ‚Üí x, c ‚Üí y (hauteur), b ‚Üí z (profondeur)
        const normal = new THREE.Vector3(a, c, b);

        if (normal.lengthSq() < 1e-8) {
          showSplashScreen("‚ùå Vecteur normal nul ou invalide. V√©rifiez l'√©quation.");
          return;
        }

        // ========================================
        // 4. D√âTERMINATION DU POINT DE PASSAGE
        // ========================================
        const pxStr = document.getElementById("planeEqPointX").value.trim();
        const pyStr = document.getElementById("planeEqPointY").value.trim();
        const pzStr = document.getElementById("planeEqPointZ").value.trim();

        let pointOnPlane = null;
        let calculationMode = "auto"; // "auto" (constante d) ou "point" (point impos√©)

        // CAS A : L'utilisateur a rempli les coordonn√©es (ou s√©lectionn√© un point)
        if (pxStr !== "" || pyStr !== "" || pzStr !== "") {
          calculationMode = "point";
          const px = parseFloat(pxStr) || 0;
          const py_ui = parseFloat(pyStr) || 0; // Profondeur
          const pz_ui = parseFloat(pzStr) || 0; // Hauteur

          // Cr√©ation du point ThreeJS (X, Hauteur, Profondeur)
          pointOnPlane = new THREE.Vector3(px, pz_ui, py_ui);
        }
        // CAS B : Calcul automatique via la constante 'd' de l'√©quation
        else {
          // Extraction de la constante 'd'
          let constantStr = equationStr
            .replace(/[+-]?[\d\\.]*\s*\*?\s*[xyz]/gi, "") // Enlever tous les termes en x, y, z
            .replace(/--/g, "+") // Nettoyer les doubles signes
            .trim();

          let d = 0;
          try {
            if (constantStr) {
              // √âvaluer l'expression math√©matique restante (ex: "- 6" ‚Üí -6)
              d = new Function("return " + constantStr)();
            }
          } catch (e) {
            console.error("Erreur lors du calcul de la constante d:", e);
          }

          // Trouver un point arbitraire qui satisfait ax + by + cz + d = 0
          // On choisit le plus simple (mettre 2 coordonn√©es √† 0)
          if (Math.abs(normal.x) > 1e-6) {
            pointOnPlane = new THREE.Vector3(-d / normal.x, 0, 0);
          } else if (Math.abs(normal.z) > 1e-6) {
            pointOnPlane = new THREE.Vector3(0, 0, -d / normal.z);
          } else if (Math.abs(normal.y) > 1e-6) {
            pointOnPlane = new THREE.Vector3(0, -d / normal.y, 0);
          } else {
            pointOnPlane = new THREE.Vector3(0, 0, 0);
          }
        }

        // ========================================
        // 5. G√âN√âRATION DU NOM ET CR√âATION
        // ========================================
        let baseName;
        if (calculationMode === "point") {
          // Nom bas√© sur la normale (plus explicite)
          baseName = `Plan(n[${a},${b},${c}])`;
        } else {
          // Nom bas√© sur l'√©quation (tronqu√©e pour la lisibilit√©)
          baseName = `Plan(${formatNumber(a)}x+${formatNumber(b)}y+${formatNumber(c)}z...)`;
        }

        const uniqueName = geometryManager.generateUniqueName(baseName, "plane");
        const newPlane = new Plane(uniqueName, pointOnPlane, normal, 0xffeb3b);

        geometryManager.addPlane(newPlane);
        updateAllUI();
        saveState();

        // ========================================
        // 6. NETTOYAGE DES CHAMPS
        // ========================================
        document.getElementById("planeEquationInput").value = "";

        // Remettre le select sur "d√©faut"
        const select = document.getElementById("planeEquationPointSelect");
        if (select) select.value = "";

        // Vider les champs manuels
        document.getElementById("planeEqPointX").value = "";
        document.getElementById("planeEqPointY").value = "";
        document.getElementById("planeEqPointZ").value = "";

        // Message de confirmation
        showSplashScreen(`‚úÖ Plan "${uniqueName}" cr√©√© !`);
      }
      function removePlaneById(id) {
        const p = geometryManager.findPlaneById(id);
        if (p && confirm(`Supprimer le plan "${p.name}" ?`)) {
          if (selectedObjectInstance === p) {
            deselectCurrentObject();
          }
          // Chercher et supprimer le vecteur normal associ√© s'il existe
          const normalVector = geometryManager.vectors.find((v) => v.parentPlaneId === p.id && v.isNormalVector);
          if (normalVector) {
            geometryManager.removeVector(normalVector);
          }

          // Supprimer le plan lui-m√™me
          geometryManager.removePlane(p);
          updateAllUI();
          saveState();
        }
      }

      function clearAllPlanes() {
        if (confirm("Effacer tous les plans et leurs normales associ√©es ?")) {
          // D'abord, trouver et supprimer tous les vecteurs normaux
          deselectCurrentObject();
          const normalVectors = geometryManager.vectors.filter((v) => v.isNormalVector);
          normalVectors.forEach((v) => geometryManager.removeVector(v));

          // Ensuite, supprimer tous les plans
          geometryManager.planes.forEach((plane) => plane.removeFromScene(scene));
          geometryManager.planes = [];
          updateAllUI();
          saveState();
        }
      }

      function togglePlaneVisibility(id) {
        const p = geometryManager.findPlaneById(id);
        if (p) {
          p.setVisibility(!p.isVisible);
          updatePlaneList();
        }
      }

      // --- Vecteurs ---
      function addVectorFromPoints() {
        const [sIdx, eIdx] = ["vectorStartPoint", "vectorEndPoint"].map((id) => document.getElementById(id).value);
        if (sIdx === "" || eIdx === "" || sIdx === eIdx) {
          showSplashScreen("S√©lectionnez deux points diff√©rents.");
          return;
        }
        const pS = geometryManager.points[sIdx],
          pE = geometryManager.points[eIdx];
        const c = new THREE.Vector3().subVectors(pE.position, pS.position);
        const n = `Vecteur(${pS.name}${pE.name})`;

        const baseName = `Vecteur(${pS.name}${pE.name})`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "vector");
        geometryManager.addVector(new Vector(uniqueName, pS.position, c));
        updateAllUI();
        saveState();
      }

      function addVectorFromCoords() {
        const n = document.getElementById("vectorNameCoords").value.trim() || "Vecteur";

        // V√©rification doublon de nom
        if (geometryManager.vectors.some((vector) => vector.name === n)) {
          showSplashScreen(`Le nom de vecteur "${n}" est d√©j√† utilis√©. Veuillez en choisir un autre.`);
          return;
        }

        // 1. Lecture des COMPOSANTES du vecteur (Vx, Vy, Vz)
        const vx = parseFloat(document.getElementById("vectorCoordX").value);
        const vy_vec = parseFloat(document.getElementById("vectorCoordY").value); // Profondeur (UI)
        const vz_vec = parseFloat(document.getElementById("vectorCoordZ").value); // Hauteur (UI)

        // 2. Lecture de l'ORIGINE du vecteur (Ox, Oy, Oz) - C'est ici qu'√©tait le probl√®me
        // On lit maintenant ce que vous tapez, ou ce qui a √©t√© rempli automatiquement
        const ox = parseFloat(document.getElementById("vectorOriginX").value);
        const oy_org = parseFloat(document.getElementById("vectorOriginY").value); // Profondeur (UI)
        const oz_org = parseFloat(document.getElementById("vectorOriginZ").value); // Hauteur (UI)

        // 3. Validation
        // On v√©rifie que TOUT est num√©rique. Si une case origine est vide, on consid√®re que c'est invalide (ou on pourrait mettre 0 par d√©faut).
        if ([vx, vy_vec, vz_vec, ox, oy_org, oz_org].some(isNaN)) {
          showSplashScreen("Veuillez remplir toutes les coordonn√©es (Composantes ET Origine).");
          return;
        }

        // 4. Cr√©ation des objets Three.js
        // Attention √† l'inversion Y/Z sp√©cifique √† votre application :
        // UI (X, Profondeur, Hauteur) -> ThreeJS (x, z, y)
        const comps = new THREE.Vector3(vx, vz_vec, vy_vec);
        const origin = new THREE.Vector3(ox, oz_org, oy_org);

        // 5. Ajout
        geometryManager.addVector(new Vector(n, origin, comps));

        cancelVectorEdit(); // Vide les champs proprement
        updateAllUI();
        saveState();
      }

      function updateVector() {
        const id = parseInt(document.getElementById("editVectorId").value);
        const v = geometryManager.findVectorById(id);
        if (!v) return;

        const n = document.getElementById("vectorNameCoords").value.trim();

        // V√©rif doublon de nom
        if (geometryManager.vectors.some((vec) => vec.name === n && vec.id !== id)) {
          showSplashScreen(`Le nom "${n}" est d√©j√† utilis√©.`);
          return;
        }

        // 1. Lecture des COMPOSANTES (Vx, Vy, Vz)
        const vx = parseFloat(document.getElementById("vectorCoordX").value);
        const vy_ui = parseFloat(document.getElementById("vectorCoordY").value);
        const vz_ui = parseFloat(document.getElementById("vectorCoordZ").value);

        // 2. Lecture de l'ORIGINE (Ox, Oy, Oz) - AJOUT CRUCIAL
        // On lit maintenant les valeurs que vous avez saisies manuellement
        const ox = parseFloat(document.getElementById("vectorOriginX").value);
        const oy_ui = parseFloat(document.getElementById("vectorOriginY").value);
        const oz_ui = parseFloat(document.getElementById("vectorOriginZ").value);

        // V√©rification de validit√©
        if ([vx, vy_ui, vz_ui, ox, oy_ui, oz_ui].some((val) => isNaN(val))) {
          showSplashScreen("Toutes les coordonn√©es (Composantes et Origine) doivent √™tre valides.");
          return;
        }

        // 3. Cr√©ation des vecteurs ThreeJS (Attention √† l'inversion Y/Z)
        const components = new THREE.Vector3(vx, vz_ui, vy_ui);
        const origin = new THREE.Vector3(ox, oz_ui, oy_ui);

        // 4. Application de la mise √† jour
        // On ignore d√©sormais le menu d√©roulant, on fait confiance aux champs de saisie
        v.update(n, origin, components);

        // 5. Finalisation
        updateAllUI();
        cancelVectorEdit();
        saveState();
        showSplashScreen("Vecteur mis √† jour !");
      }

      function deleteEditingVector() {
        const id = parseInt(document.getElementById("editVectorId").value);
        if (isNaN(id)) return; // S√©curit√© pour √©viter les erreurs

        const vector = geometryManager.findVectorById(id);
        if (vector) {
          // On utilise la fonction de suppression existante, qui g√®re la confirmation
          removeVectorById(id);
          // On r√©initialise le formulaire
          cancelVectorEdit();
        }
      }

      function cancelVectorEdit() {
        // 1. Vider les champs
        document.getElementById("vectorNameCoords").value = "";
        document.getElementById("vectorCoordX").value = "";
        document.getElementById("vectorCoordY").value = "";
        document.getElementById("vectorCoordZ").value = "";
        document.getElementById("vectorOriginX").value = "";
        document.getElementById("vectorOriginY").value = "";
        document.getElementById("vectorOriginZ").value = "";
        document.getElementById("editVectorId").value = "";
        document.getElementById("vectorOriginPoint").value = "";

        // 2. R√©tablir les boutons
        const addBtn = document.getElementById("addVectorFromCoordsBtn");
        if (addBtn) addBtn.style.display = "block"; // On r√©affiche "Ajouter"

        const editActions = document.getElementById("vectorEditActions");
        if (editActions) editActions.style.display = "none"; // On cache "Mettre √† jour"

        // 3. D√©s√©lectionner l'objet 3D (optionnel mais recommand√©)
        deselectCurrentObject();
      }

      function removeVectorById(id) {
        const v = geometryManager.findVectorById(id);
        if (v && confirm(`Supprimer "${v.name}" ?`)) {
          if (selectedObjectInstance === v) {
            deselectCurrentObject();
          }
          geometryManager.removeVector(v);
          updateAllUI();
          saveState();
        }
      }

      function clearAllVectors() {
        if (confirm("Effacer tous les vecteurs ?")) {
          geometryManager.vectors.forEach((vector) => vector.removeFromScene(scene));
          geometryManager.vectors = [];
          updateAllUI();
        }
      }

      function toggleVectorVisibility(id) {
        const v = geometryManager.findVectorById(id);
        if (v) {
          v.setVisibility(!v.isVisible);
          updateVectorList();
        }
      }

      function performRaycastSelection(screenX, screenY) {
        mouse.x = (screenX / window.innerWidth) * 2 - 1;
        mouse.y = -(screenY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const meshes = [
          ...geometryManager.points.map((p) => p.mesh),
          ...geometryManager.lines.map((l) => l.mesh),
          ...geometryManager.planes.map((p) => p.mesh),
          ...geometryManager.vectors
            .map((v) => v.arrowHelper)
            .filter(Boolean)
            .flatMap((a) => [a.line, a.cone]),
        ];

        const intersects = raycaster.intersectObjects(meshes);

        if (intersects.length > 0) {
          // Un objet est touch√©, on le s√©lectionne
          handleSelection(intersects[0].object);
        } else {
          // Aucun objet n'est touch√©, on d√©s√©lectionne tout
          deselectCurrentObject();
          cancelEdit();
          cancelVectorEdit();
        }
      }

      function handleSelection(mesh) {
        const inst = mesh.userData.instance;
        if (!inst) return;

        // 1. Gestion du Toggle (D√©s√©lection si d√©j√† s√©lectionn√©)
        if (inst === selectedObjectInstance) {
          deselectCurrentObject();
          // On annule les modes d'√©dition sp√©cifiques
          if (typeof cancelEdit === "function") cancelEdit();
          if (typeof cancelVectorEdit === "function") cancelVectorEdit();
          if (typeof cancelLineEdit === "function") cancelLineEdit();
          if (typeof cancelPlaneEdit === "function") cancelPlaneEdit();
          return;
        }

        // 2. Nouvelle s√©lection
        deselectCurrentObject(); // Nettoie la s√©lection pr√©c√©dente
        selectedObjectInstance = inst;

        // 3. Attachement du Gizmo (Fl√®ches de d√©placement)
        if (transformControl) {
          if (inst instanceof Vector && inst.arrowHelper) {
            transformControl.attach(inst.arrowHelper);
            inst.arrowHelper.setColor(0xffff00); // Jaune
          } else {
            transformControl.attach(mesh);
            // Surbrillance
            if (mesh.material && mesh.material.color) {
              mesh.material.color.set(0xffff00);
              if (inst instanceof Plane) mesh.material.opacity = 0.75;
            }
          }
          transformControl.setMode("translate");
        }

        // =========================================================
        // 4. MISE √Ä JOUR DU MENU TRANSFORMATION (La nouveaut√© est ici)
        // =========================================================

        // A. On cache le texte "Veuillez s√©lectionner..."
        const hint = document.getElementById("transformations-hint");
        if (hint) hint.style.display = "none";

        // B. On affiche le conteneur des inputs
        const container = document.getElementById("transformations-container");
        if (container) container.style.display = "block";

        // C. On r√©initialise les valeurs par d√©faut (pour √©viter de garder les anciennes)
        document.getElementById("transX").value = "0";
        document.getElementById("transY").value = "0";
        document.getElementById("transZ").value = "0";
        document.getElementById("rotationAngle").value = "90";

        // D. On met √† jour les listes d√©roulantes (Centre de rotation, R√©f sym√©trie)
        // pour qu'elles contiennent l'objet s√©lectionn√© si besoin
        updateSelects();
        updateSymmetryUI();

        // =========================================================

        // 5. Mise √† jour du panneau d'√©dition classique (Nom, Coordonn√©es)
        // Note : On passe 'false' ou on modifie la logique pour ne pas forcer l'ouverture du panneau
        // si vous √™tes sur mobile.
        const isMobile = window.innerWidth <= 768;
        updatePanelForSelection(inst, !isMobile);
      }

      function deselectCurrentObject() {
        if (transformControl) {
          transformControl.detach();
        }

        // Gestion de l'UI Transformation : Retour √† l'√©tat "Pas de s√©lection"
        const hint = document.getElementById("transformations-hint");
        const container = document.getElementById("transformations-container");
        if (hint) hint.style.display = "block"; // Affiche "Faites un clic droit..." ou "S√©lectionnez..."
        if (container) container.style.display = "none"; // Cache les inputs

        if (!selectedObjectInstance) return;

        const inst = selectedObjectInstance;

        // Restaurer la couleur
        if (inst instanceof Vector) {
          inst.arrowHelper.setColor(inst.color);
        } else if (inst.mesh) {
          inst.mesh.material.color.copy(inst.color);
          if (inst instanceof Plane) inst.mesh.material.opacity = 0.5; // ou 0.4 selon votre config
        }

        selectedObjectInstance = null;
      }

      function updatePanelForSelection(inst) {
        // D√âTECTION : Si largeur √©cran <= 768px, on consid√®re que c'est du mobile/tactile
        const isMobile = window.innerWidth <= 768;

        // Si on est sur mobile, shouldOpen sera FALSE.
        // Le panneau restera donc ferm√© gr√¢ce aux modifications ci-dessus.
        const shouldOpen = !isMobile;

        if (inst instanceof Point) {
          // On passe l'index et le bool√©en
          editPoint(geometryManager.points.indexOf(inst), shouldOpen);
        } else if (inst instanceof Vector) {
          editVector(inst.id, shouldOpen);
        } else if (inst instanceof Line3D) {
          editLine(inst.id, shouldOpen);
        } else if (inst instanceof Plane) {
          editPlane(inst.id, shouldOpen);
        }
      }

      function constructChaslesSum() {
        // 1. Nettoyer toute construction pr√©c√©dente pour repartir de z√©ro
        clearChaslesConstruction();

        // 2. R√©cup√©rer les objets s√©lectionn√©s dans l'interface
        const u = geometryManager.findVectorById(parseInt(document.getElementById("sumVectorSelect1").value));
        const v = geometryManager.findVectorById(parseInt(document.getElementById("sumVectorSelect2").value));
        const originId = document.getElementById("sumVectorOrigin").value;
        const resultDiv = document.getElementById("vectorSumResult");

        if (!u || !v || originId === "") {
          showSplashScreen("Veuillez s√©lectionner deux vecteurs et un point de d√©part pour la construction.");
          resultDiv.textContent = "S√©lection invalide.";
          return;
        }

        const pointA =
          originId === "origin"
            ? new THREE.Vector3(0, 0, 0)
            : geometryManager.points[parseInt(originId)].position.clone();

        // 3. Calculer les points cl√©s de la construction
        const pointB = new THREE.Vector3().addVectors(pointA, u.components);

        // 4. Cr√©er les objets visuels et les ajouter au suivi
        // Repr√©sentant de u (bleu)
        const u_rep = new Vector(
          geometryManager.generateUniqueName(`Rep(${u.name})`, "vector"),
          pointA,
          u.components,
          0x2196f3
        );
        geometryManager.addVector(u_rep);
        currentConstructionObjects.push(u_rep);

        // Repr√©sentant de v (rouge)
        const v_rep = new Vector(
          geometryManager.generateUniqueName(`Rep(${v.name})`, "vector"),
          pointB,
          v.components,
          0xf44336
        );
        geometryManager.addVector(v_rep);
        currentConstructionObjects.push(v_rep);

        // Vecteur somme (violet)
        const sumComponents = new THREE.Vector3().addVectors(u.components, v.components);
        const sum_vec = new Vector(
          geometryManager.generateUniqueName(`Somme(${u.name},${v.name})`, "vector"),
          pointA,
          sumComponents,
          0x8a2be2
        );
        geometryManager.addVector(sum_vec);
        currentConstructionObjects.push(sum_vec);

        // 5. Afficher le r√©sultat dans l'UI
        resultDiv.innerHTML = `Construction de Chasles effectu√©e.<br>
                               <strong>${u_rep.name} + ${v_rep.name} = ${sum_vec.name}</strong><br>
                               Composantes somme: <strong>(${formatNumber(sumComponents.x)}, ${formatNumber(
          sumComponents.y
        )}, ${formatNumber(sumComponents.z)})</strong>`;

        // 6. Mettre √† jour la sc√®ne et afficher le bouton de nettoyage
        updateAllUI();
        saveState();
        document.getElementById("clearChaslesBtn").style.display = "block";
      }

      function clearChaslesConstruction() {
        if (currentConstructionObjects.length === 0) {
          return; // Rien √† faire
        }

        // Parcourir la liste des objets suivis et les supprimer
        currentConstructionObjects.forEach((obj) => {
          if (obj instanceof Vector) {
            geometryManager.removeVector(obj);
          }
        });

        // Vider la liste de suivi
        currentConstructionObjects = [];

        // R√©initialiser l'interface
        document.getElementById("clearChaslesBtn").style.display = "none";
        document.getElementById("vectorSumResult").innerHTML = "";

        updateAllUI();
      }

      function displayPlaneEquation() {
        const s = document.getElementById("equationPlaneSelect"),
          r = document.getElementById("planeEquationDisplay");
        if (!s || !r) return;

        const pId = parseInt(s.value),
          p = geometryManager.findPlaneById(pId);
        if (!p) {
          r.innerHTML = "Aucun plan s√©lectionn√©.";
          return;
        }

        const n = p.displayNormal;
        const p0 = p.pointOnPlane;
        // La constante 'd' de l'√©quation ax+by+cz+d=0
        const d = -n.dot(p0);

        const terms = [];

        // Terme en X
        if (Math.abs(n.x) > 1e-6) {
          if (Math.abs(n.x - 1) < 1e-6) terms.push("x");
          else if (Math.abs(n.x + 1) < 1e-6) terms.push("-x");
          else terms.push(`${formatNumber(n.x, 2)}x`);
        }

        // Terme en Y (profondeur) -> utilise n.z
        if (Math.abs(n.z) > 1e-6) {
          const sign = n.z > 0 ? " + " : " - ";
          const absValue = Math.abs(n.z);
          if (absValue === 1) terms.push(`${sign}y`);
          else terms.push(`${sign}${formatNumber(absValue, 2)}y`);
        }

        // Terme en Z (hauteur) -> utilise n.y
        if (Math.abs(n.y) > 1e-6) {
          const sign = n.y > 0 ? " + " : " - ";
          const absValue = Math.abs(n.y);
          if (absValue === 1) terms.push(`${sign}z`);
          else terms.push(`${sign}${formatNumber(absValue, 2)}z`);
        }

        // Terme constant D
        if (Math.abs(d) > 1e-6) {
          const sign = d > 0 ? " + " : " - ";
          terms.push(`${sign}${formatNumber(Math.abs(d), 2)}`);
        }

        // Si tous les coefficients sont nuls
        if (terms.length === 0) {
          r.innerHTML = "<strong>0 = 0</strong>";
          return;
        }

        // On assemble l'√©quation en joignant les termes
        let equation = terms.join(" ").trim();

        // On nettoie le d√©but de la cha√Æne pour un affichage parfait
        if (equation.startsWith("+ ")) {
          // Enl√®ve le " + " initial si le premier terme est positif
          equation = equation.substring(2);
        } else if (equation.startsWith("- ")) {
          // Enl√®ve l'espace apr√®s le "-" initial si le premier terme est n√©gatif
          equation = "-" + equation.substring(2);
        }

        r.innerHTML = `<strong>${equation} = 0</strong>`;
      }

      function displayLineEquation(tempLineInstance = null) {
        const s = document.getElementById("equationLineSelect"),
          r = document.getElementById("lineEquationDisplay");
        if (!s || !r) return;

        let l;

        // Si une instance temporaire est fournie (pendant le drag), on l'utilise
        if (tempLineInstance) {
          l = tempLineInstance;
        } else {
          // Sinon, on cherche la droite s√©lectionn√©e dans le gestionnaire
          const lId = parseInt(s.value);
          l = geometryManager.findLineById(lId);
        }

        if (!l) {
          r.innerHTML = "Aucune droite s√©lectionn√©e.";
          return;
        }

        const p0 = l.startPoint;
        const v = l.directorVector;

        const formatTTerm = (coefficient) => {
          if (Math.abs(coefficient) < 1e-6) return "";
          const sign = coefficient > 0 ? " + " : " - ";
          const absValue = Math.abs(coefficient);
          if (Math.abs(absValue - 1) < 1e-6) return `${sign}t`;
          else return `${sign}${formatNumber(absValue, 2)}t`;
        };

        const eX = `x = ${formatNumber(p0.x, 2)}${formatTTerm(v.x)}`;

        // La ligne 'y' (profondeur) doit afficher les composantes Z de Three.js
        const eY = `y = ${formatNumber(p0.z, 2)}${formatTTerm(v.z)}`;
        // La ligne 'z' (hauteur) doit afficher les composantes Y de Three.js
        const eZ = `z = ${formatNumber(p0.y, 2)}${formatTTerm(v.y)}`;

        r.innerHTML = `<strong>${eX}<br>${eY}<br>${eZ}</strong>`;
      }

      function calculateVectorSumFree() {
        // Nettoyer toute construction visuelle de Chasles qui pourrait √™tre active
        clearChaslesConstruction();

        const v1 = geometryManager.findVectorById(parseInt(document.getElementById("sumVectorSelect1").value));
        const v2 = geometryManager.findVectorById(parseInt(document.getElementById("sumVectorSelect2").value));
        const r = document.getElementById("vectorSumResult");

        if (!v1 || !v2) {
          showSplashScreen("Veuillez s√©lectionner deux vecteurs.");
          r.textContent = "Veuillez s√©lectionner deux vecteurs.";
          return;
        }

        const sumComponents = new THREE.Vector3().addVectors(v1.components, v2.components);

        let sumOrigin;
        const originSelection = document.getElementById("sumVectorOrigin").value;
        let originPointName = "l'origine du rep√®re";

        if (originSelection !== "origin" && originSelection !== "") {
          const originPoint = geometryManager.points[parseInt(originSelection)];
          sumOrigin = originPoint.position.clone();
          originPointName = `point ${originPoint.name}`;
        } else {
          sumOrigin = new THREE.Vector3(0, 0, 0); // Origine par d√©faut
        }

        const baseName = `Somme(${v1.name},${v2.name})`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "vector");

        const newVector = new Vector(uniqueName, sumOrigin, sumComponents, 0x9932cc);
        geometryManager.addVector(newVector);

        const componentsText = `(${formatNumber(sumComponents.x)}, ${formatNumber(sumComponents.y)}, ${formatNumber(
          sumComponents.z
        )})`;
        const normText = formatNumber(sumComponents.length(), 3);

        r.innerHTML = `Vecteur somme "${uniqueName}" cr√©√© depuis ${originPointName}.<br>
                     Composantes: <strong>${componentsText}</strong><br>
                     Norme ‚âà <strong>${normText}</strong>`;

        updateAllUI();
        saveState();
      }

      function calculateScalarProduct() {
        const [v1, v2] = [
          geometryManager.findVectorById(parseInt(document.getElementById("dotVectorSelect1").value)),
          geometryManager.findVectorById(parseInt(document.getElementById("dotVectorSelect2").value)),
        ];
        const r = document.getElementById("scalarProductResult");

        if (!v1 || !v2) {
          r.textContent = "S√©lectionnez deux vecteurs.";
          return;
        }

        // 1. Calcul du produit scalaire
        const dP = v1.components.dot(v2.components);

        // 2. Calcul des normes
        const len1 = v1.components.length();
        const len2 = v2.components.length();
        const productLen = len1 * len2;

        let angleInfo = "";

        // 3. Calcul de l'angle et du cosinus (si les vecteurs ne sont pas nuls)
        if (productLen > 1e-9) {
          // Calcul du cosinus
          let cosTheta = dP / productLen;

          // Correction des erreurs d'arrondi flottant (ex: 1.000000002 qui ferait planter acos)
          cosTheta = Math.max(-1, Math.min(1, cosTheta));

          // Calcul de l'angle en radians puis degr√©s
          const angleRad = Math.acos(cosTheta);
          const angleDeg = angleRad * (180 / Math.PI);

          angleInfo = `<br>
                 <span style="font-size:0.9em; color:#555;">
                    cos(Œ∏) = <strong>${cosTheta.toFixed(4)}</strong><br>
                    Angle Œ∏ ‚âà <strong>${angleDeg.toFixed(2)}¬∞</strong>
                 </span>`;
        } else {
          angleInfo = `<br><span style="font-size:0.9em; color:#a00;">Angle ind√©fini (vecteur nul)</span>`;
        }

        // 4. Affichage du r√©sultat complet
        r.innerHTML = `<strong>${v1.name} ‚ãÖ ${v2.name} = ${parseFloat(dP.toFixed(4))}</strong>${angleInfo}`;
      }

      function calculateVectorProduct() {
        const [v1, v2] = [
          geometryManager.findVectorById(parseInt(document.getElementById("crossVectorSelect1").value)),
          geometryManager.findVectorById(parseInt(document.getElementById("crossVectorSelect2").value)),
        ];
        const r = document.getElementById("vectorProductResult");

        if (!v1 || !v2) {
          showSplashScreen("S√©lectionnez deux vecteurs.");
          r.textContent = "Veuillez s√©lectionner deux vecteurs.";
          return;
        }

        let o = new THREE.Vector3(0, 0, 0);
        const oS = document.getElementById("crossVectorOrigin").value;
        if (oS !== "origin" && oS !== "") {
          o = geometryManager.points[parseInt(oS)].position;
        }
        const rC = new THREE.Vector3().crossVectors(v1.components, v2.components);

        const baseName = `ProduitVect(${v1.name},${v2.name})`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "vector");

        const newVector = new Vector(uniqueName, o, rC, 0x4682b4);
        geometryManager.addVector(newVector);

        // --- NOUVELLE MISE EN FORME HTML (SIMPLE ET ALIGN√âE √Ä GAUCHE) ---
        const componentsText = `(${formatNumber(rC.x)}, ${formatNumber(rC.y)}, ${formatNumber(rC.z)})`;
        const normText = formatNumber(rC.length(), 3);

        r.innerHTML = `Vecteur "${uniqueName}" cr√©√©<br>
                     Composantes: <strong>${componentsText}</strong><br>
                     Norme ‚âà <strong>${normText}</strong>`;
        // --- FIN DE LA MODIFICATION ---

        updateAllUI();
        saveState();
      }

      function calculatePointPointDistance() {
        const [i1, i2] = [
          document.getElementById("distPointSelect1").value,
          document.getElementById("distPointSelect2").value,
        ];
        if (i1 === "" || i2 === "") return;
        const p1 = geometryManager.points[i1],
          p2 = geometryManager.points[i2];
        const d = p1.position.distanceTo(p2.position);
        document.getElementById("distResult1").innerHTML = `Dist(${p1.name},${p2.name}) = <strong>${d.toFixed(
          3
        )}</strong>`;
      }

      function calculatePointLineDistance() {
        const pI = document.getElementById("distPointSelect3").value,
          lI = document.getElementById("distLineSelect1").value;
        if (pI === "" || lI === "") return;
        const p = geometryManager.points[pI],
          l = geometryManager.findLineById(parseInt(lI));

        // --- CORRECTION APPLIQU√âE ---
        const lineMath = new THREE.Line3(
          l.startPoint.clone().add(l.directorVector.clone().normalize().multiplyScalar(-1000)),
          l.startPoint.clone().add(l.directorVector.clone().normalize().multiplyScalar(1000))
        );
        const closestPoint = new THREE.Vector3();
        lineMath.closestPointToPoint(p.position, true, closestPoint);
        const d = p.position.distanceTo(closestPoint);
        // --- FIN DE LA CORRECTION ---

        document.getElementById("distResult2").innerHTML = `Dist(${p.name}, ${l.name}) = <strong>${d.toFixed(
          3
        )}</strong>`;
      }

      function calculatePointPlaneDistance() {
        const pI = document.getElementById("calcPointSelect").value,
          plId = parseInt(document.getElementById("calcPlaneSelect1").value);
        const r = document.getElementById("calcResultDisplay1"); // CORRECTED ID
        if (pI === "" || isNaN(plId)) {
          r.textContent = "S√©lectionnez un point et un plan.";
          return;
        }
        const pt = geometryManager.points[pI],
          pl = geometryManager.findPlaneById(plId);
        const vP0P = new THREE.Vector3().subVectors(pt.position, pl.pointOnPlane);
        const d = Math.abs(vP0P.dot(pl.normal));
        r.innerHTML = `Distance = <strong>${d.toFixed(3)}</strong>`;
      }

      function calculateLineLineAngle() {
        const [l1, l2] = [
          geometryManager.findLineById(parseInt(document.getElementById("angleLineSelect1").value)),
          geometryManager.findLineById(parseInt(document.getElementById("angleLineSelect2").value)),
        ];
        const r = document.getElementById("angleResult1");
        if (!l1 || !l2) {
          r.textContent = "S√©lectionnez deux droites.";
          return;
        }
        let a = (l1.directorVector.angleTo(l2.directorVector) * 180) / Math.PI;
        if (a > 90) a = 180 - a;
        r.innerHTML = `Angle ‚âà <strong>${a.toFixed(2)}¬∞</strong>`;
      }

      function calculatePlanePlaneAngle() {
        const [p1, p2] = [
          geometryManager.findPlaneById(parseInt(document.getElementById("anglePlaneSelect1").value)),
          geometryManager.findPlaneById(parseInt(document.getElementById("anglePlaneSelect2").value)),
        ];
        const r = document.getElementById("angleResult2");
        if (!p1 || !p2) {
          r.textContent = "S√©lectionnez deux plans.";
          return;
        }
        let a = (p1.normal.angleTo(p2.normal) * 180) / Math.PI;
        if (a > 90) a = 180 - a;
        r.innerHTML = `Angle ‚âà <strong>${a.toFixed(2)}¬∞</strong>`;
      }

      function calculateLinePlaneAngle() {
        const l = geometryManager.findLineById(parseInt(document.getElementById("angleLineSelect3").value)),
          p = geometryManager.findPlaneById(parseInt(document.getElementById("anglePlaneSelect3").value));

        const r = document.getElementById("angleResult3");
        if (!l || !p) {
          r.textContent = "S√©lectionnez une droite et un plan.";
          return;
        }
        const dot = Math.abs(l.directorVector.clone().normalize().dot(p.normal));
        const a = (Math.asin(dot) * 180) / Math.PI;
        r.innerHTML = `Angle ‚âà <strong>${a.toFixed(2)}¬∞</strong>`;
      }

      function calculateLinePlaneIntersection() {
        console.log("calculateLinePlaneIntersection1");
        // 1. R√©cup√©ration des √©l√©ments UI (inchang√©)
        const lineSelect = document.getElementById("calcLineSelect");
        const planeSelect = document.getElementById("calcPlaneSelect2");
        const resultDisplay = document.getElementById("calcResultDisplay2");

        if (!lineSelect || !planeSelect || !resultDisplay) {
          console.error("IDs de s√©lection pour le calcul d'intersection non trouv√©s.");
          return;
        }

        // 2. R√©cup√©ration des objets g√©om√©triques (inchang√©)
        const line = geometryManager.findLineById(parseInt(lineSelect.value));
        const plane = geometryManager.findPlaneById(parseInt(planeSelect.value));

        if (!line || !plane) {
          resultDisplay.innerHTML = "Veuillez s√©lectionner une droite et un plan valides.";
          return;
        }

        // 3. Calcul de l'intersection (inchang√©)
        const p0 = line.startPoint;
        const v = line.directorVector;
        const planePoint = plane.pointOnPlane;
        const n = plane.displayNormal;
        const dotNV = n.dot(v);

        if (Math.abs(dotNV) < 1e-6) {
          const pointIsOnPlane = Math.abs(n.dot(new THREE.Vector3().subVectors(p0, planePoint))) < 1e-6;
          if (pointIsOnPlane) {
            resultDisplay.innerHTML = "La droite est contenue dans le plan (infinit√© d'intersections).";
          } else {
            resultDisplay.innerHTML = "La droite est parall√®le au plan (aucune intersection).";
          }
          return;
        }

        const t = n.dot(new THREE.Vector3().subVectors(planePoint, p0)) / dotNV;
        const intersectionPoint = new THREE.Vector3().copy(p0).addScaledVector(v, t);

        // --- D√âBUT DE LA MODIFICATION ---
        // On applique VOTRE fonction formatNumber aux r√©sultats du calcul

        // 4. Formatage des coordonn√©es pour l'affichage et la saisie
        const formattedX = formatNumber(intersectionPoint.x);
        const formattedY_UI = formatNumber(intersectionPoint.z); // Le Z de Three.js est le Y de l'UI (profondeur)
        const formattedZ_UI = formatNumber(intersectionPoint.y); // Le Y de Three.js est le Z de l'UI (hauteur)

        // 5. Remplissage des champs de saisie avec les valeurs format√©es
        const pointNameInput = document.getElementById("pointName");
        const pointXInput = document.getElementById("pointX");
        const pointYInput = document.getElementById("pointY");
        const pointZInput = document.getElementById("pointZ");

        const baseName = `Intersect(${line.name},${plane.name})`;
        const uniqueName = geometryManager.generateUniqueName(baseName, "point");

        pointNameInput.value = uniqueName;
        pointXInput.value = formattedX;
        pointYInput.value = formattedY_UI;
        pointZInput.value = formattedZ_UI;

        // 6. Affichage du r√©sultat format√© dans la bo√Æte de dialogue
        const displayCoords = `(${formattedX}, ${formattedY_UI}, ${formattedZ_UI})`;

        resultDisplay.innerHTML = `Coordonn√©es ins√©r√©es dans la section 'Ajouter un point'.<br>
                               Nom sugg√©r√© : <strong>${uniqueName}</strong><br>
                               Coordonn√©es calcul√©es : <strong>${displayCoords}</strong>`;

        // --- FIN DE LA MODIFICATION ---
      }

      function calculatePlanePlaneIntersection() {
        console.log("calculatePlanePlaneIntersection");
        const plane1Id = parseInt(document.getElementById("calcPlaneSelect3").value); // CORRECTED ID
        const plane2Id = parseInt(document.getElementById("calcPlaneSelect4").value); // CORRECTED ID
        const r = document.getElementById("calcResultDisplay3");

        const p1 = geometryManager.findPlaneById(plane1Id);
        const p2 = geometryManager.findPlaneById(plane2Id);

        if (!p1 || !p2) {
          r.textContent = "Veuillez s√©lectionner deux plans distincts.";
          return;
        }

        const n1 = p1.normal;
        const n2 = p2.normal;
        const lineDirection = new THREE.Vector3().crossVectors(n1, n2);

        if (lineDirection.lengthSq() < 1e-8) {
          const vec_p1_p2 = new THREE.Vector3().subVectors(p1.pointOnPlane, p2.pointOnPlane);
          if (Math.abs(vec_p1_p2.dot(n2)) < 1e-6) {
            r.textContent = "Les plans sont confondus.";
          } else {
            r.textContent = "Les plans sont parall√®les et distincts.";
          }
          return;
        }

        let linePoint;
        const d1 = n1.dot(p1.pointOnPlane);
        const d2 = n2.dot(p2.pointOnPlane);
        const absDir = new THREE.Vector3(
          Math.abs(lineDirection.x),
          Math.abs(lineDirection.y),
          Math.abs(lineDirection.z)
        );

        try {
          if (absDir.z > absDir.x && absDir.z > absDir.y) {
            const det = n1.x * n2.y - n2.x * n1.y;
            const x = (n2.y * d1 - n1.y * d2) / det;
            const y = (n1.x * d2 - n2.x * d1) / det;
            linePoint = new THREE.Vector3(x, y, 0);
          } else if (absDir.y > absDir.x) {
            const det = n1.x * n2.z - n2.x * n1.z;
            const x = (n2.z * d1 - n1.z * d2) / det;
            const z = (n1.x * d2 - n2.x * d1) / det;
            linePoint = new THREE.Vector3(x, 0, z);
          } else {
            const det = n1.y * n2.z - n1.z * n2.y; // CORRECTION
            const y = (n2.z * d1 - n1.z * d2) / det;
            const z = (n1.y * d2 - n2.y * d1) / det;
            linePoint = new THREE.Vector3(0, y, z);
          }
        } catch (error) {
          r.textContent = "Erreur num√©rique. Plans quasi parall√®les ?";
          return;
        }

        if (isNaN(linePoint.x)) {
          r.textContent = "Calcul impossible (division par z√©ro).";
          return;
        }

        const baseName = `Intersect(${p1.name}, ${p2.name})`;
        const lineName = geometryManager.generateUniqueName(baseName, "line");
        const newLine = new Line3D(lineName, linePoint, lineDirection, 0xff1493);
        geometryManager.addLine(newLine);
        r.textContent = `Droite d'intersection "${lineName}" cr√©√©e.`;
        updateAllUI();
        saveState();
      }

      function calculateLineLineIntersection() {
        const line1Id = parseInt(document.getElementById("calcLineSelect1").value); // CORRECTED ID
        const line2Id = parseInt(document.getElementById("calcLineSelect2").value); // CORRECTED ID
        const r = document.getElementById("calcResultDisplay4");

        const d1 = geometryManager.findLineById(line1Id);
        const d2 = geometryManager.findLineById(line2Id);

        if (!d1 || !d2) {
          r.textContent = "Veuillez s√©lectionner deux droites distinctes.";
          return;
        }

        const p1 = d1.startPoint,
          v1 = d1.directorVector.clone().normalize();
        const p2 = d2.startPoint,
          v2 = d2.directorVector.clone().normalize();

        const v1_cross_v2 = new THREE.Vector3().crossVectors(v1, v2);
        const p1_minus_p2 = new THREE.Vector3().subVectors(p1, p2);

        if (v1_cross_v2.lengthSq() < 1e-8) {
          if (p1_minus_p2.clone().cross(v1).lengthSq() < 1e-8) {
            r.textContent = "Droites colin√©aires (confondues).";
          } else {
            r.textContent = "Droites parall√®les et distinctes.";
          }
          return;
        }

        const mixedProduct = p1_minus_p2.dot(v1_cross_v2);

        if (Math.abs(mixedProduct) < 1e-6) {
          const p2_minus_p1 = p1_minus_p2.clone().negate();
          const v2_cross_p2p1 = new THREE.Vector3().crossVectors(v2, p2_minus_p1);
          const t = v2_cross_p2p1.dot(v1_cross_v2) / v1_cross_v2.lengthSq();
          const intersectionPoint = p1.clone().add(v1.clone().multiplyScalar(t));
          const baseName = `Intersect(${d1.name}, ${d2.name})`;
          const pointName = geometryManager.generateUniqueName(baseName, "point");
          const newPoint = new Point(
            pointName,
            intersectionPoint.x,
            intersectionPoint.y,
            intersectionPoint.z,
            0x00ff00
          );
          geometryManager.addPoint(newPoint);
          r.innerHTML = `Droites s√©cantes.<br>Point "${pointName}" cr√©√©.`;
          updateAllUI();
          saveState();
        } else {
          const distance = Math.abs(mixedProduct) / v1_cross_v2.length();
          r.innerHTML = `Droites non-coplanaires.<br>Distance min ‚âà <strong>${distance.toFixed(3)}</strong>.`;
        }
      }

      // =====================================================================================
      // SECTION 8 : CONTR√îLE CAM√âRA ET FONCTIONS UTILITAIRES
      // =====================================================================================

      function expandSectionAndScrollToItem(itemId, listId) {
        const listElement = document.getElementById(listId);
        if (!listElement) return;

        // 1. Trouver la section parente et la d√©plier si elle est ferm√©e
        const section = listElement.closest(".section.collapsible");
        if (section && section.classList.contains("collapsed")) {
          section.classList.remove("collapsed");
        }

        // 2. On ne fait PLUS d√©filer la page.
        // La ligne suivante est supprim√©e :
        // itemElement.scrollIntoView({ behavior: "smooth", block: "center" });
      }
      function togglePanel() {
        const p = document.getElementById("panel");
        const o = document.getElementById("openBtn");

        // 1. NETTOYAGE CRITIQUE :
        // On s'assure d'enlever la classe qui bloque l'animation (utilis√©e par le swipe)
        p.classList.remove("no-transition");

        // On supprime toute position "en dur" laiss√©e par un √©ventuel swipe inachev√©
        p.style.transform = "";

        // 2. BASCULE LOGIQUE
        panelOpen = !panelOpen;

        // 3. APPLICATION DES CLASSES
        // Le CSS 'transition: transform 0.3s' fera le reste
        p.classList.toggle("hidden", !panelOpen);
        o.classList.toggle("show", !panelOpen);
      }

      function ensurePanelVisible() {
        // La variable globale 'panelOpen' nous indique l'√©tat actuel du panneau.
        if (!panelOpen) {
          // Si le panneau n'est pas ouvert, on appelle la fonction existante pour l'ouvrir.
          togglePanel();
        }
      }

      function addFixedTestPoints() {
        const pts = [
          { n: "A", x: 2, y: 0, z: 0 },
          { n: "B", x: 0, y: 3, z: 0 },
          { n: "C", x: 0, y: 0, z: 4 },
        ];
        pts.forEach((p) => {
          if (!geometryManager.points.some((gp) => gp.name === p.n))
            geometryManager.addPoint(new Point(p.n, p.x, p.y, p.z));
        });
        updateAllUI();
        saveState();
      }

      function toggleAutoLoadTestPoints() {
        const c = document.getElementById("autoLoadTestPointsCheckbox");
        localStorage.setItem("autoLoadTestPoints", c.checked);
      }

      function loadTestPointsOnce() {
        addFixedTestPoints();
      }

      function updateCameraPosition() {
        camera.position.x = cameraTarget.x + cameraDistance * Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x);
        camera.position.y = cameraTarget.y + cameraDistance * Math.sin(cameraRotation.x);
        camera.position.z = cameraTarget.z + cameraDistance * Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x);
        camera.lookAt(cameraTarget);
      }

      function onMouseDown(e) {
        if (isGizmoDragging) return; // <--- AJOUT IMPORTANT
        wasDragged = false;
        if (e.target.closest("#cameraControls")) return;
        if (e.button === 0) isDragging = true;
        else if (e.button === 2) isPanning = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
      }

      function onMouseMove(e) {
        if (isGizmoDragging) return;
        lastTooltipX = e.clientX;
        lastTooltipY = e.clientY;
        const dX = e.clientX - previousMousePosition.x,
          dY = e.clientY - previousMousePosition.y;
        if (isDragging || isPanning) if (Math.abs(dX) > 3 || Math.abs(dY) > 3) wasDragged = true;
        if (isDragging) {
          cameraRotation.y += dX * 0.005;
          cameraRotation.x += dY * 0.005;
          cameraRotation.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraRotation.x));
          updateCameraPosition();
        } else if (isPanning) panCamera(dX, dY);
        previousMousePosition = { x: e.clientX, y: e.clientY };
        if (!isDragging && !isPanning) {
          handleHover(e.clientX, e.clientY);
        }
      }

      function onMouseUp() {
        isDragging = false;
        isPanning = false;
      }

      function onWheel(e) {
        e.preventDefault();
        zoomCamera(e.deltaY * 0.01);
      }

      function panCamera(dX, dY) {
        // Vitesse dynamique : plus on est loin, plus √ßa bouge vite
        // 0.002 est un facteur de sensibilit√© (ajustable)
        const speed = cameraDistance * 0.002;

        const r = new THREE.Vector3();
        camera.getWorldDirection(r);

        const u = camera.up.clone();

        // Produit vectoriel pour avoir la droite/gauche par rapport √† la vue
        r.cross(u).normalize();

        // D√©placement du point cible (Target)
        // Note : On inverse dX pour que le mouvement suive le doigt
        cameraTarget.addScaledVector(r, -dX * speed);
        cameraTarget.addScaledVector(u, dY * speed);

        updateCameraPosition();
      }

      function zoomCamera(d) {
        cameraDistance = Math.max(3, Math.min(50, cameraDistance + d));
        updateCameraPosition();
      }

      function resetCamera(btn) {
        setCameraView("isometric", btn);
      }

      function setCameraView(v, btn) {
        cameraTarget.set(0, 0, 0);
        cameraDistance = 15;
        switch (v) {
          case "top": // Vue de dessus (regarde le plan XY de l'utilisateur, donc XZ interne)
            cameraRotation.x = Math.PI / 2 - 0.001;
            cameraRotation.y = 0;
            break;
          case "front": // Vue de face (regarde le plan XZ de l'utilisateur, donc XY interne)
            cameraRotation.x = 0;
            cameraRotation.y = Math.PI / 2; // On tourne la cam√©ra pour voir le plan XY interne
            break;
          case "side": // Vue de c√¥t√© (regarde le plan YZ de l'utilisateur, donc YZ interne)
            cameraRotation.x = 0;
            cameraRotation.y = 0;
            break;
          default: // Vue isom√©trique
            cameraRotation.x = 0.5;
            cameraRotation.y = 0.5;
        }
        updateCameraPosition();
        toggleButtonState(btn);
      }

      function toggleButtonState(btn) {
        document.querySelectorAll("#cameraControls .camera-btn").forEach((b) => b.classList.remove("active"));
        if (btn) btn.classList.add("active");
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      document.addEventListener("DOMContentLoaded", () => {
        document.querySelectorAll(".section-header").forEach((header) => {
          header.addEventListener("click", () => header.closest(".section").classList.toggle("collapsed"));
        });
        init();
        const resetBtn = document.getElementById("btnReset");
        resetCamera(resetBtn);
      });

      function applyTranslation() {
        if (!selectedObjectInstance) {
          showSplashScreen("Aucun objet n'est s√©lectionn√©.");
          return;
        }

        // 1. R√©cup√©ration des valeurs de l'interface
        const dx = parseFloat(document.getElementById("transX").value) || 0;
        const dy_ui = parseFloat(document.getElementById("transY").value) || 0; // L'utilisateur pense "Y" (Profondeur)
        const dz_ui = parseFloat(document.getElementById("transZ").value) || 0; // L'utilisateur pense "Z" (Hauteur)

        // 2. CORRECTION DE L'AXE : Conversion vers le rep√®re Three.js
        // Three.js X = UI X
        // Three.js Y (Vertical) = UI Z (Hauteur)
        // Three.js Z (Profondeur) = UI Y (Profondeur)
        const translationVector = new THREE.Vector3(dx, dz_ui, dy_ui);

        const inst = selectedObjectInstance;

        // 3. Application de la translation selon le type d'objet
        if (inst instanceof Point) {
          const newPos = inst.position.clone().add(translationVector);
          // Note : update() attend (nom, x, z, y) car elle refait la conversion en interne,
          // mais ici on manipule directement des positions Three.js, donc on passe x, y, z du vecteur position
          // C'est une petite subtilit√© : on met √† jour la position brute.
          inst.position.copy(newPos);
          inst.mesh.position.copy(inst.position);
          inst.updateLabelPosition();
        } else if (inst instanceof Vector) {
          const newOrigin = inst.origin.clone().add(translationVector);
          // Pour le vecteur, on met √† jour l'origine, les composantes ne changent pas
          inst.update(inst.name, newOrigin, inst.components);
        } else if (inst instanceof Plane) {
          inst.pointOnPlane.add(translationVector);
          inst.mesh.position.copy(inst.pointOnPlane);
        } else if (inst instanceof Line3D) {
          // D√©placer le point de d√©part
          inst.startPoint.add(translationVector);

          // Recalculer la g√©om√©trie visuelle
          const lineLength = 100;
          const dir = inst.directorVector.clone().normalize();
          const start = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(-lineLength));
          const end = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(lineLength));

          // Mise √† jour propre de la g√©om√©trie
          inst.mesh.geometry.dispose(); // Nettoyage m√©moire
          inst.mesh.geometry = new THREE.BufferGeometry().setFromPoints([start, end]);

          // R√©initialiser la couleur si n√©cessaire (garde la s√©lection active visuellement)
          if (inst === selectedObjectInstance) {
            inst.mesh.material.color.set(HIGHLIGHT_COLOR);
          }
        }

        // 4. Mise √† jour de l'interface (notamment les coordonn√©es dans la liste)
        updateAllUI();
        saveState();
      }

      function applyRotation() {
        if (!selectedObjectInstance) {
          showSplashScreen("Aucun objet n'est s√©lectionn√©.");
          return;
        }

        // 1. R√©cup√©ration de l'angle
        const angleDeg = parseFloat(document.getElementById("rotationAngle").value) || 0;
        const angleRad = (angleDeg * Math.PI) / 180;

        // 2. R√©cup√©ration et correction de l'Axe
        const axisSelect = document.getElementById("rotationAxisSelect");
        const axisValue = axisSelect.value.toLowerCase().trim(); // S√©curit√© contre les majuscules/espaces

        let rotationAxis;

        // --- C'EST ICI QUE SE JOUE LA CORRECTION ---
        if (axisValue === "x") {
          // Axe X (Rouge) : Ne change pas
          rotationAxis = new THREE.Vector3(1, 0, 0);
        } else if (axisValue === "y") {
          // L'utilisateur choisit "Axe Y" (Profondeur dans votre interface)
          // Cela correspond √† l'axe Z de Three.js (L'axe BLEU)
          rotationAxis = new THREE.Vector3(0, 0, 1);
        } else {
          // L'utilisateur choisit "Axe Z" (Hauteur/Verticale)
          // Cela correspond √† l'axe Y de Three.js (L'axe VERT)
          rotationAxis = new THREE.Vector3(0, 1, 0);
        }

        // 3. R√©cup√©ration du centre de rotation
        const centerValue = document.getElementById("rotationCenterSelect").value;
        const centerOfRotation =
          centerValue === "origin"
            ? new THREE.Vector3(0, 0, 0)
            : geometryManager.points[parseInt(centerValue)].position.clone();

        const inst = selectedObjectInstance;

        // Helper : Appliquer la rotation math√©matique √† un point
        const rotatePoint = (p, c) => {
          p.sub(c); // Ramener au centre relatif
          p.applyAxisAngle(rotationAxis, angleRad); // Tourner
          p.add(c); // Remettre √† la position absolue
        };

        // 4. Application de la rotation selon le type d'objet
        if (inst instanceof Point) {
          const newPos = inst.position.clone();
          rotatePoint(newPos, centerOfRotation);

          // Mise √† jour directe des positions Three.js
          inst.position.copy(newPos);
          inst.mesh.position.copy(inst.position);
          inst.updateLabelPosition();
        } else if (inst instanceof Vector) {
          const newOrigin = inst.origin.clone();
          rotatePoint(newOrigin, centerOfRotation);

          // Le vecteur lui-m√™me (ses composantes) tourne aussi
          const newComponents = inst.components.clone().applyAxisAngle(rotationAxis, angleRad);

          inst.update(inst.name, newOrigin, newComponents);
        } else if (inst instanceof Plane) {
          rotatePoint(inst.pointOnPlane, centerOfRotation);

          // La normale du plan tourne aussi
          inst.normal.applyAxisAngle(rotationAxis, angleRad);
          inst.displayNormal.applyAxisAngle(rotationAxis, angleRad);

          inst.mesh.position.copy(inst.pointOnPlane);
          inst.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), inst.normal.clone().normalize());
        } else if (inst instanceof Line3D) {
          rotatePoint(inst.startPoint, centerOfRotation);
          inst.directorVector.applyAxisAngle(rotationAxis, angleRad);

          // Recalcul g√©om√©trie (identique au fix de translation)
          const lineLength = 100;
          const dir = inst.directorVector.clone().normalize();
          const start = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(-lineLength));
          const end = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(lineLength));

          inst.mesh.geometry.dispose();
          inst.mesh.geometry = new THREE.BufferGeometry().setFromPoints([start, end]);

          // Conserver la couleur de s√©lection
          if (inst === selectedObjectInstance) {
            inst.mesh.material.color.set(HIGHLIGHT_COLOR);
          }
        }

        updateAllUI();
        saveState();
      }

      function updateSymmetryUI() {
        const type = document.getElementById("symmetryTypeSelect").value;
        const container = document.getElementById("symmetryOptionsContainer");
        const applyBtn = document.getElementById("applySymmetryBtn");
        container.innerHTML = ""; // Vider les anciennes options

        if (!type) {
          applyBtn.style.display = "none";
          return;
        }

        // Liste des types qui n√©cessitent une s√©lection d'objet dans la sc√®ne
        const needsSelection = ["point", "line", "plane"];

        if (!needsSelection.includes(type)) {
          // CAS 1 : Sym√©trie "Fixe" (Origine, Axes, Plans principaux)
          // Pas de menu secondaire, on affiche juste le bouton
          container.innerHTML = `<p style="font-size:11px; color:#666; margin:5px 0;">Sym√©trie standard s√©lectionn√©e.</p>`;
          applyBtn.style.display = "block";
          return;
        }

        // CAS 2 : Sym√©trie par rapport √† un objet existant (Code existant)
        let selectHTML = `<label>R√©f√©rence :</label><select id="symmetryRefSelect" style="width: 100%;">`;
        let hasOptions = false;

        if (type === "point") {
          if (geometryManager.points.length > 0) {
            geometryManager.points.forEach((p, i) => {
              selectHTML += `<option value="${i}">${p.name}</option>`;
            });
            hasOptions = true;
          } else {
            selectHTML += `<option value="">Aucun point disponible</option>`;
          }
        } else if (type === "line") {
          if (geometryManager.lines.length > 0) {
            geometryManager.lines.forEach((l) => {
              selectHTML += `<option value="${l.id}">${l.name}</option>`;
            });
            hasOptions = true;
          } else {
            selectHTML += `<option value="">Aucune droite disponible</option>`;
          }
        } else if (type === "plane") {
          if (geometryManager.planes.length > 0) {
            geometryManager.planes.forEach((p) => {
              selectHTML += `<option value="${p.id}">${p.name}</option>`;
            });
            hasOptions = true;
          } else {
            selectHTML += `<option value="">Aucun plan disponible</option>`;
          }
        }

        selectHTML += `</select>`;
        container.innerHTML = selectHTML;
        applyBtn.style.display = hasOptions ? "block" : "none";
      }

      function applySymmetry() {
        if (!selectedObjectInstance) {
          showSplashScreen("Aucun objet n'est s√©lectionn√©.");
          return;
        }

        const type = document.getElementById("symmetryTypeSelect").value;
        let refObject = null;

        // Gestion des types n√©cessitant une r√©f√©rence
        if (["point", "line", "plane"].includes(type)) {
          const refId = document.getElementById("symmetryRefSelect").value;
          if (!refId) return;
          if (type === "point") refObject = geometryManager.points[parseInt(refId)];
          else if (type === "line") refObject = geometryManager.findLineById(parseInt(refId));
          else if (type === "plane") refObject = geometryManager.findPlaneById(parseInt(refId));
        }

        // --- FONCTION DE TRANSFORMATION UNIFI√âE ---
        // Cette fonction prend un Vector3 (position) et renvoie le nouveau Vector3 transform√©
        const transformVector = (v) => {
          const p = v.clone();

          switch (type) {
            // --- CAS STANDARD (Fixes) ---
            case "origin":
              return p.negate(); // (-x, -y, -z)

            case "axis_x": // Sym√©trie axe X : on garde X, on inverse le reste
              return new THREE.Vector3(p.x, -p.y, -p.z);

            case "axis_y": // UI Axe Y (Profondeur) -> ThreeJS Axe Z. On garde Z, on inverse X et Y(hauteur)
              return new THREE.Vector3(-p.x, -p.y, p.z);

            case "axis_z": // UI Axe Z (Hauteur) -> ThreeJS Axe Y. On garde Y, on inverse X et Z
              return new THREE.Vector3(-p.x, p.y, -p.z);

            case "plane_xy": // UI Plan XY (Sol) -> On inverse la Hauteur (ThreeJS Y)
              return new THREE.Vector3(p.x, -p.y, p.z);

            case "plane_xz": // UI Plan XZ (Face) -> On inverse la Profondeur (ThreeJS Z)
              return new THREE.Vector3(p.x, p.y, -p.z);

            case "plane_yz": // UI Plan YZ (C√¥t√©) -> On inverse X
              return new THREE.Vector3(-p.x, p.y, p.z);

            // --- CAS AVANC√âS (Objets de r√©f√©rence) ---
            case "point":
              // p' = center - (p - center) = 2*center - p
              return refObject.position.clone().multiplyScalar(2).sub(p);

            case "line":
              const lineStart = refObject.startPoint;
              const lineDir = refObject.directorVector.clone().normalize();
              const vStartToP = new THREE.Vector3().subVectors(p, lineStart);
              const projection = lineDir.multiplyScalar(vStartToP.dot(lineDir));
              const projectedPoint = new THREE.Vector3().addVectors(lineStart, projection);
              // p' = proj - (p - proj) = 2*proj - p
              return projectedPoint.multiplyScalar(2).sub(p);

            case "plane":
              const vP0P = new THREE.Vector3().subVectors(p, refObject.pointOnPlane);
              const dist = vP0P.dot(refObject.normal); // Distance sign√©e
              // p' = p - 2 * dist * normal
              return p.clone().addScaledVector(refObject.normal, -2 * dist);

            default:
              return p;
          }
        };

        // --- APPLICATION DE LA TRANSFORMATION √Ä L'OBJET S√âLECTIONN√â ---
        const inst = selectedObjectInstance;

        if (inst instanceof Point) {
          const newPos = transformVector(inst.position);
          inst.update(inst.name, newPos.x, newPos.y, newPos.z); // Note: update g√®re l'inversion Y/Z interne si on passe des coords brutes, ici on passe x,y,z du vecteur ThreeJS, donc attention.
          // CORRECTION POUR POINT : update() prend (x, y_ui, z_ui).
          // Si on a un vecteur ThreeJS (x, y_3js, z_3js), y_ui = z_3js et z_ui = y_3js.
          // MAIS votre classe Point stocke directement new THREE.Vector3(x, y, z).
          // La m√©thode update() fait : this.position.set(x, y, z).
          // Donc on peut simplement faire :
          inst.position.copy(newPos);
          inst.mesh.position.copy(inst.position);
          inst.updateLabelPosition();
        } else if (inst instanceof Vector) {
          const newOrigin = transformVector(inst.origin);
          const endPoint = new THREE.Vector3().addVectors(inst.origin, inst.components);
          const newEndPoint = transformVector(endPoint);
          const newComponents = new THREE.Vector3().subVectors(newEndPoint, newOrigin);

          inst.update(inst.name, newOrigin, newComponents);
        } else if (inst instanceof Line3D) {
          const newStart = transformVector(inst.startPoint);
          // Pour le vecteur directeur, on transforme le point "start + dir" et on soustrait le nouveau start
          const endPoint = new THREE.Vector3().addVectors(inst.startPoint, inst.directorVector);
          const newEnd = transformVector(endPoint);
          const newDir = new THREE.Vector3().subVectors(newEnd, newStart);

          // Mise √† jour manuelle (similaire √† translation/rotation)
          inst.startPoint.copy(newStart);
          inst.directorVector.copy(newDir);

          const lineLength = 100;
          const dir = inst.directorVector.clone().normalize();
          const start = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(-lineLength));
          const end = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(lineLength));

          inst.mesh.geometry.dispose();
          inst.mesh.geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
          if (inst === selectedObjectInstance) inst.mesh.material.color.set(HIGHLIGHT_COLOR);
        } else if (inst instanceof Plane) {
          // Transformation du point d'ancrage
          const newPointOnPlane = transformVector(inst.pointOnPlane);

          // Transformation de la normale : on transforme (point + normal) et on soustrait le nouveau point
          const pointPlusNormal = new THREE.Vector3().addVectors(inst.pointOnPlane, inst.normal);
          const newPointPlusNormal = transformVector(pointPlusNormal);
          const newNormal = new THREE.Vector3().subVectors(newPointPlusNormal, newPointOnPlane).normalize();

          inst.pointOnPlane.copy(newPointOnPlane);
          inst.normal.copy(newNormal);
          inst.displayNormal.copy(newNormal);

          inst.mesh.position.copy(inst.pointOnPlane);
          inst.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), inst.normal);
        }

        updateAllUI();
        saveState();
      }

      function saveScene() {
        const sceneName = document.getElementById("sceneNameInput").value.trim();
        if (!sceneName) {
          showSplashScreen("Veuillez donner un nom √† votre sc√®ne.");
          return;
        }
        // 1. S√©rialiser la g√©om√©trie actuelle
        const sceneData = {
          name: sceneName,
          timestamp: new Date().toISOString(),
          geometry: {
            points: geometryManager.points.map((p) => ({
              name: p.name,
              position: { x: p.position.x, y: p.position.y, z: p.position.z },
            })),
            vectors: geometryManager.vectors.map((v) => ({
              id: v.id,
              name: v.name,
              origin: { x: v.origin.x, y: v.origin.y, z: v.origin.z },
              components: { x: v.components.x, y: v.components.y, z: v.components.z },
              isLabelVisible: v.isLabelVisible,
            })),
            lines: geometryManager.lines.map((l) => ({
              id: l.id,
              name: l.name,
              startPoint: { x: l.startPoint.x, y: l.startPoint.y, z: l.startPoint.z },
              directorVector: { x: l.directorVector.x, y: l.directorVector.y, z: l.directorVector.z },
            })),
            planes: geometryManager.planes.map((p) => ({
              id: p.id,
              name: p.name,
              pointOnPlane: { x: p.pointOnPlane.x, y: p.pointOnPlane.y, z: p.pointOnPlane.z },
              displayNormal: { x: p.displayNormal.x, y: p.displayNormal.y, z: p.displayNormal.z },
            })),
          },
        };

        // 2. G√©rer le stockage
        let savedScenes = JSON.parse(localStorage.getItem("savedScenes")) || [];

        // V√©rifier si une sc√®ne avec le m√™me nom existe d√©j√†
        const existingSceneIndex = savedScenes.findIndex((s) => s.name === sceneName);
        if (existingSceneIndex > -1) {
          if (confirm(`Une sc√®ne nomm√©e "${sceneName}" existe d√©j√†. Voulez-vous la remplacer ?`)) {
            savedScenes[existingSceneIndex] = sceneData;
          } else {
            return; // L'utilisateur a annul√©
          }
        } else {
          savedScenes.push(sceneData);
        }

        // 3. Sauvegarder dans localStorage
        localStorage.setItem("savedScenes", JSON.stringify(savedScenes));
        showSplashScreen(`‚úÖ Sc√®ne "${sceneName}" enregistr√©e !`);

        // 4. Mettre √† jour la liste des sc√®nes chargeables
        populateSavedScenesSelect();
      }

      function loadScene() {
        const sceneName = document.getElementById("savedScenesSelect").value;
        if (!sceneName) {
          showSplashScreen("Veuillez s√©lectionner une sc√®ne √† charger.");
          return;
        }

        const savedScenes = JSON.parse(localStorage.getItem("savedScenes")) || [];
        const sceneData = savedScenes.find((s) => s.name === sceneName);

        if (!sceneData) {
          showSplashScreen("Erreur : Impossible de trouver les donn√©es de la sc√®ne.");
          return;
        }

        // 1. Nettoyer la sc√®ne actuelle
        geometryManager.clearAll();

        // 2. D√©s√©rialiser et reconstruire la g√©om√©trie
        sceneData.geometry.points.forEach((p) => {
          geometryManager.addPoint(new Point(p.name, p.position.x, p.position.y, p.position.z));
        });

        sceneData.geometry.vectors.forEach((v) => {
          const origin = new THREE.Vector3(v.origin.x, v.origin.y, v.origin.z);
          const components = new THREE.Vector3(v.components.x, v.components.y, v.components.z);
          // On doit recr√©er le vecteur avec son ID pour garder la coh√©rence
          const newVector = new Vector(v.name, origin, components);
          newVector.id = v.id;
          nextVectorId = Math.max(nextVectorId, v.id + 1); // Important pour ne pas avoir de conflits d'ID
          if (v.isLabelVisible === false) {
            newVector.setLabelVisibility(false);
          }

          geometryManager.addVector(newVector);
        });

        sceneData.geometry.lines.forEach((l) => {
          const startPoint = new THREE.Vector3(l.startPoint.x, l.startPoint.y, l.startPoint.z);
          const directorVector = new THREE.Vector3(l.directorVector.x, l.directorVector.y, l.directorVector.z);
          const newLine = new Line3D(l.name, startPoint, directorVector);
          newLine.id = l.id;
          nextStraightLineId = Math.max(nextStraightLineId, l.id + 1);
          geometryManager.addLine(newLine);
        });

        sceneData.geometry.planes.forEach((p) => {
          const pointOnPlane = new THREE.Vector3(p.pointOnPlane.x, p.pointOnPlane.y, p.pointOnPlane.z);
          const normal = new THREE.Vector3(p.displayNormal.x, p.displayNormal.y, p.displayNormal.z);
          const newPlane = new Plane(p.name, pointOnPlane, normal);
          newPlane.id = p.id;
          nextPlaneId = Math.max(nextPlaneId, p.id + 1);
          geometryManager.addPlane(newPlane);
        });
        showSplashScreen(`‚úÖ Sc√®ne "${sceneName}" charg√©e !`);
        // 3. Mettre √† jour l'ensemble de l'interface
        updateAllUI();
      }

      function deleteScene() {
        const sceneName = document.getElementById("savedScenesSelect").value;
        if (!sceneName) {
          showSplashScreen("Veuillez s√©lectionner une sc√®ne √† supprimer.");
          return;
        }

        if (confirm(`√ätes-vous s√ªr de vouloir supprimer la sc√®ne "${sceneName}" ? Cette action est irr√©versible.`)) {
          let savedScenes = JSON.parse(localStorage.getItem("savedScenes")) || [];
          const updatedScenes = savedScenes.filter((s) => s.name !== sceneName);
          localStorage.setItem("savedScenes", JSON.stringify(updatedScenes));
          populateSavedScenesSelect();
          showSplashScreen(`‚úÖ Sc√®ne "${sceneName}"supprim√©e !`);
        }
      }

      function populateSavedScenesSelect() {
        const select = document.getElementById("savedScenesSelect");
        select.innerHTML = ""; // Vider les anciennes options

        const savedScenes = JSON.parse(localStorage.getItem("savedScenes")) || [];

        if (savedScenes.length === 0) {
          select.add(new Option("Aucune sc√®ne enregistr√©e", ""));
        } else {
          savedScenes.forEach((scene) => {
            select.add(new Option(scene.name, scene.name));
          });
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        populateSavedScenesSelect(); // Ajoutez cette ligne !
      });

      function showSplashScreen(message, duration = 2000) {
        const splashElement = document.getElementById("splashScreen");
        const messageElement = document.getElementById("splashMessage");

        // Annule un timer pr√©c√©dent si une notification √©tait d√©j√† en cours de disparition
        if (splashTimer) {
          clearTimeout(splashTimer);
        }

        // 1. Mettre √† jour le message et afficher l'√©l√©ment
        messageElement.textContent = message;
        splashElement.classList.remove("splash-hidden");

        // 2. Programmer la disparition de l'√©l√©ment apr√®s la dur√©e sp√©cifi√©e
        splashTimer = setTimeout(() => {
          splashElement.classList.add("splash-hidden");
          splashTimer = null; // R√©initialiser le timer
        }, duration);
      }

      function hideContextMenu() {
        console.log("hideContextMenu");
        const menu = document.getElementById("contextMenu");
        if (menu) {
          menu.style.display = "none";
        }
      }
      // --- GESTIONNAIRE D'HISTORIQUE ---
      const historyStack = []; // Stocke les √©tats (snapshots)
      let historyIndex = -1; // Position actuelle dans l'historique
      const MAX_HISTORY = 20; // Limite pour ne pas saturer la m√©moire
      // --- Fonction saveState corrig√©e (anti-doublons) ---

      function saveState() {
        // 1. Si on est au milieu de l'historique (apr√®s des Undos), on coupe le futur
        if (historyIndex < historyStack.length - 1) {
          historyStack.splice(historyIndex + 1);
        }

        // 2. Cr√©ation de la "photo" de la sc√®ne actuelle
        const currentState = serializeSceneData();

        // ============================================================
        // 3. CORRECTION : V√âRIFICATION ANTI-DOUBLON
        // ============================================================
        // On v√©rifie si l'√©tat qu'on veut sauvegarder est identique au dernier √©tat connu.
        // Cela emp√™che d'avoir [A, B, B] dans l'historique.
        if (historyIndex >= 0 && historyStack[historyIndex] === currentState) {
          // Si c'est exactement pareil, on ne sauvegarde pas une 2√®me fois.
          // console.log("√âtat identique ignor√©");
          return;
        }

        // 4. Ajout √† la pile si c'est un nouvel √©tat
        historyStack.push(currentState);
        historyIndex++;

        // 5. Limite de m√©moire (on garde les 20 derniers √©tats)
        if (historyStack.length > MAX_HISTORY) {
          historyStack.shift(); // On supprime le plus vieux
          historyIndex--;
        }

        updateHistoryButtons();
      }

      function undo() {
        if (historyIndex > 0) {
          historyIndex--;
          const previousState = historyStack[historyIndex];
          restoreSceneData(previousState);
          showSplashScreen("Action annul√©e ‚Ü©Ô∏è");
        } else {
          showSplashScreen("Rien √† annuler.");
        }
        updateHistoryButtons();
      }

      // Optionnel : Redo
      function redo() {
        if (historyIndex < historyStack.length - 1) {
          historyIndex++;
          const nextState = historyStack[historyIndex];
          restoreSceneData(nextState);
          showSplashScreen("Action r√©tablie ‚Ü™Ô∏è");
        }
        updateHistoryButtons();
      }

      function serializeSceneData() {
        return JSON.stringify({
          points: geometryManager.points.map((p) => ({
            name: p.name,
            position: { x: p.position.x, y: p.position.y, z: p.position.z },
          })),
          vectors: geometryManager.vectors.map((v) => ({
            id: v.id,
            name: v.name,
            origin: { x: v.origin.x, y: v.origin.y, z: v.origin.z },
            components: { x: v.components.x, y: v.components.y, z: v.components.z },
            isLabelVisible: v.isLabelVisible,
            isVisible: v.isVisible,
            // Sauvegarde des props sp√©cifiques (normale de plan, etc)
            isNormalVector: v.isNormalVector || false,
            parentPlaneId: v.parentPlaneId || null,
          })),
          lines: geometryManager.lines.map((l) => ({
            id: l.id,
            name: l.name,
            startPoint: { x: l.startPoint.x, y: l.startPoint.y, z: l.startPoint.z },
            directorVector: { x: l.directorVector.x, y: l.directorVector.y, z: l.directorVector.z },
            isVisible: l.isVisible,
          })),
          planes: geometryManager.planes.map((p) => ({
            id: p.id,
            name: p.name,
            pointOnPlane: { x: p.pointOnPlane.x, y: p.pointOnPlane.y, z: p.pointOnPlane.z },
            displayNormal: { x: p.displayNormal.x, y: p.displayNormal.y, z: p.displayNormal.z },
            isVisible: p.isVisible,
          })),
        });
      }

      function restoreSceneData(jsonString) {
        deselectCurrentObject();
        const data = JSON.parse(jsonString);

        // 1. Nettoyage complet
        geometryManager.clearAll();

        // 2. Reconstruction
        data.points.forEach((p) =>
          geometryManager.addPoint(new Point(p.name, p.position.x, p.position.y, p.position.z))
        );

        data.vectors.forEach((v) => {
          const vec = new Vector(
            v.name,
            new THREE.Vector3(v.origin.x, v.origin.y, v.origin.z),
            new THREE.Vector3(v.components.x, v.components.y, v.components.z)
          );
          vec.id = v.id;
          vec.isVisible = v.isVisible !== undefined ? v.isVisible : true;
          vec.isLabelVisible = v.isLabelVisible !== undefined ? v.isLabelVisible : true;
          vec.isNormalVector = v.isNormalVector;
          vec.parentPlaneId = v.parentPlaneId;
          nextVectorId = Math.max(nextVectorId, v.id + 1);
          geometryManager.addVector(vec);
        });

        data.lines.forEach((l) => {
          const line = new Line3D(
            l.name,
            new THREE.Vector3(l.startPoint.x, l.startPoint.y, l.startPoint.z),
            new THREE.Vector3(l.directorVector.x, l.directorVector.y, l.directorVector.z)
          );
          line.id = l.id;
          line.isVisible = l.isVisible !== undefined ? l.isVisible : true;
          nextStraightLineId = Math.max(nextStraightLineId, l.id + 1);
          geometryManager.addLine(line);
        });

        data.planes.forEach((p) => {
          const plane = new Plane(
            p.name,
            new THREE.Vector3(p.pointOnPlane.x, p.pointOnPlane.y, p.pointOnPlane.z),
            new THREE.Vector3(p.displayNormal.x, p.displayNormal.y, p.displayNormal.z)
          );
          plane.id = p.id;
          plane.isVisible = p.isVisible !== undefined ? p.isVisible : true;
          nextPlaneId = Math.max(nextPlaneId, p.id + 1);
          geometryManager.addPlane(plane);
        });

        updateAllUI();
      }

      function updateHistoryButtons() {
        const btnUndo = document.getElementById("btnUndo");
        const btnRedo = document.getElementById("btnRedo");

        // 1. Gestion du bouton UNDO (Annuler)
        if (btnUndo) {
          if (historyIndex > 0) {
            btnUndo.style.opacity = "1";
            btnUndo.style.pointerEvents = "auto";
            btnUndo.style.cursor = "pointer";
          } else {
            btnUndo.style.opacity = "0.5";
            btnUndo.style.pointerEvents = "none";
            btnUndo.style.cursor = "default";
          }
        }

        // 2. Gestion du bouton REDO (R√©tablir)
        if (btnRedo) {
          // On peut r√©tablir s'il y a des √©tats apr√®s l'index actuel dans la pile
          if (historyIndex < historyStack.length - 1) {
            btnRedo.style.opacity = "1";
            btnRedo.style.pointerEvents = "auto";
            btnRedo.style.cursor = "pointer";
          } else {
            btnRedo.style.opacity = "0.5";
            btnRedo.style.pointerEvents = "none";
            btnRedo.style.cursor = "default";
          }
        }
      }
      function handleHover(clientX, clientY) {
        const tooltip = document.getElementById("tooltip");

        // ============================================================
        // 1. PROTECTION UI : On v√©rifie ce qu'il y a sous la souris
        // ============================================================
        const elementUnderMouse = document.elementFromPoint(clientX, clientY);

        // Si on survole le panneau, le bouton burger ou les contr√¥les cam√©ra...
        if (
          elementUnderMouse &&
          (elementUnderMouse.closest("#panel") ||
            elementUnderMouse.closest("#openBtn") ||
            elementUnderMouse.closest("#cameraControls"))
        ) {
          // ... On cache l'info-bulle et on arr√™te tout.
          tooltip.style.display = "none";
          document.body.style.cursor = "default";
          return;
        }

        // ============================================================
        // 2. PROTECTION MOUVEMENT CAM√âRA
        // ============================================================
        // Si on bouge la cam√©ra, on cache tout pour ne pas g√™ner la vue
        if (isDragging || isPanning) {
          tooltip.style.display = "none";
          document.body.style.cursor = "default";
          return;
        }

        // ============================================================
        // 3. LOGIQUE D'AFFICHAGE NORMALE
        // ============================================================
        const intersection = getIntersectionResult(clientX, clientY);

        if (intersection && intersection.object.userData.instance) {
          const instance = intersection.object.userData.instance;
          let content = "";

          // Style CSS inline pour les d√©tails
          const detailStyle = 'style="color: #ddd; font-size: 0.9em; display: block; margin-top: 2px;"';

          // --- 1. POINT ---
          if (instance instanceof Point) {
            const x = formatNumber(instance.position.x);
            const y_ui = formatNumber(instance.position.z);
            const z_ui = formatNumber(instance.position.y);
            content = `üìç <strong>${instance.name}</strong><span ${detailStyle}>Coord : (${x}, ${y_ui}, ${z_ui})</span>`;

            // --- 2. VECTEUR ---
          } else if (instance instanceof Vector) {
            const v = instance.components;
            const x = formatNumber(v.x);
            const y_ui = formatNumber(v.z);
            const z_ui = formatNumber(v.y);
            const norm = formatNumber(v.length());
            content = `‚ÜóÔ∏è <strong>${instance.name}</strong><span ${detailStyle}>Coord : (${x}, ${y_ui}, ${z_ui})</span><span ${detailStyle}>Norme : ${norm}</span>`;

            // --- 3. DROITE ---
          } else if (instance instanceof Line3D) {
            const u = instance.directorVector;
            const x = formatNumber(u.x);
            const y_ui = formatNumber(u.z);
            const z_ui = formatNumber(u.y);
            content = `üìè <strong>${instance.name}</strong><span ${detailStyle}>Vect. dir. : (${x}, ${y_ui}, ${z_ui})</span>`;

            // --- 4. PLAN ---
          } else if (instance instanceof Plane) {
            const n = instance.displayNormal;
            const x = formatNumber(n.x);
            const y_ui = formatNumber(n.z);
            const z_ui = formatNumber(n.y);
            content = `üî∑ <strong>${instance.name}</strong><span ${detailStyle}>Normale : (${x}, ${y_ui}, ${z_ui})</span>`;

            // --- AUTRES ---
          } else {
            content = instance.name;
          }

          tooltip.innerHTML = content;

          // Positionnement
          positionTooltipSmartly(clientX, clientY);

          document.body.style.cursor = "pointer";
        } else {
          tooltip.style.display = "none";
          document.body.style.cursor = "default";
        }
      }
      function syncDataFromGizmo() {
        const inst = selectedObjectInstance;
        if (!inst) return;

        // 1. POINT (Inchang√©)
        if (inst instanceof Point) {
          inst.position.copy(inst.mesh.position);
          inst.updateLabelPosition();
          const editIndexInput = document.getElementById("editPointIndex");
          if (
            editIndexInput &&
            editIndexInput.value != "" &&
            parseInt(editIndexInput.value) === geometryManager.points.indexOf(inst)
          ) {
            document.getElementById("pointX").value = formatNumber(inst.position.x);
            document.getElementById("pointY").value = formatNumber(inst.position.z);
            document.getElementById("pointZ").value = formatNumber(inst.position.y);
          }

          // AJOUT POUR LE TABLEUR (Mise √† jour temps r√©el des inputs)
          if (isSpreadsheetOpen && currentSpreadsheetTab === "points") {
            const idx = geometryManager.points.indexOf(inst);
            const inputX = document.getElementById(`sheet-p-${idx}-x`);
            const inputY = document.getElementById(`sheet-p-${idx}-y`);
            const inputZ = document.getElementById(`sheet-p-${idx}-z`);
            if (inputX) {
              inputX.value = formatNumber(inst.position.x);
              inputY.value = formatNumber(inst.position.z); // UI Y
              inputZ.value = formatNumber(inst.position.y); // UI Z
            }
          }
        }

        // 2. VECTEUR (Inchang√©)
        else if (inst instanceof Vector) {
          const currentOrigin = inst.origin.clone().add(inst.arrowHelper.position);
          inst.updateLabelPosition();

          const originListSpan = document.getElementById(`vector-origin-list-${inst.id}`);
          if (originListSpan) {
            const ox = formatNumber(currentOrigin.x, 1);
            const oy = formatNumber(currentOrigin.z, 1);
            const oz = formatNumber(currentOrigin.y, 1);
            originListSpan.innerHTML = `Origine: <strong>(${ox}, ${oy}, ${oz})</strong>`;
          }

          if (document.getElementById("editVectorId").value == inst.id) {
            document.getElementById("vectorOriginX").value = formatNumber(currentOrigin.x);
            document.getElementById("vectorOriginY").value = formatNumber(currentOrigin.z);
            document.getElementById("vectorOriginZ").value = formatNumber(currentOrigin.y);
            // On force le select sur vide/custom pour que les inputs soient pris en compte
            const vSelect = document.getElementById("vectorOriginPoint");
            if (vSelect) vSelect.value = "";
          }

          // ... code existant ...
          if (isSpreadsheetOpen && currentSpreadsheetTab === "vectors") {
            const o = inst.origin.clone().add(inst.arrowHelper.position);
            const oxInput = document.getElementById(`sheet-v-${inst.id}-ox`);
            if (oxInput) {
              oxInput.value = formatNumber(o.x);
              document.getElementById(`sheet-v-${inst.id}-oy`).value = formatNumber(o.z);
              document.getElementById(`sheet-v-${inst.id}-oz`).value = formatNumber(o.y);
            }
          }
        }

        // 3. DROITE (CORRIG√â)
        else if (inst instanceof Line3D) {
          // Calcul de la position actuelle
          const currentP = inst.startPoint.clone().add(inst.mesh.position);

          // A. Mise √† jour de la liste
          const pointSpan = document.getElementById(`line-point-${inst.id}`);
          if (pointSpan) {
            const px = formatNumber(currentP.x, 1);
            const py = formatNumber(currentP.z, 1);
            const pz = formatNumber(currentP.y, 1);
            pointSpan.innerHTML = `Passe par : <strong>(${px}, ${py}, ${pz})</strong>`;
          }

          // B. Mise √† jour de l'affichage √©quation
          const eqSelect = document.getElementById("equationLineSelect");
          if (eqSelect && parseInt(eqSelect.value) === inst.id) {
            const tempLine = {
              startPoint: currentP,
              directorVector: inst.directorVector,
            };
            displayLineEquation(tempLine);
          }

          // C. --- CORRECTION CRITIQUE : MISE √Ä JOUR DU FORMULAIRE D'√âDITION ---
          // Si on est en train d'√©diter CETTE droite pr√©cise
          if (document.getElementById("editLineId").value == inst.id) {
            document.getElementById("lineEqPointX").value = formatNumber(currentP.x);
            document.getElementById("lineEqPointY").value = formatNumber(currentP.z); // Profondeur (UI Y = 3D Z)
            document.getElementById("lineEqPointZ").value = formatNumber(currentP.y); // Hauteur (UI Z = 3D Y)

            // IMPORTANT : On remet le selecteur sur "vide" pour forcer l'usage des coordonn√©es manuelles
            // sinon la fonction updateLine() pourrait reprendre le point nomm√© pr√©c√©dent.
            document.getElementById("lineEquationPointSelect").value = "";
          }
        }

        // 4. PLAN (CORRIG√â)
        else if (inst instanceof Plane) {
          inst.pointOnPlane.copy(inst.mesh.position);

          if (transformControl.mode === "rotate") {
            const rotationMatrix = new THREE.Matrix4().extractRotation(inst.mesh.matrix);
            const initialNormal = new THREE.Vector3(0, 0, 1);
            inst.normal.copy(initialNormal).applyMatrix4(rotationMatrix).normalize();
            inst.displayNormal.copy(inst.normal);
            // Note : Pour la rotation, mettre √† jour l'√©quation texte (ax+by...) est complexe
            // et pourrait √©craser le formatage utilisateur, on se concentre sur la position ici.
          }

          // A. Mise √† jour liste
          const pointSpan = document.getElementById(`plane-point-${inst.id}`);
          if (pointSpan) {
            const px = formatNumber(inst.pointOnPlane.x, 1);
            const py_ui = formatNumber(inst.pointOnPlane.z, 1);
            const pz_ui = formatNumber(inst.pointOnPlane.y, 1);
            pointSpan.innerHTML = `Passe par : <strong>(${px}, ${py_ui}, ${pz_ui})</strong>`;
          }

          // B. Equation display
          const planeSelect = document.getElementById("equationPlaneSelect");
          if (planeSelect && parseInt(planeSelect.value) === inst.id) {
            displayPlaneEquation();
          }

          // C. --- CORRECTION CRITIQUE : MISE √Ä JOUR DU FORMULAIRE D'√âDITION ---
          if (document.getElementById("editPlaneId").value == inst.id) {
            document.getElementById("planeEqPointX").value = formatNumber(inst.pointOnPlane.x);
            document.getElementById("planeEqPointY").value = formatNumber(inst.pointOnPlane.z); // Profondeur
            document.getElementById("planeEqPointZ").value = formatNumber(inst.pointOnPlane.y); // Hauteur

            // Force l'usage des coordonn√©es manuelles
            document.getElementById("planeEquationPointSelect").value = "";
          }
        }
      }

      function updateTooltipFromGizmo() {
        const tooltip = document.getElementById("tooltip");
        const inst = selectedObjectInstance;

        if (!inst || (lastTooltipX === 0 && lastTooltipY === 0)) {
          tooltip.style.display = "none";
          return;
        }

        let content = "";
        const detailStyle = 'style="color: #ddd; font-size: 0.9em; display: block; margin-top: 2px;"';

        try {
          if (inst instanceof Point) {
            const x = formatNumber(inst.position.x);
            const y_ui = formatNumber(inst.position.z);
            const z_ui = formatNumber(inst.position.y);
            content = `üìç <strong>${inst.name}</strong><span ${detailStyle}>Coord : (${x}, ${y_ui}, ${z_ui})</span>`;
          } else if (inst instanceof Vector) {
            // Pour le vecteur, on calcule la position visuelle absolue
            const o = inst.origin.clone().add(inst.arrowHelper.position);
            const v = inst.components;

            const ox = formatNumber(o.x);
            const oy_ui = formatNumber(o.z);
            const oz_ui = formatNumber(o.y);
            const norm = formatNumber(v.length());

            content = `‚ÜóÔ∏è <strong>${inst.name}</strong>
           <span ${detailStyle}>Origine : (${ox}, ${oy_ui}, ${oz_ui})</span>
           <span ${detailStyle}>Norme : ${norm}</span>`;
          }
          // --- MODIFICATION POUR LA DROITE ---
          else if (inst instanceof Line3D) {
            // Position r√©elle = Point de d√©part initial + D√©placement du Gizmo
            const currentP = inst.startPoint.clone().add(inst.mesh.position);

            const px = formatNumber(currentP.x);
            const py_ui = formatNumber(currentP.z);
            const pz_ui = formatNumber(currentP.y);

            const u = inst.directorVector;
            const ux = formatNumber(u.x, 1);
            const uz_ui = formatNumber(u.z, 1);
            const uy_ui = formatNumber(u.y, 1);

            content = `üìè <strong>${inst.name}</strong>
                 <span ${detailStyle}>Passe par : (${px}, ${py_ui}, ${pz_ui})</span>
                 <span ${detailStyle}>Vect. dir. : (${ux}, ${uz_ui}, ${uy_ui})</span>`;
          }
          // -----------------------------------
          else if (inst instanceof Plane) {
            const currentP = inst.pointOnPlane.clone().add(inst.mesh.position);

            // Calcul de la normale (avec rotation si n√©cessaire)
            let n = inst.normal;
            if (transformControl.mode === "rotate") {
              const rotationMatrix = new THREE.Matrix4().extractRotation(inst.mesh.matrix);
              n = inst.normal.clone().applyMatrix4(rotationMatrix);
            }

            // Formatage pour l'affichage
            const nx = formatNumber(n.x, 1);
            const ny_ui = formatNumber(n.z, 1);
            const nz_ui = formatNumber(n.y, 1);

            // NOUVEAU : Formatage du point de passage
            // Note : inst.mesh.position est d√©j√† absolu pour les plans dans notre logique actuelle
            const px = formatNumber(inst.pointOnPlane.x);
            const py_ui = formatNumber(inst.pointOnPlane.z);
            const pz_ui = formatNumber(inst.pointOnPlane.y);

            content = `üî∑ <strong>${inst.name}</strong>
       <span ${detailStyle}>Passe par : (${px}, ${py_ui}, ${pz_ui})</span>
       <span ${detailStyle}>Normale : (${nx}, ${ny_ui}, ${nz_ui})</span>`;
          }

          tooltip.innerHTML = content;
          positionTooltipSmartly(lastTooltipX, lastTooltipY);
        } catch (err) {
          tooltip.style.display = "none";
        }
      }

      function finalizeGizmoMovement() {
        const inst = selectedObjectInstance;
        if (!inst) return;

        // --- CAS 1 : C'EST UN VECTEUR (Correction du bug de disparition) ---
        if (inst instanceof Vector) {
          // 1. IMPORTANT : On l√¢che l'objet AVANT de le modifier.
          // Sinon, Three.js essaie de mettre √† jour un objet qui va √™tre d√©truit.
          transformControl.detach();

          // 2. On capture la nouvelle position absolue
          // Le Gizmo a d√©plac√© l'ArrowHelper. Sa position est devenue la nouvelle origine.
          const newOrigin = inst.arrowHelper.position.clone();

          // 3. On utilise la m√©thode update() de la classe Vector
          // Elle s'occupe proprement de : supprimer l'ancien, cr√©er le nouveau, l'ajouter √† la sc√®ne.
          inst.update(inst.name, newOrigin, inst.components);

          // 4. On r√©attache le Gizmo sur le NOUVEAU vecteur
          // L'ancien inst.arrowHelper n'existe plus, update() en a cr√©√© un nouveau.
          transformControl.attach(inst.arrowHelper);

          // 5. On remet la couleur de s√©lection (Jaune)
          // Car update() a remis la couleur d'origine (orange/bleu/etc).
          if (inst.arrowHelper) {
            inst.arrowHelper.setColor(0xffff00);
          }
        }

        // --- CAS 2 : C'EST UNE DROITE ---
        else if (inst instanceof Line3D) {
          // 1. Appliquer le d√©placement du mesh au point de d√©part math√©matique
          inst.startPoint.add(inst.mesh.position);

          // 2. Remettre le mesh √† z√©ro (pour √©viter que √ßa s'accumule)
          inst.mesh.position.set(0, 0, 0);

          // 3. R√©g√©n√©rer la g√©om√©trie visuelle √† partir du nouveau point de d√©part
          const lineLength = 100;
          const dir = inst.directorVector.clone().normalize();
          const visualStart = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(-lineLength));
          const visualEnd = new THREE.Vector3().addVectors(inst.startPoint, dir.clone().multiplyScalar(lineLength));

          inst.mesh.geometry.dispose();
          inst.mesh.geometry = new THREE.BufferGeometry().setFromPoints([visualStart, visualEnd]);

          // 4. Mise √† jour de l'√©quation (si affich√©e)
          const eqSelect = document.getElementById("equationLineSelect");
          if (eqSelect && parseInt(eqSelect.value) === inst.id) {
            displayLineEquation();
          }
        }

        // --- CAS 3 : C'EST UN POINT OU UN PLAN ---
        else if (inst instanceof Point) {
          // Pour un point, la position du mesh est la v√©rit√©. On met √† jour l'instance.
          inst.position.copy(inst.mesh.position);
          inst.updateLabelPosition();
        } else if (inst instanceof Plane) {
          // Pour un plan, on met √† jour le point d'ancrage
          inst.pointOnPlane.copy(inst.mesh.position);
        }

        // --- FINALISATION COMMUNE ---
        // Mettre √† jour les coordonn√©es dans le panneau HTML (listes)
        updateAllUI();
        // Sauvegarder dans l'historique (Undo/Redo)
        saveState();
      }

      function positionTooltipSmartly(x, y) {
        const tooltip = document.getElementById("tooltip");
        const offset = 15; // Marge par rapport au curseur

        // 1. On l'affiche d'abord pour pouvoir mesurer sa taille r√©elle
        tooltip.style.display = "block";
        const rect = tooltip.getBoundingClientRect();

        const winWidth = window.innerWidth;
        const winHeight = window.innerHeight;

        // 2. Gestion Horizontal (X)
        let finalX = x + offset;
        // Si le tooltip d√©passe le bord droit de l'√©cran...
        if (finalX + rect.width > winWidth) {
          // ... on le place √† gauche du curseur
          finalX = x - rect.width - offset;
        }
        // S√©curit√© : ne pas sortir √† gauche non plus (si l'√©cran est tr√®s petit)
        if (finalX < 0) finalX = offset;

        // 3. Gestion Vertical (Y)
        let finalY = y + offset;
        // Si le tooltip d√©passe le bord bas de l'√©cran...
        if (finalY + rect.height > winHeight) {
          // ... on le place au-dessus du curseur
          finalY = y - rect.height - offset;
        }
        // S√©curit√© : ne pas sortir en haut
        if (finalY < 0) finalY = offset;

        // 4. Application des coordonn√©es
        tooltip.style.left = finalX + "px";
        tooltip.style.top = finalY + "px";
      }

      function downloadDebugJSON() {
        // 1. Construction de l'objet de donn√©es
        const debugData = {
          meta: {
            appName: "√âditeur Points 3D",
            date: new Date().toLocaleString(),
            timestamp: Date.now(),
            totalObjects:
              geometryManager.points.length +
              geometryManager.vectors.length +
              geometryManager.lines.length +
              geometryManager.planes.length,
          },
          // Points : on exporte la position brute Three.js
          points: geometryManager.points.map((p, index) => ({
            index: index,
            name: p.name,
            position_raw: { x: p.position.x, y: p.position.y, z: p.position.z },
            // On ajoute la position "Vue UI" pour faciliter la lecture humaine
            position_ui: { x: p.position.x, profondeur: p.position.z, hauteur: p.position.y },
            color: "#" + p.color.getHexString(),
          })),
          vectors: geometryManager.vectors.map((v) => ({
            id: v.id,
            name: v.name,
            origin: { x: v.origin.x, y: v.origin.y, z: v.origin.z },
            components: { x: v.components.x, y: v.components.y, z: v.components.z },
            norm: v.components.length(),
            isVisible: v.isVisible,
            isNormalVector: v.isNormalVector || false,
          })),
          lines: geometryManager.lines.map((l) => ({
            id: l.id,
            name: l.name,
            startPoint: { x: l.startPoint.x, y: l.startPoint.y, z: l.startPoint.z },
            directorVector: { x: l.directorVector.x, y: l.directorVector.y, z: l.directorVector.z },
            isVisible: l.isVisible,
          })),
          planes: geometryManager.planes.map((p) => ({
            id: p.id,
            name: p.name,
            pointOnPlane: { x: p.pointOnPlane.x, y: p.pointOnPlane.y, z: p.pointOnPlane.z },
            normal: { x: p.normal.x, y: p.normal.y, z: p.normal.z },
            equationConstant_D: -p.normal.dot(p.pointOnPlane), // d = -n.p
            isVisible: p.isVisible,
          })),
        };

        // 2. Conversion en cha√Æne JSON format√©e (pretty print)
        const jsonStr = JSON.stringify(debugData, null, 2);

        // 3. Cr√©ation du lien de t√©l√©chargement invisible
        const blob = new Blob([jsonStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");

        // Nom du fichier avec timestamp
        const dateStr = new Date().toISOString().slice(0, 10);
        a.download = `debug_scene_3d_${dateStr}.json`;

        a.href = url;
        document.body.appendChild(a);
        a.click();

        // 4. Nettoyage
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showSplashScreen("üì• Donn√©es de d√©bogage t√©l√©charg√©es !");
      }
      // --- GESTION DU TH√àME ---
      let isDarkMode = false;
      let gridHelper = null; // R√©f√©rence globale pour pouvoir la supprimer/recr√©er
      let axesGroup = null; // R√©f√©rence globale pour les axes

      function initTheme() {
        // V√©rifier si une pr√©f√©rence est sauvegard√©e
        const savedTheme = localStorage.getItem("theme");
        if (savedTheme === "dark") {
          isDarkMode = true;
        }
        applyTheme();
      }

      function toggleTheme() {
        isDarkMode = !isDarkMode;
        localStorage.setItem("theme", isDarkMode ? "dark" : "light");
        applyTheme();
      }

      function applyTheme() {
        // 1. Mise √† jour HTML/CSS
        document.documentElement.setAttribute("data-theme", isDarkMode ? "dark" : "light");

        const btnIcon = document.querySelector("#themeToggleBtn i");
        if (btnIcon) {
          btnIcon.className = isDarkMode ? "fas fa-sun" : "fas fa-moon";
          btnIcon.style.color = isDarkMode ? "#ffeb3b" : "#333"; // Jaune pour soleil, Gris pour lune
        }

        // 2. Mise √† jour de la Sc√®ne 3D
        if (scene) {
          // A. Couleur de fond
          scene.background = new THREE.Color(isDarkMode ? 0x1a1a1a : 0xf0f0f0);

          // B. Mise √† jour de la Grille (GridHelper)
          if (gridHelper) scene.remove(gridHelper);

          // Couleurs : (couleur ligne centrale, couleur lignes grille)
          const colorCenter = isDarkMode ? 0x555555 : 0xcccccc;
          const colorGrid = isDarkMode ? 0x333333 : 0xe0e0e0;

          gridHelper = new THREE.GridHelper(20, 20, colorCenter, colorGrid);
          gridHelper.position.y = 0;
          gridHelper.renderOrder = -1;
          gridHelper.material.depthTest = false;
          scene.add(gridHelper);

          // C. Recr√©er les axes (pour changer la couleur du texte X, Y, Z)
          createAxes();

          // D. Recr√©er les labels de tous les points et vecteurs existants
          refreshAllLabels();
        }
      }

      function refreshAllLabels() {
        // Points
        geometryManager.points.forEach((p) => {
          scene.remove(p.label);
          p.label = createGenericTextLabel(p.name);
          p.updateLabelPosition();
          scene.add(p.label);
        });

        // Vecteurs
        geometryManager.vectors.forEach((v) => {
          if (v.label) scene.remove(v.label);
          v.label = createGenericTextLabel(v.name);
          v.updateLabelPosition();
          if (v.isVisible && v.isLabelVisible) scene.add(v.label);
        });
      }

      // =====================================================================================
      // SECTION : CALCULS G√âOM√âTRIQUES AVANC√âS
      // =====================================================================================

      /**
       * Calcule le segment le plus court entre deux droites (distance et points d'ancrage).
       * G√®re les droites non coplanaires et parall√®les.
       * @param {Line3D} line1
       * @param {Line3D} line2
       * @returns {Object} { distance: Number, p1: THREE.Vector3, p2: THREE.Vector3, type: "skew"|"parallel" }
       */
      function getShortestSegmentBetweenLines(line1, line2) {
        const P1 = line1.startPoint;
        const u = line1.directorVector.clone().normalize();
        const P2 = line2.startPoint;
        const v = line2.directorVector.clone().normalize();

        const w0 = new THREE.Vector3().subVectors(P1, P2);
        const a = u.dot(u); // Toujours 1 si normalis√©
        const b = u.dot(v);
        const c = v.dot(v); // Toujours 1 si normalis√©
        const d = u.dot(w0);
        const e = v.dot(w0);

        const det = a * c - b * b;
        let sc, tc;

        // Si le d√©terminant est proche de 0, les droites sont parall√®les
        if (Math.abs(det) < 1e-8) {
          // Droites parall√®les
          sc = 0;
          tc = b > c ? d / b : e / c; // On projette P1 sur la droite 2

          // Point sur la droite 1 (fixe)
          const p1_res = P1.clone();
          // Point projet√© sur la droite 2
          const p2_res = new THREE.Vector3().addVectors(P2, v.multiplyScalar(tc));

          return {
            distance: p1_res.distanceTo(p2_res),
            p1: p1_res,
            p2: p2_res,
            type: "parallel",
          };
        } else {
          // Droites non coplanaires (gauches)
          sc = (b * e - c * d) / det;
          tc = (a * e - b * d) / det;

          const p1_res = new THREE.Vector3().addVectors(P1, u.multiplyScalar(sc));
          const p2_res = new THREE.Vector3().addVectors(P2, v.multiplyScalar(tc));

          return {
            distance: p1_res.distanceTo(p2_res),
            p1: p1_res,
            p2: p2_res,
            type: "skew",
          };
        }
      }

      /**
       * Calcule l'angle entre un vecteur et un plan.
       * @param {Vector} vectorInstance Votre instance de classe Vector
       * @param {Plane} planeInstance Votre instance de classe Plane
       * @returns {Number} Angle en degr√©s
       */
      function getVectorPlaneAngle(vectorInstance, planeInstance) {
        // Math√©matiquement : arcsin( |u . n| / (||u|| * ||n||) )
        // Ou 90¬∞ - angle(vecteur, normale)

        const u = vectorInstance.components.clone().normalize();
        const n = planeInstance.normal.clone().normalize();

        // Produit scalaire
        const dot = u.dot(n);

        // On prend la valeur absolue car l'angle g√©om√©trique est entre la droite port√©e par le vecteur et le plan
        // Math.asin renvoie des radians
        const angleRad = Math.asin(Math.abs(dot));
        const angleDeg = THREE.MathUtils.radToDeg(angleRad);

        return angleDeg;
      }

      /**
       * Projette un point sur une droite.
       * @param {Point} pointInstance
       * @param {Line3D} lineInstance
       * @returns {Object} { projectedPoint: THREE.Vector3, distance: Number }
       */
      function projectPointOnLine(pointInstance, lineInstance) {
        const P = pointInstance.position;
        const A = lineInstance.startPoint;
        const u = lineInstance.directorVector.clone().normalize();

        // Vecteur AP
        const AP = new THREE.Vector3().subVectors(P, A);

        // Projection scalaire t = AP . u
        const t = AP.dot(u);

        // Point H = A + t*u
        const H = new THREE.Vector3().copy(A).add(u.multiplyScalar(t));

        return {
          projectedPoint: H,
          distance: P.distanceTo(H),
        };
      }

      /**
       * Calcule le barycentre de N points avec pond√©ration.
       * @param {Array<Point>} pointsArray Tableau d'instances de Point
       * @param {Array<Number>} weightsArray Tableau de poids (optionnel, d√©faut 1)
       * @returns {THREE.Vector3} Position du barycentre
       */
      function computeBarycenter(pointsArray, weightsArray = null) {
        if (!pointsArray || pointsArray.length === 0) return new THREE.Vector3(0, 0, 0);

        let sumX = 0,
          sumY = 0,
          sumZ = 0;
        let totalWeight = 0;

        for (let i = 0; i < pointsArray.length; i++) {
          const p = pointsArray[i].position;
          // Si pas de poids fourni, on utilise 1 (isobarycentre)
          const w = weightsArray && weightsArray[i] !== undefined ? parseFloat(weightsArray[i]) : 1;

          sumX += p.x * w;
          sumY += p.y * w;
          sumZ += p.z * w;
          totalWeight += w;
        }

        if (totalWeight === 0) {
          console.warn("Somme des poids nulle, calcul impossible.");
          return new THREE.Vector3(0, 0, 0);
        }

        return new THREE.Vector3(sumX / totalWeight, sumY / totalWeight, sumZ / totalWeight);
      }

      function calculateCommonPerpendicular() {
        const l1Id = parseInt(document.getElementById("perpLine1").value);
        const l2Id = parseInt(document.getElementById("perpLine2").value);
        const r = document.getElementById("perpResult");

        const line1 = geometryManager.findLineById(l1Id);
        const line2 = geometryManager.findLineById(l2Id);

        if (!line1 || !line2) {
          r.textContent = "S√©lectionnez deux droites.";
          return;
        }

        // Appel de la fonction math√©matique
        const result = getShortestSegmentBetweenLines(line1, line2);

        if (result.type === "parallel") {
          r.innerHTML = `Droites parall√®les.<br>Distance = <strong>${formatNumber(result.distance)}</strong>`;
        } else {
          // Cr√©ation visuelle du segment (Vecteur)
          const baseName = `Perp(${line1.name},${line2.name})`;
          const uniqueName = geometryManager.generateUniqueName(baseName, "vector");

          // Cr√©ation du vecteur repr√©sentant le segment le plus court
          const segmentVector = new THREE.Vector3().subVectors(result.p2, result.p1);
          const newVector = new Vector(uniqueName, result.p1, segmentVector, 0xff00ff); // Magenta
          geometryManager.addVector(newVector);

          // Cr√©ation des points d'intersection H1 et H2
          geometryManager.addPoint(new Point(uniqueName + "_H1", result.p1.x, result.p1.y, result.p1.z)); // Attention inversion Y/Z selon votre logique UI
          geometryManager.addPoint(new Point(uniqueName + "_H2", result.p2.x, result.p2.y, result.p2.z));

          r.innerHTML = `Distance min = <strong>${formatNumber(result.distance)}</strong><br>Segment trac√©.`;

          updateAllUI();
          saveState();
        }
      }
      function addLineFromPointVector() {
        // 1. R√©cup√©ration des valeurs
        const nameInput = document.getElementById("lineNamePV");
        const pSelect = document.getElementById("linePointPVSelect");
        const vSelect = document.getElementById("lineVectorPVSelect");

        const pId = pSelect.value;
        const vId = vSelect.value;

        // 2. Validation
        if (pId === "" || vId === "") {
          showSplashScreen("Veuillez s√©lectionner un Point ET un Vecteur.");
          return;
        }

        // 3. R√©cup√©ration des objets g√©om√©triques
        const pointObj = geometryManager.points[parseInt(pId)];
        const vectorObj = geometryManager.findVectorById(parseInt(vId));

        if (!pointObj || !vectorObj) return;

        // 4. Gestion du nom (automatique si vide)
        let lineName = nameInput.value.trim();
        if (!lineName) {
          lineName = `D(${pointObj.name}, u_${vectorObj.name})`;
        }

        // 5. Cr√©ation de la droite
        // On clone les vecteurs pour √©viter que modifier le point plus tard ne casse la droite
        const uniqueName = geometryManager.generateUniqueName(lineName, "line");
        const newLine = new Line3D(
          uniqueName,
          pointObj.position, // Point de passage
          vectorObj.components // Vecteur directeur
        );

        // 6. Ajout et Sauvegarde
        geometryManager.addLine(newLine);

        updateAllUI();
        saveState();

        // 7. Nettoyage des champs
        nameInput.value = "";
        pSelect.value = "";
        vSelect.value = "";

        showSplashScreen(`‚úÖ Droite "${uniqueName}" cr√©√©e !`);
      }

      function updateLine() {
        console.log("updateLine lanc√©e..."); // DEBUG

        // 1. R√©cup√©ration de l'objet
        const idVal = document.getElementById("editLineId").value;
        if (!idVal) {
          console.error("Pas d'ID");
          return;
        }

        const id = parseInt(idVal);
        const line = geometryManager.findLineById(id);
        if (!line) {
          console.error("Ligne introuvable");
          return;
        }

        const name = document.getElementById("lineNameFromEquation").value.trim();
        const equationsText = document.getElementById("lineEquationInput").value;

        // 2. Analyse de l'√©quation (Parsing)
        const lines = equationsText.split("\n").filter((l) => l.trim() !== "");

        // Valeurs par d√©faut
        let vector = { x: 0, y: 0, z: 0 }; // Composantes t
        let pointText = { x: 0, y: 0, z: 0 }; // Constantes

        lines.forEach((l) => {
          const axis = l.trim().charAt(0).toLowerCase();
          if (!["x", "y", "z"].includes(axis)) return;

          const content = l.substring(l.indexOf("=") + 1).replace(/\s/g, "");

          // Trouver t (ex: "-5t")
          const tMatch = content.match(/[+-]?[\d\.]*t/);
          if (tMatch) {
            let tStr = tMatch[0].replace("t", "");
            if (tStr === "" || tStr === "+") vector[axis] = 1;
            else if (tStr === "-") vector[axis] = -1;
            else vector[axis] = parseFloat(tStr);
          }

          // Trouver constante (ex: "2") - on enl√®ve la partie t pour lire le reste
          const constStr = tMatch ? content.replace(tMatch[0], "") : content;
          const val = parseFloat(constStr);
          if (!isNaN(val)) pointText[axis] = val;
        });

        // 3. R√©cup√©ration Point de Passage (Priorit√© aux inputs manuels)
        const px = document.getElementById("lineEqPointX").value;
        const py = document.getElementById("lineEqPointY").value;
        const pz = document.getElementById("lineEqPointZ").value;
        const selectVal = document.getElementById("lineEquationPointSelect").value;

        let newStart = new THREE.Vector3();

        // Logique de priorit√© : Inputs > Select > Texte Equation
        if (px !== "" || py !== "" || pz !== "") {
          newStart.set(parseFloat(px) || 0, parseFloat(pz) || 0, parseFloat(py) || 0); // Note: Z UI -> Y 3D
        } else if (selectVal !== "" && selectVal !== "origin") {
          const pObj = geometryManager.points[parseInt(selectVal)];
          if (pObj) newStart.copy(pObj.position);
        } else if (selectVal === "origin") {
          newStart.set(0, 0, 0);
        } else {
          newStart.set(pointText.x, pointText.z, pointText.y); // Note: Z UI -> Y 3D
        }

        // 4. Vecteur Directeur
        const newDir = new THREE.Vector3(vector.x, vector.z, vector.y); // Note: Z UI -> Y 3D
        if (newDir.lengthSq() < 1e-8) {
          showSplashScreen("Erreur : Vecteur directeur nul.");
          return;
        }

        // =========================================================
        // 5. MISE √Ä JOUR DES DONN√âES ET DE LA SC√àNE (CRITIQUE)
        // =========================================================

        // A. Mise √† jour de l'objet JS
        line.name = name || line.name;
        line.startPoint.copy(newStart);
        line.directorVector.copy(newDir);

        // B. Mise √† jour du Mesh (Visuel)
        // IMPORTANT : On remet le conteneur √† 0 pour que la g√©om√©trie absolue fonctionne
        line.mesh.position.set(0, 0, 0);
        line.mesh.rotation.set(0, 0, 0);
        line.mesh.scale.set(1, 1, 1);
        line.mesh.updateMatrix();

        // C. Recalculer les points de la ligne
        const len = 1000; // Longueur visuelle
        const dirNorm = newDir.clone().normalize();
        const pA = newStart.clone().addScaledVector(dirNorm, -len);
        const pB = newStart.clone().addScaledVector(dirNorm, len);

        // D. Remplacer la g√©om√©trie
        line.mesh.geometry.dispose(); // Nettoyer m√©moire
        line.mesh.geometry = new THREE.BufferGeometry().setFromPoints([pA, pB]);

        // E. Si le Gizmo tenait la ligne, il faut le rafra√Æchir
        if (selectedObjectInstance === line && typeof transformControl !== "undefined") {
          transformControl.detach();
          transformControl.attach(line.mesh);
        }

        // 6. Mise √† jour de l'interface (Liste √† gauche)
        updateAllUI(); // Ceci met √† jour la liste "Droites existantes"
        saveState(); // Historique

        // 7. Sortir du mode √©dition
        cancelLineEdit();
        showSplashScreen(`‚úÖ Droite mise √† jour !`);
      }

      function cancelLineEdit() {
        // Vider
        document.getElementById("editLineId").value = "";
        document.getElementById("lineNameFromEquation").value = "";
        document.getElementById("lineEquationInput").value = "x = 2t\ny = t\nz = -5t";
        document.getElementById("lineEqPointX").value = "";
        document.getElementById("lineEqPointY").value = "";
        document.getElementById("lineEqPointZ").value = "";
        document.getElementById("lineEquationPointSelect").value = "";

        // Basculer boutons
        document.getElementById("addLineFromEquationBtn").style.display = "block";
        document.getElementById("lineEquationActions").style.display = "none";

        // D√©s√©lectionner
        deselectCurrentObject();
      }

      function deleteEditingLine() {
        const id = parseInt(document.getElementById("editLineId").value);
        if (!isNaN(id)) {
          removeStraightLineById(id);
          cancelLineEdit();
        }
      }

      function cancelLineEdit() {
        // Vider les champs
        document.getElementById("lineNameFromEquation").value = "";
        document.getElementById("lineEquationInput").value = "x = 2t\ny = t\nz = -5t"; // Valeur par d√©faut
        document.getElementById("editLineId").value = "";
        document.getElementById("lineEqPointX").value = "";
        document.getElementById("lineEqPointY").value = "";
        document.getElementById("lineEqPointZ").value = "";
        document.getElementById("lineEquationPointSelect").value = "";

        // Basculer l'affichage des boutons
        document.getElementById("addLineFromEquationBtn").style.display = "block";
        document.getElementById("lineEquationActions").style.display = "none";

        // D√©s√©lectionner
        deselectCurrentObject();
      }

      function deleteEditingLine() {
        const id = parseInt(document.getElementById("editLineId").value);
        if (!isNaN(id)) {
          removeStraightLineById(id); // Fonction existante
          cancelLineEdit();
        }
      }

      function updatePlane() {
        const idVal = document.getElementById("editPlaneId").value;
        if (!idVal) return;

        const id = parseInt(idVal);
        const plane = geometryManager.findPlaneById(id);
        if (!plane) return;

        let equationStr = document.getElementById("planeEquationInput").value.trim();
        if (!equationStr) {
          showSplashScreen("L'√©quation est vide.");
          return;
        }

        // --- 1. Parsing de l'√©quation (Identique √† addPlaneFromEquation) ---
        if (equationStr.includes("=")) {
          const parts = equationStr.split("=");
          equationStr = `${parts[0]} - (${parts[1]})`;
        }

        const getCoefficient = (variable) => {
          const regex = new RegExp(`([+-]?[\\d\\.]*)\\s*\\*?\\s*${variable}`, "gi");
          let total = 0;
          let match;
          while ((match = regex.exec(equationStr)) !== null) {
            let s = match[1].replace(/\s/g, "");
            if (s === "" || s === "+") total += 1;
            else if (s === "-") total += -1;
            else total += parseFloat(s);
          }
          return total;
        };

        const a = getCoefficient("x");
        const b = getCoefficient("y"); // UI Y (Prof) -> 3D Z
        const c = getCoefficient("z"); // UI Z (Haut) -> 3D Y

        // Normale ThreeJS (x, y, z) -> (a, c, b)
        const newNormalUnnormalized = new THREE.Vector3(a, c, b);

        if (newNormalUnnormalized.lengthSq() < 1e-8) {
          showSplashScreen("Vecteur normal invalide.");
          return;
        }

        const newNormal = newNormalUnnormalized.clone().normalize();

        // --- 2. Point de passage ---
        const pxStr = document.getElementById("planeEqPointX").value;
        const pyStr = document.getElementById("planeEqPointY").value;
        const pzStr = document.getElementById("planeEqPointZ").value;
        const selectVal = document.getElementById("planeEquationPointSelect").value;

        let newPoint = new THREE.Vector3();

        // Priorit√© 1 : Manuel
        if (pxStr !== "" || pyStr !== "" || pzStr !== "") {
          newPoint.set(parseFloat(pxStr) || 0, parseFloat(pzStr) || 0, parseFloat(pyStr) || 0);
        }
        // Priorit√© 2 : Select
        else if (selectVal !== "" && selectVal !== "origin") {
          const pObj = geometryManager.points[parseInt(selectVal)];
          if (pObj) newPoint.copy(pObj.position);
        } else if (selectVal === "origin") {
          newPoint.set(0, 0, 0);
        }
        // Priorit√© 3 : Calcul via 'd' (Auto)
        else {
          let constantStr = equationStr
            .replace(/[+-]?[\d\\.]*\s*\*?\s*[xyz]/gi, "")
            .replace(/--/g, "+")
            .trim();
          let d = 0;
          try {
            if (constantStr) d = new Function("return " + constantStr)();
          } catch (e) {}

          // Trouver un point valide
          if (Math.abs(newNormalUnnormalized.x) > 1e-6) newPoint.set(-d / newNormalUnnormalized.x, 0, 0);
          else if (Math.abs(newNormalUnnormalized.z) > 1e-6)
            newPoint.set(0, 0, -d / newNormalUnnormalized.z); // Z 3D = Y UI (b)
          else if (Math.abs(newNormalUnnormalized.y) > 1e-6) newPoint.set(0, -d / newNormalUnnormalized.y, 0); // Y 3D = Z UI (c)
        }

        // --- 3. MISE √Ä JOUR OBJET ET SC√àNE ---

        // A. Mise √† jour donn√©es
        plane.normal.copy(newNormal);
        plane.displayNormal.copy(newNormalUnnormalized); // On garde (a,c,b) pour l'affichage
        plane.pointOnPlane.copy(newPoint);

        // B. Mise √† jour Mesh
        // Position
        plane.mesh.position.copy(plane.pointOnPlane);
        // Rotation (Quaternion pour aligner Z local avec la normale)
        plane.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), plane.normal);
        plane.mesh.updateMatrix();

        // C. Gestion Gizmo
        if (selectedObjectInstance === plane && typeof transformControl !== "undefined") {
          transformControl.detach();
          transformControl.attach(plane.mesh);
        }

        // D. Gestion Vecteur Normal affich√© (Vn)
        // Si le bouton "Vn" est actif, on doit mettre √† jour le vecteur visuel aussi
        const existingVn = geometryManager.vectors.find((v) => v.parentPlaneId === plane.id && v.isNormalVector);
        if (existingVn) {
          // Vn part du point du plan et suit la normale
          const vnLength = 2.5;
          const vnComps = plane.normal.clone().multiplyScalar(vnLength);
          existingVn.update(existingVn.name, plane.pointOnPlane, vnComps);
        }

        // --- 4. Finalisation ---
        updateAllUI();
        saveState();
        cancelPlaneEdit();
        showSplashScreen(`‚úÖ Plan mis √† jour !`);
      }

      function cancelPlaneEdit() {
        // Reset champs
        document.getElementById("editPlaneId").value = "";
        document.getElementById("planeEquationInput").value = "";
        document.getElementById("planeEqPointX").value = "";
        document.getElementById("planeEqPointY").value = "";
        document.getElementById("planeEqPointZ").value = "";
        document.getElementById("planeEquationPointSelect").value = "";

        // Reset boutons
        document.getElementById("addPlaneFromEquationBtn").style.display = "block";
        document.getElementById("planeEquationActions").style.display = "none";

        deselectCurrentObject();
      }

      function deleteEditingPlane() {
        const id = parseInt(document.getElementById("editPlaneId").value);
        if (!isNaN(id)) {
          removePlaneById(id); // Utilise la fonction existante
          cancelPlaneEdit();
        }
      }
      /**
       * Exporte la sc√®ne actuelle dans un fichier JSON t√©l√©chargeable.
       * Utilise le format interne serializeSceneData() pour garantir une compatibilit√© totale √† l'import.
       */
      /**
       * Exporte la sc√®ne actuelle dans un fichier JSON avec m√©tadonn√©es.
       */
      function exportSceneToJSON() {
        try {
          // 1. On r√©cup√®re les donn√©es de g√©om√©trie brutes (celles utilis√©es par l'historique)
          const rawData = JSON.parse(serializeSceneData());

          // 2. On construit l'objet final en ajoutant le bloc "meta" demand√©
          const exportData = {
            meta: {
              appName: "√âditeur Points 3D",
              date: new Date().toLocaleString(),
              timestamp: Date.now(),
              // On calcule le total en v√©rifiant que les tableaux existent
              totalObjects:
                (rawData.points ? rawData.points.length : 0) +
                (rawData.vectors ? rawData.vectors.length : 0) +
                (rawData.lines ? rawData.lines.length : 0) +
                (rawData.planes ? rawData.planes.length : 0),
            },
            // 3. On fusionne les donn√©es g√©om√©triques (points, vectors, etc.) √† la racine de l'objet
            ...rawData,
          };

          // 4. Conversion en texte (avec indentation pour que ce soit lisible par un humain)
          const jsonString = JSON.stringify(exportData, null, 2);

          // 5. Cr√©ation et t√©l√©chargement du fichier
          const blob = new Blob([jsonString], { type: "application/json" });
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          // Format du nom de fichier : scene_YYYY-MM-DD_HH-MM.json
          const dateStr = new Date().toISOString().slice(0, 16).replace(/[:T]/g, "-");
          a.download = `scene_3d_${dateStr}.json`;
          a.href = url;

          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          showSplashScreen("‚úÖ Sc√®ne export√©e avec m√©tadonn√©es !");
        } catch (e) {
          console.error(e);
          showSplashScreen("‚ùå Erreur lors de l'export.");
        }
      }
      /**
       * Importe une sc√®ne depuis un fichier JSON s√©lectionn√© par l'utilisateur.
       * @param {HTMLInputElement} inputElement - L'√©l√©ment input type="file"
       */
      function importSceneFromJSON(inputElement) {
        const file = inputElement.files[0];

        if (!file) return;

        // S√©curit√© : Demander confirmation car cela va √©craser la sc√®ne actuelle
        if (!confirm("Attention : L'importation va remplacer la sc√®ne actuelle. Voulez-vous continuer ?")) {
          inputElement.value = ""; // Reset de l'input
          return;
        }

        const reader = new FileReader();

        reader.onload = function (e) {
          try {
            const jsonContent = e.target.result;

            // On utilise la fonction existante restoreSceneData qui g√®re d√©j√† tout le nettoyage et la reconstruction
            restoreSceneData(jsonContent);

            // On sauvegarde cet √©tat dans l'historique pour pouvoir faire "Annuler" si l'import n'est pas voulu
            saveState();

            showSplashScreen(`‚úÖ Sc√®ne "${file.name}" import√©e !`);
          } catch (err) {
            console.error(err);
            showSplashScreen("‚ùå Erreur : Fichier invalide ou corrompu.");
          }

          // Reset de l'input pour permettre de r√©importer le m√™me fichier si besoin
          inputElement.value = "";
        };

        reader.readAsText(file);
      }

      // =====================================================================================
      // SECTION TABLEUR (SPREADSHEET) LOGIC
      // =====================================================================================

      let isSpreadsheetOpen = false;
      let currentSpreadsheetTab = "points";

      function toggleSpreadsheet() {
        const panel = document.getElementById("spreadsheetContainer");
        const btn = document.getElementById("openSpreadsheetBtn");

        isSpreadsheetOpen = !isSpreadsheetOpen;

        if (isSpreadsheetOpen) {
          panel.classList.remove("spreadsheet-hidden");
          btn.style.display = "none"; // Cache le bouton d'ouverture
          updateSpreadsheet(); // Rafra√Æchir les donn√©es
        } else {
          panel.classList.add("spreadsheet-hidden");
          setTimeout(() => {
            btn.style.display = "block"; // R√©affiche le bouton apr√®s l'anim
          }, 300);
        }
      }

      function switchSpreadsheetTab(tabName) {
        currentSpreadsheetTab = tabName;

        // Mise √† jour visuelle des onglets
        document.querySelectorAll(".tab-btn").forEach((btn) => {
          btn.classList.remove("active");
          if (btn.textContent.toLowerCase().includes(tabName.substring(0, 4))) {
            // d√©tection simple
            btn.classList.add("active");
          }
        });

        // Mapping du bouton cliqu√© (plus robuste)
        const buttons = document.querySelectorAll(".tab-btn");
        if (tabName === "points") buttons[0].classList.add("active");
        if (tabName === "vectors") buttons[1].classList.add("active");
        if (tabName === "lines") buttons[2].classList.add("active");
        if (tabName === "planes") buttons[3].classList.add("active");

        updateSpreadsheet();
      }

      /**
       * Fonction principale qui reconstruit le tableau HTML
       */
      function updateSpreadsheet() {
        if (!isSpreadsheetOpen) return;

        const thead = document.querySelector("#spreadsheetTable thead");
        const tbody = document.querySelector("#spreadsheetTable tbody");
        thead.innerHTML = "";
        tbody.innerHTML = "";

        if (currentSpreadsheetTab === "points") {
          renderPointsTable(thead, tbody);
        } else if (currentSpreadsheetTab === "vectors") {
          renderVectorsTable(thead, tbody);
        } else if (currentSpreadsheetTab === "lines") {
          renderLinesTable(thead, tbody);
        } else if (currentSpreadsheetTab === "planes") {
          renderPlanesTable(thead, tbody);
        }
      }

      // --- RENDU DES POINTS ---
      function renderPointsTable(thead, tbody) {
        thead.innerHTML = `
    <tr>
      <th style="width:50px">ID</th>
      <th>Nom</th>
      <th style="width:80px">X</th>
      <th style="width:80px">Y (Prof)</th>
      <th style="width:80px">Z (Haut)</th>
      <th style="width:60px">Actions</th>
    </tr>`;

        geometryManager.points.forEach((p, index) => {
          const tr = document.createElement("tr");
          tr.id = `sheet-row-point-${index}`;
          // Attention mapping : UI Y = Three Z, UI Z = Three Y
          tr.innerHTML = `
      <td>${index}</td>
      <td><input type="text" value="${p.name}" onchange="sheetUpdatePointName(${index}, this.value)"></td>
      <td class="col-x"><input type="number" step="0.1" id="sheet-p-${index}-x" value="${formatNumber(
            p.position.x
          )}" onchange="sheetUpdatePointCoords(${index})"></td>
      <td class="col-y"><input type="number" step="0.1" id="sheet-p-${index}-y" value="${formatNumber(
            p.position.z
          )}" onchange="sheetUpdatePointCoords(${index})"></td>
      <td class="col-z"><input type="number" step="0.1" id="sheet-p-${index}-z" value="${formatNumber(
            p.position.y
          )}" onchange="sheetUpdatePointCoords(${index})"></td>
      <td>
        <button class="btn-secondary" style="padding:2px 5px; margin:0;" onclick="handleSelection(geometryManager.points[${index}].mesh)">üéØ</button>
      </td>
    `;
          tbody.appendChild(tr);
        });
      }

      // --- LOGIQUE DE MISE √Ä JOUR DEPUIS LE TABLEUR (POINTS) ---
      function sheetUpdatePointName(index, newName) {
        const p = geometryManager.points[index];
        if (p) {
          p.update(newName, p.position.x, p.position.z, p.position.y); // update attend (nom, x, z_ui, y_ui)
          updateAllUI(); // Rafra√Æchir liste lat√©rale
        }
      }

      function sheetUpdatePointCoords(index) {
        const p = geometryManager.points[index];
        if (!p) return;

        const x = parseFloat(document.getElementById(`sheet-p-${index}-x`).value);
        const y_ui = parseFloat(document.getElementById(`sheet-p-${index}-y`).value); // Profondeur (Z Three)
        const z_ui = parseFloat(document.getElementById(`sheet-p-${index}-z`).value); // Hauteur (Y Three)

        if (isNaN(x) || isNaN(y_ui) || isNaN(z_ui)) return;

        // On utilise copy pour √©viter de recr√©er l'objet si possible, ou p.update
        p.position.set(x, z_ui, y_ui); // Attention ordre ThreeJS
        p.mesh.position.copy(p.position);
        p.updateLabelPosition();

        // Si Gizmo actif sur ce point
        if (selectedObjectInstance === p && transformControl) {
          transformControl.attach(p.mesh); // Recalage du gizmo
        }

        saveState();
        // On ne rappelle pas updateAllUI() complet ici pour √©viter de perdre le focus de l'input
        // Mais on doit mettre √† jour le panneau lat√©ral si besoin
        // updatePointList(); // Optionnel
      }

      // --- RENDU DES VECTEURS ---
      function renderVectorsTable(thead, tbody) {
        thead.innerHTML = `
    <tr>
      <th>Nom</th>
      <th>Origine X</th><th>Origine Y</th><th>Origine Z</th>
      <th>Vect X</th><th>Vect Y</th><th>Vect Z</th>
    </tr>`;

        geometryManager.vectors.forEach((v) => {
          const tr = document.createElement("tr");
          tr.id = `sheet-row-vector-${v.id}`;
          // Origine
          const ox = formatNumber(v.origin.x);
          const oy = formatNumber(v.origin.z); // UI Y
          const oz = formatNumber(v.origin.y); // UI Z
          // Composantes
          const vx = formatNumber(v.components.x);
          const vy = formatNumber(v.components.z); // UI Y
          const vz = formatNumber(v.components.y); // UI Z

          tr.innerHTML = `
      <td><input type="text" value="${v.name}" onchange="sheetUpdateVector(${v.id})"></td>
      <td class="col-x"><input type="number" id="sheet-v-${v.id}-ox" value="${ox}" onchange="sheetUpdateVector(${v.id})"></td>
      <td class="col-y"><input type="number" id="sheet-v-${v.id}-oy" value="${oy}" onchange="sheetUpdateVector(${v.id})"></td>
      <td class="col-z"><input type="number" id="sheet-v-${v.id}-oz" value="${oz}" onchange="sheetUpdateVector(${v.id})"></td>
      <td class="col-x" style="border-left:2px solid #ddd"><input type="number" id="sheet-v-${v.id}-vx" value="${vx}" onchange="sheetUpdateVector(${v.id})"></td>
      <td class="col-y"><input type="number" id="sheet-v-${v.id}-vy" value="${vy}" onchange="sheetUpdateVector(${v.id})"></td>
      <td class="col-z"><input type="number" id="sheet-v-${v.id}-vz" value="${vz}" onchange="sheetUpdateVector(${v.id})"></td>
    `;
          tbody.appendChild(tr);
        });
      }

      function sheetUpdateVector(id) {
        const v = geometryManager.findVectorById(id);
        if (!v) return;

        // R√©cup√©ration ligne par ID pour √™tre s√ªr (ou par element relatif si on passait 'this')
        // Ici on utilise les IDs g√©n√©r√©s
        const ox = parseFloat(document.getElementById(`sheet-v-${id}-ox`).value);
        const oy = parseFloat(document.getElementById(`sheet-v-${id}-oy`).value);
        const oz = parseFloat(document.getElementById(`sheet-v-${id}-oz`).value);

        const vx = parseFloat(document.getElementById(`sheet-v-${id}-vx`).value);
        const vy = parseFloat(document.getElementById(`sheet-v-${id}-vy`).value);
        const vz = parseFloat(document.getElementById(`sheet-v-${id}-vz`).value);

        // Reconstruction vecteurs ThreeJS (Attention inversion Y/Z)
        const newOrigin = new THREE.Vector3(ox, oz, oy);
        const newComps = new THREE.Vector3(vx, vz, vy);

        v.update(v.name, newOrigin, newComps);

        if (selectedObjectInstance === v && transformControl) {
          // Astuce pour le gizmo vecteur : il faut le r√©attacher au nouvel arrowHelper
          transformControl.detach();
          transformControl.attach(v.arrowHelper);
        }
        saveState();
      }

      // Pour Droites et Plans, on fait simple pour l'instant (Nom + Point principal)
      function renderLinesTable(thead, tbody) {
        thead.innerHTML = `<tr><th>Nom</th><th>Point X</th><th>Point Y</th><th>Point Z</th><th>Dir X</th><th>Dir Y</th><th>Dir Z</th></tr>`;
        geometryManager.lines.forEach((l) => {
          const p = l.startPoint;
          const u = l.directorVector;
          tbody.innerHTML += `<tr>
            <td>${l.name}</td>
            <td class="col-x">${formatNumber(p.x)}</td><td class="col-y">${formatNumber(
            p.z
          )}</td><td class="col-z">${formatNumber(p.y)}</td>
            <td class="col-x">${formatNumber(u.x)}</td><td class="col-y">${formatNumber(
            u.z
          )}</td><td class="col-z">${formatNumber(u.y)}</td>
        </tr>`;
        });
      }

      function renderPlanesTable(thead, tbody) {
        thead.innerHTML = `<tr><th>Nom</th><th>Point X</th><th>Point Y</th><th>Point Z</th><th>Norm X</th><th>Norm Y</th><th>Norm Z</th></tr>`;
        geometryManager.planes.forEach((p) => {
          const pt = p.pointOnPlane;
          const n = p.displayNormal;
          tbody.innerHTML += `<tr>
            <td>${p.name}</td>
            <td class="col-x">${formatNumber(pt.x)}</td><td class="col-y">${formatNumber(
            pt.z
          )}</td><td class="col-z">${formatNumber(pt.y)}</td>
            <td class="col-x">${formatNumber(n.x)}</td><td class="col-y">${formatNumber(
            n.z
          )}</td><td class="col-z">${formatNumber(n.y)}</td>
        </tr>`;
        });
      }

      let currentSnapSize = 1.0; // Variable modifiable au lieu de const
      const SNAP_ROTATE = THREE.MathUtils.degToRad(15); // Rotation toujours fix√©e √† 15¬∞

      function updateSnapSize() {
        const select = document.getElementById("snapSizeSelect");
        if (!select) return;

        // Mettre √† jour la variable globale
        currentSnapSize = parseFloat(select.value);

        // Si l'aimant est d√©j√† activ√©, on met √† jour le contr√¥le imm√©diatement
        if (snapEnabled && transformControl) {
          transformControl.setTranslationSnap(currentSnapSize);
          showSplashScreen(`Taille de l'aimant : ${currentSnapSize}`);
        }
      }

      function toggleSnapping() {
        const checkbox = document.getElementById("snapToggle");
        const icon = document.getElementById("snapIcon");
        const select = document.getElementById("snapSizeSelect");

        snapEnabled = checkbox.checked;

        if (transformControl) {
          // On utilise la variable currentSnapSize ici
          transformControl.setTranslationSnap(snapEnabled ? currentSnapSize : null);
          transformControl.setRotationSnap(snapEnabled ? SNAP_ROTATE : null);

          // GESTION VISUELLE
          if (snapEnabled) {
            icon.classList.remove("icon-disabled");
            // On peut aussi changer la couleur du texte du select pour montrer qu'il est actif
            select.style.opacity = "1";
            showSplashScreen(`üß≤ Aimantation ACTIV√âE (${currentSnapSize})`);
          } else {
            icon.classList.add("icon-disabled");
            // On grise l√©g√®rement le select quand d√©sactiv√©
            select.style.opacity = "0.5";
            showSplashScreen("Aimantation D√âSACTIV√âE");
          }
        }
      }
      function projectPointOnPlane() {
        const pIndex = document.getElementById("projPointSelect").value;
        const plIndex = document.getElementById("projPlaneSelect").value;

        if (pIndex === "" || plIndex === "") return;

        const point = geometryManager.points[pIndex];
        const plane = geometryManager.findPlaneById(parseInt(plIndex));

        // Math√©matiques de la projection
        // H = P - (distSign√©e * n)
        const vP0P = new THREE.Vector3().subVectors(point.position, plane.pointOnPlane);
        const distSigned = vP0P.dot(plane.normal);
        const projectedPos = point.position.clone().sub(plane.normal.clone().multiplyScalar(distSigned));

        // 1. Cr√©er le point projet√© H
        const hName = `Proj_${point.name}`;
        const hPoint = new Point(
          geometryManager.generateUniqueName(hName, "point"),
          projectedPos.x,
          projectedPos.y,
          projectedPos.z,
          0x555555
        ); // Gris
        // Attention constructeur Point(name, x, y, z) -> ThreeJS Y/Z inversion dans votre code original ? V√©rifiez l'ordre.
        // Si votre constructeur est Point(name, x, z_ui, y_ui), passez (projectedPos.x, projectedPos.z, projectedPos.y)

        geometryManager.addPoint(hPoint);

        // 2. Cr√©er le segment en pointill√© [PH]
        const dashMaterial = new THREE.LineDashedMaterial({ color: 0x555555, dashSize: 0.5, gapSize: 0.2 });
        const geom = new THREE.BufferGeometry().setFromPoints([point.position, hPoint.position]);
        const dashLine = new THREE.Line(geom, dashMaterial);
        dashLine.computeLineDistances(); // Important pour les pointill√©s
        scene.add(dashLine);

        // On ne stocke pas la ligne pointill√©e dans le manager pour l'instant (c'est juste visuel temporaire)
        // Ou alors cr√©ez une classe "ConstructionLine"

        updateAllUI();
        saveState();
        showSplashScreen(`Point ${hPoint.name} cr√©√©.`);
      }
    </script>
  </body>
</html>
